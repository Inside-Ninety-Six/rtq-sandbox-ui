<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>RTQ – Maths Paper Solution Viewer (Stress Test)</title>

    <style>
        :root {
            --page-bg: #f4f2ee;
            /* soft-warm neutral base */
            --surface: #f8f7f4;
            /* unified main surface */
            --ink: #1b1b1b;
            /* question text contrast ceiling */
            --ink-2: #2c2c2c;
            --ink-3: #3a3a3a;
            --quiet: #606060;
            --hairline: rgba(0, 0, 0, .14);
            --hairline-2: rgba(0, 0, 0, .10);
            --wash: rgba(0, 0, 0, .035);
            /* subtle solution region wash */
            --katex-underlay: rgba(0, 0, 0, .03);
            /* display-math underlay inside working/alt only */
            --frame-max: 1120px;

            --gutter: 20px;
            --nav-w: 108px;

            --q-gap: 26px;
            --qa-gap: 10px;
            --ans-gap: 8px;
            --sd-gap: 12px;
            --sd-block-gap: 12px;

            --focus: rgba(0, 0, 0, .35);
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: var(--page-bg);
            color: var(--ink);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.45;
        }

        /* Top controls (aligned to centered frame) */
        header {
            position: sticky;
            top: 0;
            z-index: 30;
            background: var(--page-bg);
            border-bottom: 1px solid var(--hairline-2);
        }

        .topbar {
            max-width: var(--frame-max);
            margin: 0 auto;
            padding: 12px var(--gutter);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .topbar .label {
            font-size: 13px;
            color: var(--quiet);
            white-space: nowrap;
        }

        select {
            font: inherit;
            font-size: 14px;
            padding: 8px 10px;
            border: 1px solid var(--hairline);
            border-radius: 6px;
            /* small control affordance; not content framing */
            background: var(--surface);
            color: var(--ink-2);
            max-width: min(520px, 100%);
        }

        /* Mobile nav toggle */
        .jump {
            margin-left: auto;
            display: none;
            font: inherit;
            font-size: 14px;
            padding: 8px 10px;
            border: 1px solid var(--hairline);
            border-radius: 6px;
            background: var(--surface);
            color: var(--ink-2);
            cursor: pointer;
        }

        .jump:hover {
            text-decoration: underline;
        }

        .jump:active {
            transform: translateY(1px);
        }

        .jump:focus-visible {
            outline: 2px solid var(--focus);
            outline-offset: 2px;
        }

        /* Main centered frame containing nav + content, unified surface */
        .frame {
            max-width: var(--frame-max);
            margin: 16px auto 60px;
            padding: 0 var(--gutter);
        }

        .surface {
            background: var(--surface);
            border: 1px solid var(--hairline-2);
            border-radius: 10px;
            /* applies to entire frame surface only (nav+content together) */
            padding: 18px 16px;
        }

        .layout {
            display: grid;
            grid-template-columns: var(--nav-w) 1fr;
            gap: 24px;
            align-items: start;
        }

        /* Navigation rail (quiet, no panel background) */
        nav {
            position: sticky;
            top: 64px;
            /* below header */
            align-self: start;
            padding-top: 2px;
            background: transparent;
        }

        .navlist {
            max-height: calc(100vh - 92px);
            overflow: auto;
            padding-right: 4px;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* legacy */
        }

        .navlist::-webkit-scrollbar {
            display: none;
        }

        /* WebKit/Blink */

        .nav-title {
            font-size: 12px;
            color: var(--quiet);
            letter-spacing: .02em;
            margin: 0 0 10px 0;
        }

        .nav-items {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .nav-section {
            margin: 10px 0 6px;
            font-size: 12px;
            color: var(--quiet);
        }

        .nav-items li {
            margin: 0;
            padding: 0;
        }

        .navbtn {
            width: 100%;
            text-align: left;
            font: inherit;
            font-size: 13px;
            color: var(--quiet);
            background: transparent;
            border: 0;
            padding: 6px 2px;
            cursor: pointer;
            border-radius: 6px;
        }

        .navbtn:hover {
            text-decoration: underline;
        }

        .navbtn:focus-visible {
            outline: 2px solid var(--focus);
            outline-offset: 2px;
            text-decoration: none;
        }

        .navbtn[aria-current="true"] {
            color: var(--ink-2);
            font-weight: 600;
            /* bold only for current nav item */
            text-decoration: none;
        }

        /* Paper content */
        main {
            min-width: 0;
            /* critical for KaTeX containment */
        }

        .paper-meta {
            margin: 0 0 14px 0;
            font-size: 13px;
            color: var(--quiet);
        }

        /* Questions (spacing rhythm; no cards) */
        .q {
            margin: 0 0 var(--q-gap) 0;
            padding: 0;
        }

        .q:last-child {
            margin-bottom: 0;
        }

        .qline {
            display: block;
        }

        .qid {
            display: inline-block;
            font-size: 14px;
            color: var(--ink-3);
            margin-right: 10px;
            white-space: nowrap;
        }

        .qtext {
            display: inline;
            font-size: 16px;
            line-height: 1.55;
            color: var(--ink);
        }

        /* Sub-question indentation & separation (no container) */
        .depth-0 {
            margin-left: 0;
        }

        .depth-1 {
            margin-left: 18px;
            margin-top: 16px;
            margin-bottom: 16px;
        }

        .depth-2 {
            margin-left: 34px;
            margin-top: 12px;
            margin-bottom: 12px;
        }

        .depth-3 {
            margin-left: 46px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        @media (max-width: 520px) {
            .depth-1 {
                margin-left: 12px;
            }

            .depth-2 {
                margin-left: 22px;
            }

            .depth-3 {
                margin-left: 30px;
            }
        }

        /* Answer */
        .answer {
            margin-top: var(--qa-gap);
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .alabel {
            font-size: 13px;
            font-weight: 600;
            color: var(--ink-3);
            flex: 0 0 auto;
            margin-top: 2px;
        }

        .avalue {
            font-size: 14px;
            color: var(--ink-2);
            min-width: 0;
        }

        /* Disclosure control (text-first, not button-like) */
        .toggle-row {
            margin-top: var(--ans-gap);
        }

        .toggle {
            font: inherit;
            font-size: 14px;
            color: var(--ink-3);
            background: transparent;
            border: 0;
            padding: 4px 0;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .toggle:hover {
            text-decoration: underline;
        }

        .toggle:focus-visible {
            outline: 2px solid var(--focus);
            outline-offset: 2px;
            border-radius: 6px;
            text-decoration: none;
        }

        .chev {
            width: 10px;
            height: 10px;
            display: inline-block;
            border-right: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(45deg);
            margin-top: -1px;
        }

        .toggle[aria-expanded="true"] .chev {
            transform: rotate(-135deg);
            margin-top: 3px;
        }

        /* Solution Details region (quiet signature) */
        .solution {
            margin-top: var(--sd-gap);
            padding: 12px 12px 10px 12px;
            background: var(--wash);
            border: 0;
            /* no framing */
        }

        .sd-divider {
            height: 1px;
            background: var(--hairline);
            margin: 10px 0;
        }

        .sd-block {
            margin: 0;
            padding: 0;
        }

        .sd-block+.sd-block {
            margin-top: var(--sd-block-gap);
        }

        .sd-label {
            font-size: 13px;
            font-weight: 600;
            /* labels only */
            color: var(--ink-3);
            margin: 0 0 6px 0;
        }

        .sd-body {
            font-size: 14px;
            color: var(--ink-2);
            line-height: 1.45;
            min-width: 0;
        }

        /* Markdown defaults (quiet, paper-like) */
        .md p {
            margin: 0 0 10px 0;
        }

        .md p:last-child {
            margin-bottom: 0;
        }

        .md ul,
        .md ol {
            margin: 0 0 10px 20px;
            padding: 0;
        }

        .md li {
            margin: 0 0 6px 0;
        }

        .md table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
            font-size: 13px;
        }

        .md th,
        .md td {
            border: 1px solid var(--hairline);
            padding: 6px 8px;
            vertical-align: top;
        }

        .md th {
            font-weight: 600;
            color: var(--ink-3);
        }

        .md code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.95em;
        }

        .md pre {
            overflow: auto;
            padding: 10px 12px;
            border: 1px solid var(--hairline);
            background: transparent;
            /* no code block chrome */
        }

        /* Diagrams (inline SVG passthrough) */
        .md svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px 0;
        }

        /* KaTeX containment invariant */
        .katex,
        .katex * {
            max-width: 100%;
        }

        .katex-display {
            max-width: 100%;
            overflow-x: auto;
            /* allowed only within display math */
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* Prevent display blocks from widening layout */
        .katex-display>.katex {
            display: inline-block;
            max-width: 100%;
        }

        /* Display-math underlay permission: only inside Working/Alternative working bodies */
        .sd-body[data-underlay="true"] .katex-display {
            background: var(--katex-underlay);
            padding: 6px 8px;
            margin: 10px 0;
        }

        /* Inline math must never receive a background */
        .katex-inline {
            background: transparent !important;
        }

        /* Expand/collapse transition (continuity, restrained) */
        .collapsible {
            overflow: hidden;
            transition: max-height 180ms ease;
        }

        @media (prefers-reduced-motion: reduce) {
            html {
                scroll-behavior: auto;
            }

            .collapsible {
                transition: none;
            }
        }

        @media (prefers-reduced-motion: no-preference) {
            html {
                scroll-behavior: smooth;
            }
        }

        /* Mobile drawer */
        .drawer-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .22);
            z-index: 60;
            display: none;
        }

        .drawer {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            width: min(320px, 84vw);
            background: var(--surface);
            border-right: 1px solid var(--hairline);
            z-index: 70;
            transform: translateX(-100%);
            transition: transform 180ms ease;
            display: flex;
            flex-direction: column;
        }

        .drawer header {
            position: static;
            border-bottom: 1px solid var(--hairline-2);
            background: transparent;
        }

        .drawer-top {
            padding: 12px 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .drawer-top .dt {
            font-size: 13px;
            color: var(--quiet);
        }

        .close {
            font: inherit;
            font-size: 14px;
            padding: 6px 8px;
            border: 1px solid var(--hairline);
            border-radius: 6px;
            background: transparent;
            cursor: pointer;
        }

        .close:hover {
            text-decoration: underline;
        }

        .close:focus-visible {
            outline: 2px solid var(--focus);
            outline-offset: 2px;
        }

        .drawer .navlist {
            max-height: none;
            height: 100%;
            padding: 12px 14px;
        }

        .drawer-open .drawer-backdrop {
            display: block;
        }

        .drawer-open .drawer {
            transform: translateX(0);
        }

        /* Responsive layout */
        @media (max-width: 860px) {
            :root {
                --nav-w: 92px;
            }

            .layout {
                gap: 18px;
            }

            nav {
                top: 66px;
            }
        }

        @media (max-width: 760px) {
            .layout {
                grid-template-columns: 1fr;
            }

            nav {
                display: none;
            }

            .jump {
                display: inline-flex;
            }

            .surface {
                padding: 16px 14px;
            }
        }
    </style>

    <!-- Real KaTeX Rendering (CDN) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">

</head>

<body>
    <header>
        <div class="topbar" role="region" aria-label="Paper controls">
            <div class="label">Paper</div>
            <select id="paperSelect" aria-label="Paper selector"></select>
            <button class="jump" id="jumpBtn" type="button" aria-haspopup="dialog" aria-controls="drawer">Jump
                to</button>
        </div>
    </header>

    <div class="frame">
        <div class="surface">
            <div class="layout" aria-label="Paper layout">
                <nav aria-label="Document navigation">
                    <div class="nav-title">Jump</div>
                    <div class="navlist" id="navList" tabindex="0" aria-label="Question list"></div>
                </nav>

                <main id="paperMain" aria-label="Paper content">
                    <p class="paper-meta" id="paperMeta"></p>
                    <div id="paperContent"></div>
                </main>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="drawer-backdrop" id="backdrop" hidden></div>
    <aside class="drawer" id="drawer" role="dialog" aria-modal="true" aria-label="Navigation drawer" hidden>
        <header>
            <div class="drawer-top">
                <div class="dt">Jump</div>
                <button class="close" id="closeDrawer" type="button">Close</button>
            </div>
        </header>
        <div class="navlist" id="navListMobile" tabindex="0" aria-label="Question list"></div>
    </aside>

    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"
        crossorigin="anonymous"></script>

    <!-- KaTeX JS + auto-render -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
        crossorigin="anonymous"></script>

    <script>
        // CANONICAL CONSTANT — PAPERS PAYLOAD PATH (v1.0)
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.json";

        (function () {
            const els = {
                select: document.getElementById('paperSelect'),
                nav: document.getElementById('navList'),
                navMobile: document.getElementById('navListMobile'),
                paperMeta: document.getElementById('paperMeta'),
                paperContent: document.getElementById('paperContent'),
                main: document.getElementById('paperMain'),
                jumpBtn: document.getElementById('jumpBtn'),
                drawer: document.getElementById('drawer'),
                closeDrawer: document.getElementById('closeDrawer'),
                backdrop: document.getElementById('backdrop'),
            };

            // Markdown-it: HTML passthrough + TeX backslash preservation
            const md = window.markdownit({
                html: true,
                linkify: false,
                typographer: false,
                breaks: false
            });
            // Disable escape rule to preserve TeX backslashes exactly as authored
            if (md && md.inline && md.inline.ruler) {
                md.inline.ruler.disable(['escape']);
            }

            let payload = null;
            let activePaperIndex = 0;
            let expandedIds = new Set(); // question UID strings expanded (if not expandedAll)
            let expandedAll = false;
            let questionIndex = []; // list of { uid, id, el }
            let io = null;
            let lastActiveUid = null;

            function safeText(s) { return (s == null) ? '' : String(s); }

            function renderMarkdownToHTML(markdown) {
                const src = safeText(markdown);
                if (!src.trim()) return '';
                return md.render(src);
            }

            function runKatex(container) {
                // Step order: Markdown -> DOM -> KaTeX render across container
                if (!container) return;
                if (typeof window.renderMathInElement !== 'function') return;
                try {
                    window.renderMathInElement(container, {
                        delimiters: [
                            { left: "$$", right: "$$", display: true },
                            { left: "$", right: "$", display: false },
                        ],
                        throwOnError: false
                    });
                } catch (e) {
                    // Graceful fallback: leave content as-is (plain text/TeX)
                }
            }

            function hasAnySolutionContent(sd) {
                if (!sd || typeof sd !== 'object') return false;
                const keys = ['keepInMind', 'formulasUsed', 'working', 'alternativeWorking'];
                return keys.some(k => safeText(sd[k]).trim().length > 0);
            }

            function mk(tag, attrs, children) {
                const el = document.createElement(tag);
                if (attrs) {
                    for (const [k, v] of Object.entries(attrs)) {
                        if (v === null || v === undefined) continue;
                        if (k === 'class') el.className = v;
                        else if (k === 'html') el.innerHTML = v;
                        else if (k.startsWith('data-')) el.setAttribute(k, v);
                        else if (k === 'text') el.textContent = v;
                        else el.setAttribute(k, v);
                    }
                }
                if (children && Array.isArray(children)) children.forEach(c => el.appendChild(c));
                return el;
            }

            function flattenQuestionsForNav(paper) {
                // Returns items in authored order, including section separators for nav
                const items = [];
                const visit = (q) => {
                    items.push({ type: 'q', q });
                    if (Array.isArray(q.children)) {
                        q.children.forEach(ch => visit(ch));
                    }
                };

                if (Array.isArray(paper.sections)) {
                    paper.sections.forEach(sec => {
                        items.push({ type: 'section', label: safeText(sec.label) });
                        if (Array.isArray(sec.questions)) sec.questions.forEach(q => visit(q));
                    });
                } else if (Array.isArray(paper.questions)) {
                    paper.questions.forEach(q => visit(q));
                }
                return items;
            }

            function buildNav(container, items, isMobile) {
                container.innerHTML = '';
                const ul = mk('ul', { class: 'nav-items' });

                items.forEach(item => {
                    if (item.type === 'section') {
                        const li = mk('li', {});
                        li.appendChild(mk('div', { class: 'nav-section', text: safeText(item.label) }));
                        ul.appendChild(li);
                        return;
                    }
                    const q = item.q;
                    const uid = q.__uid;
                    const li = mk('li', {});
                    const btn = mk('button', {
                        type: 'button',
                        class: 'navbtn',
                        'data-uid': uid,
                        'aria-current': (uid === lastActiveUid) ? 'true' : 'false'
                    });
                    btn.textContent = safeText(q.id);
                    btn.addEventListener('click', () => {
                        const target = document.querySelector('[data-q-uid="' + CSS.escape(uid) + '"]');
                        if (target) {
                            target.scrollIntoView({ block: 'start', behavior: (prefersReducedMotion() ? 'auto' : 'smooth') });
                        }
                        if (isMobile) closeDrawer();
                    });
                    li.appendChild(btn);
                    ul.appendChild(li);
                });

                container.appendChild(ul);
            }

            function prefersReducedMotion() {
                return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }

            function setDrawerOpen(open) {
                document.body.classList.toggle('drawer-open', !!open);
                if (open) {
                    els.drawer.hidden = false;
                    els.backdrop.hidden = false;
                    // Trap focus: focus first meaningful control
                    els.closeDrawer.focus();
                    // Prevent background interaction for keyboard users by inert-like approach
                    els.main.setAttribute('aria-hidden', 'true');
                } else {
                    els.drawer.hidden = true;
                    els.backdrop.hidden = true;
                    els.main.removeAttribute('aria-hidden');
                    els.jumpBtn.focus();
                }
            }

            function openDrawer() { setDrawerOpen(true); }
            function closeDrawer() { setDrawerOpen(false); }

            function wireDrawer() {
                els.jumpBtn.addEventListener('click', openDrawer);
                els.closeDrawer.addEventListener('click', closeDrawer);
                els.backdrop.addEventListener('click', closeDrawer);
                document.addEventListener('keydown', (e) => {
                    if (!document.body.classList.contains('drawer-open')) return;
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        closeDrawer();
                        return;
                    }
                    // Simple focus trap
                    if (e.key === 'Tab') {
                        const focusables = els.drawer.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
                        const list = Array.from(focusables).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));
                        if (!list.length) return;
                        const first = list[0];
                        const last = list[list.length - 1];
                        if (e.shiftKey && document.activeElement === first) {
                            e.preventDefault();
                            last.focus();
                        } else if (!e.shiftKey && document.activeElement === last) {
                            e.preventDefault();
                            first.focus();
                        }
                    }
                });
            }

            function assignUids(paper) {
                let n = 0;
                const assign = (q) => {
                    q.__uid = 'q' + (++n);
                    if (Array.isArray(q.children)) q.children.forEach(assign);
                };
                if (Array.isArray(paper.sections)) {
                    paper.sections.forEach(sec => {
                        if (Array.isArray(sec.questions)) sec.questions.forEach(assign);
                    });
                } else if (Array.isArray(paper.questions)) {
                    paper.questions.forEach(assign);
                }
            }

            function buildQuestionNode(q, depth) {
                const qWrap = mk('section', { class: `q depth-${Math.min(depth, 3)}`, 'data-q-uid': q.__uid });

                // Question line: id prefix + prompt
                const qLine = mk('div', { class: 'qline' });
                qLine.appendChild(mk('span', { class: 'qid', text: safeText(q.id) }));
                const qText = mk('span', { class: 'qtext md', html: renderMarkdownToHTML(q.question) });
                qLine.appendChild(qText);
                qWrap.appendChild(qLine);

                // Answer (always visible, label must be "Answer")
                const ansRow = mk('div', { class: 'answer' });
                ansRow.appendChild(mk('div', { class: 'alabel', text: 'Answer' }));
                const aVal = mk('div', { class: 'avalue md', html: renderMarkdownToHTML(q.answer) });
                ansRow.appendChild(aVal);
                qWrap.appendChild(ansRow);

                // Solution Details: single atomic region under one toggle, only if solutionDetails exists (even if empty)
                const sd = q.solutionDetails;
                const hasSdObj = (sd && typeof sd === 'object');
                if (hasSdObj) {
                    const toggleRow = mk('div', { class: 'toggle-row' });
                    const btn = mk('button', {
                        type: 'button',
                        class: 'toggle',
                        'aria-expanded': (expandedAll || expandedIds.has(q.__uid)) ? 'true' : 'false',
                        'data-toggle-uid': q.__uid
                    });

                    btn.appendChild(mk('span', { class: 'chev', 'aria-hidden': 'true' }));
                    btn.appendChild(document.createTextNode((expandedAll || expandedIds.has(q.__uid)) ? 'Hide working' : 'Show working'));
                    toggleRow.appendChild(btn);
                    qWrap.appendChild(toggleRow);

                    // Collapsible region (inline; no modal)
                    const collapsible = mk('div', { class: 'collapsible', 'data-collapsible-uid': q.__uid });
                    const solution = mk('div', { class: 'solution', 'data-solution-uid': q.__uid });

                    // Only render blocks that exist and are non-empty; keep order locked.
                    const blocks = [];
                    const addBlock = (label, bodyMd, underlay) => {
                        const body = safeText(bodyMd).trim();
                        if (!body) return;
                        const blk = mk('div', { class: 'sd-block' });
                        blk.appendChild(mk('div', { class: 'sd-label', text: label }));
                        const b = mk('div', { class: 'sd-body md', html: renderMarkdownToHTML(bodyMd) });
                        if (underlay) b.setAttribute('data-underlay', 'true');
                        blk.appendChild(b);
                        blocks.push(blk);
                    };

                    addBlock('Keep in mind', sd.keepInMind, false);
                    addBlock('Formulas used', sd.formulasUsed, false);
                    addBlock('Working', sd.working, true);
                    addBlock('Alternative working', sd.alternativeWorking, true);

                    // Region signature: optional hairlines when multiple blocks exist (and for answer->solution boundary)
                    if (blocks.length) {
                        // Answer → Solution Details boundary (when expanded) via internal divider after first paint
                        // We implement via a divider at top of solution only when expanded (handled in applyExpandedState)
                        blocks.forEach((blk, idx) => {
                            solution.appendChild(blk);
                            if (idx < blocks.length - 1) {
                                solution.appendChild(mk('div', { class: 'sd-divider', 'aria-hidden': 'true' }));
                            }
                        });
                    }

                    collapsible.appendChild(solution);
                    qWrap.appendChild(collapsible);

                    // Toggle behavior (no cross-question effects)
                    btn.addEventListener('click', () => {
                        const uid = q.__uid;
                        if (expandedAll) {
                            // If expandedAll is true by default, allow per-question collapse without changing other questions.
                            // So treat expandedIds as "collapsed exceptions" in that mode.
                            if (expandedIds.has(uid)) expandedIds.delete(uid);
                            else expandedIds.add(uid);
                        } else {
                            if (expandedIds.has(uid)) expandedIds.delete(uid);
                            else expandedIds.add(uid);
                        }
                        applyExpandedState(uid);
                        // Update button label only (no focus movement, no auto scroll)
                    });

                    // Initial state
                    applyExpandedState(q.__uid, /*skipKatex*/ true);
                }

                // Children
                if (Array.isArray(q.children) && q.children.length) {
                    q.children.forEach(ch => {
                        qWrap.appendChild(buildQuestionNode(ch, depth + 1));
                    });
                }

                // After markdown is in DOM, KaTeX render within this question node
                runKatex(qWrap);

                return qWrap;
            }

            function isExpanded(uid) {
                // If expandedAll true: expanded unless explicitly toggled in expandedIds (as collapsed exceptions)
                if (expandedAll) return !expandedIds.has(uid);
                return expandedIds.has(uid);
            }

            function applyExpandedState(uid, skipKatex) {
                const btn = document.querySelector('[data-toggle-uid="' + CSS.escape(uid) + '"]');
                const coll = document.querySelector('[data-collapsible-uid="' + CSS.escape(uid) + '"]');
                const sol = document.querySelector('[data-solution-uid="' + CSS.escape(uid) + '"]');
                if (!btn || !coll || !sol) return;

                const open = isExpanded(uid);
                btn.setAttribute('aria-expanded', open ? 'true' : 'false');
                btn.childNodes.forEach(n => {
                    if (n.nodeType === Node.TEXT_NODE) n.textContent = open ? 'Hide working' : 'Show working';
                });

                // Keep hidden content non-focusable: use hidden on solution container content by toggling display via max-height
                if (!open) {
                    coll.style.maxHeight = '0px';
                    sol.setAttribute('aria-hidden', 'true');
                    // Remove top divider (answer->solution boundary) effect is via CSS wash; keep no preview
                } else {
                    // Add a quiet divider at the top of the region only when expanded (Answer → Solution Details boundary)
                    // Implement as first child divider if not already present
                    if (!sol.__hasTopDivider) {
                        const topDiv = mk('div', { class: 'sd-divider', 'aria-hidden': 'true' });
                        sol.insertBefore(topDiv, sol.firstChild);
                        sol.__hasTopDivider = true;
                    }
                    sol.removeAttribute('aria-hidden');

                    // Measure height for transition
                    // Temporarily set max-height to scrollHeight
                    coll.style.maxHeight = sol.scrollHeight + 'px';
                }

                // Ensure KaTeX overflow containment remains correct (no-op if KaTeX missing)
                if (!skipKatex) runKatex(sol);
            }

            function buildPaper(paper) {
                if (!paper) return;

                // Reset observers
                if (io) { io.disconnect(); io = null; }
                questionIndex = [];
                lastActiveUid = null;

                // Defaults
                expandedAll = !!(paper.defaults && paper.defaults.expandedAll === true);
                expandedIds = new Set(); // if expandedAll, store collapsed exceptions; else store expanded
                // If expandedAll is false, all collapsed by default.
                // If expandedAll is true, all expanded by default.

                assignUids(paper);

                const items = flattenQuestionsForNav(paper);
                buildNav(els.nav, items, false);
                buildNav(els.navMobile, items, true);

                // Meta (quiet; no progress semantics)
                els.paperMeta.textContent = safeText(paper.label || paper.key || '');

                // Content
                els.paperContent.innerHTML = '';

                const renderSection = (label, questions) => {
                    // Section header as structural divider, not container/card
                    const sec = mk('section', { class: 'q depth-0' });
                    const h = mk('div', { class: 'qline' });
                    h.appendChild(mk('span', { class: 'qid', text: safeText(label) }));
                    h.appendChild(mk('span', { class: 'qtext', text: '' }));
                    sec.appendChild(h);
                    els.paperContent.appendChild(sec);

                    if (Array.isArray(questions)) {
                        questions.forEach(q => {
                            els.paperContent.appendChild(buildQuestionNode(q, 0));
                        });
                    }
                };

                if (Array.isArray(paper.sections)) {
                    paper.sections.forEach(sec => renderSection(sec.label, sec.questions));
                } else if (Array.isArray(paper.questions)) {
                    paper.questions.forEach(q => {
                        els.paperContent.appendChild(buildQuestionNode(q, 0));
                    });
                }

                // Collect question anchors for active nav
                document.querySelectorAll('[data-q-uid]').forEach(el => {
                    const uid = el.getAttribute('data-q-uid');
                    questionIndex.push({ uid, el });
                });

                // Apply initial expanded/collapsed sizing for all collapsibles after layout
                requestAnimationFrame(() => {
                    document.querySelectorAll('[data-collapsible-uid]').forEach(c => {
                        const uid = c.getAttribute('data-collapsible-uid');
                        // set correct max-height
                        applyExpandedState(uid, /*skipKatex*/ true);
                    });
                });

                // Active nav with IntersectionObserver (quiet; no scroll forcing)
                setupActiveTracking();
            }

            function setActiveNav(uid) {
                if (!uid || uid === lastActiveUid) return;
                lastActiveUid = uid;

                const update = (root) => {
                    const btns = root.querySelectorAll('.navbtn');
                    btns.forEach(b => b.setAttribute('aria-current', (b.getAttribute('data-uid') === uid) ? 'true' : 'false'));
                };
                update(els.nav);
                update(els.navMobile);
            }

            function setupActiveTracking() {
                if (!('IntersectionObserver' in window)) return;

                const opts = {
                    root: null,
                    rootMargin: '-10% 0px -80% 0px',
                    threshold: 0
                };

                io = new IntersectionObserver((entries) => {
                    // Choose the first entry that is intersecting and closest to top
                    const visible = entries.filter(e => e.isIntersecting)
                        .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                    if (visible.length) {
                        const uid = visible[0].target.getAttribute('data-q-uid');
                        if (uid) setActiveNav(uid);
                    }
                }, opts);

                questionIndex.forEach(item => io.observe(item.el));
            }

            function populateSelector(papers) {
                els.select.innerHTML = '';
                papers.forEach((p, idx) => {
                    const opt = mk('option', { value: String(idx), text: safeText(p.label || p.key || ('Paper ' + (idx + 1))) });
                    els.select.appendChild(opt);
                });
                els.select.value = String(activePaperIndex);
                els.select.addEventListener('change', () => {
                    const idx = parseInt(els.select.value, 10);
                    if (Number.isFinite(idx)) {
                        activePaperIndex = idx;
                        buildPaper(payload.papers[activePaperIndex]);
                    }
                });
            }

            function renderFailure() {
                // UI shell remains; content area shows exactly the failure text
                els.paperMeta.textContent = '';
                els.paperContent.innerHTML = '';
                els.nav.innerHTML = '';
                els.navMobile.innerHTML = '';
                els.paperContent.appendChild(mk('div', { text: 'PAPERS PAYLOAD MISSING' }));
            }

            async function loadPayload() {
                try {
                    const res = await fetch(RTQ_PAPERS_PAYLOAD_PATH, { credentials: 'same-origin' });
                    if (!res.ok) throw new Error('Fetch failed');
                    const json = await res.json();
                    if (!json || !Array.isArray(json.papers)) throw new Error('Bad schema');
                    payload = json;
                    populateSelector(payload.papers);
                    buildPaper(payload.papers[activePaperIndex]);
                } catch (e) {
                    renderFailure();
                }
            }

            // Drawer wiring
            wireDrawer();

            // Initial aria hidden for drawer elements
            els.drawer.hidden = true;
            els.backdrop.hidden = true;

            // Start
            loadPayload();
        })();
    </script>
</body>

</html>