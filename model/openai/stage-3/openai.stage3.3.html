<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RTQ – Maths Paper Solution Viewer (Stress Test Harness)</title>

  <!-- KaTeX (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

  <style>
    :root {
      --bg: #fff;
      --fg: #111;
      --muted: #555;
      --faint: #777;
      --hair: #d6d6d6;
      --frame-max: 1120px;
      --gutter: 20px;
      --nav-w: 140px;
      --gap: 22px;

      --q-gap: 26px;
      /* largest spacing unit between top-level questions */
      --in-gap: 10px;
      /* inside question */
      --sub-indent: 22px;

      --control-h: 56px;
      --radius: 10px;
      --touch: 44px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --lh: 1.45;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: var(--font);
      line-height: var(--lh);
      overflow-x: hidden;
      /* main document must never scroll horizontally */
    }

    a {
      color: inherit;
    }

    button,
    select {
      font-family: inherit;
    }

    :focus-visible {
      outline: 2px solid #000;
      outline-offset: 2px;
    }

    /* Top controls */
    header {
      position: sticky;
      top: 0;
      z-index: 50;
      background: var(--bg);
      border-bottom: 1px solid var(--hair);
    }

    .frame {
      max-width: var(--frame-max);
      margin: 0 auto;
      padding: 0 var(--gutter);
    }

    .controls {
      height: var(--control-h);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .controls-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .label {
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
    }

    select {
      height: 40px;
      min-width: 260px;
      max-width: min(520px, 70vw);
      padding: 0 10px;
      border: 1px solid var(--hair);
      border-radius: 8px;
      background: #fff;
      color: var(--fg);
    }

    .jump-btn {
      height: 40px;
      padding: 0 12px;
      border: 1px solid var(--hair);
      border-radius: 8px;
      background: #fff;
      color: var(--fg);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      white-space: nowrap;
    }

    .jump-btn .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #000;
      display: inline-block;
    }

    /* Layout */
    .shell {
      padding: 18px var(--gutter) 60px var(--gutter);
    }

    .grid {
      max-width: var(--frame-max);
      margin: 0 auto;
      display: grid;
      grid-template-columns: var(--nav-w) 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Navigation (quiet, documentation-style) */
    nav {
      position: sticky;
      top: calc(var(--control-h) + 16px);
      padding-top: 6px;
    }

    .nav-title {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px 0;
      letter-spacing: 0.02em;
    }

    .nav-list {
      display: flex;
      flex-direction: column;
      gap: 2px;

      /* Allowed scroll region only for navigation when needed */
      max-height: calc(100vh - (var(--control-h) + 36px));
      overflow-y: auto;
      padding-right: 2px;

      /* Hide scrollbars (keep scrolling functional) */
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* legacy */
    }

    .nav-list::-webkit-scrollbar {
      display: none;
    }

    /* WebKit/Blink */

    .nav-item,
    .nav-sep {
      font-size: 13px;
      line-height: 1.1;
      color: var(--muted);
      text-decoration: none;
      padding: 10px 8px;
      border-radius: 8px;
    }

    .nav-item {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
    }

    .nav-item:hover {
      color: var(--fg);
    }

    .nav-item[aria-current="true"] {
      color: var(--fg);
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    .nav-sep {
      padding: 10px 8px 6px 8px;
      color: var(--faint);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      cursor: default;
      user-select: none;
    }

    .nav-indent-1 {
      padding-left: 18px;
    }

    .nav-indent-2 {
      padding-left: 28px;
    }

    .nav-indent-3 {
      padding-left: 38px;
    }

    /* Paper */
    main {
      min-width: 0;
    }

    .paper-meta {
      margin: 0 0 10px 0;
      color: var(--muted);
      font-size: 13px;
    }

    .section {
      margin: 16px 0 6px 0;
      font-size: 14px;
      color: var(--muted);
      letter-spacing: 0.02em;
      font-weight: 600;
    }

    .q {
      margin: 0 0 var(--q-gap) 0;
      padding: 0;
    }

    .q-inner {
      padding-left: calc(var(--sub-indent) * var(--depth, 0));
      min-width: 0;
    }

    .q-head {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 6px;
    }

    .q-num {
      flex: 0 0 auto;
      font-weight: 650;
      font-size: 14px;
      color: var(--fg);
      min-width: 58px;
    }

    .q-title {
      flex: 1 1 auto;
      min-width: 0;
      font-size: 14px;
      color: var(--fg);
    }

    .q-body {
      margin-left: 68px;
      display: grid;
      gap: var(--in-gap);
      min-width: 0;
    }

    .prompt {
      color: var(--fg);
      font-size: 14px;
    }

    .answer {
      color: var(--muted);
      font-size: 14px;
    }

    .answer strong {
      color: var(--fg);
      font-weight: 650;
    }

    /* Working disclosure */
    .working {
      color: var(--muted);
      font-size: 13px;
      min-width: 0;
    }

    .working-top {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle {
      min-height: var(--touch);
      padding: 0 10px;
      border: 1px solid var(--hair);
      border-radius: 999px;
      background: #fff;
      color: var(--fg);
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }

    .toggle .chev {
      width: 10px;
      height: 10px;
      display: inline-block;
      border-right: 2px solid #000;
      border-bottom: 2px solid #000;
      transform: rotate(45deg);
      margin-top: -2px;
    }

    .toggle[aria-expanded="true"] .chev {
      transform: rotate(-135deg);
      margin-top: 2px;
    }

    .working-label {
      font-size: 12px;
      color: var(--faint);
    }

    .working-preview {
      margin-top: 8px;
      color: var(--faint);
    }

    .working-preview .line {
      margin: 6px 0;
    }

    .working-full {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dotted var(--hair);
      color: var(--muted);
    }

    .working-full .line {
      margin: 8px 0;
    }

    /* KaTeX containers */
    .math-inline {
      display: inline-block;
      max-width: 100%;
      vertical-align: -0.2em;
    }

    .math-block {
      display: block;
      max-width: 100%;
      overflow-x: auto;
      /* only within math containers */
      overflow-y: hidden;
      padding: 6px 0;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
    }

    .math-block .katex {
      white-space: nowrap;
      /* preserve authored structure; allow container scroll if needed */
    }

    /* Diagrams (inline SVG placeholders) */
    .diagram {
      margin-top: 10px;
      max-width: 560px;
      width: 100%;
    }

    .diagram svg {
      width: 100%;
      height: auto;
      display: block;
      border: 1px solid var(--hair);
      border-radius: var(--radius);
    }

    .diagram .cap {
      margin-top: 6px;
      font-size: 12px;
      color: var(--faint);
    }

    /* Mobile / Tablet */
    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }

      nav {
        display: none;
      }

      .q-body {
        margin-left: 0;
      }

      .q-head {
        gap: 8px;
      }

      .q-num {
        min-width: 44px;
      }

      .q-inner {
        padding-left: calc((var(--sub-indent) - 8px) * var(--depth, 0));
      }

      select {
        min-width: 200px;
      }
    }

    /* Overlay navigation (tablet/mobile) */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.15);
      z-index: 100;
      display: none;
    }

    .overlay[aria-hidden="false"] {
      display: block;
    }

    .drawer {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
      width: min(360px, 92vw);
      background: #fff;
      border-left: 1px solid var(--hair);
      padding: 12px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }

    .drawer-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 2px;
    }

    .drawer-title {
      font-size: 13px;
      color: var(--muted);
      margin: 0;
    }

    .close-btn {
      height: 40px;
      padding: 0 12px;
      border: 1px solid var(--hair);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
    }

    .drawer .nav-list {
      max-height: unset;
      height: 100%;
      border-top: 1px solid var(--hair);
      padding-top: 10px;
    }

    /* Utility */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .muted {
      color: var(--muted);
    }

    .katex-fallback {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--faint);
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>

<body>
  <header>
    <div class="frame">
      <div class="controls" role="region" aria-label="Top controls">
        <div class="controls-left">
          <span class="label">Paper</span>
          <select id="paperSelect" aria-label="Paper selector">
            <option value="short">Short paper (6 questions)</option>
            <option value="standard">Standard paper (35 questions)</option>
            <option value="standardExpanded">Standard (Workings Expanded) (35 questions)</option>
            <option value="diagram">Diagram-heavy paper (20 questions)</option>
            <option value="sectioned">Sectioned paper (A/B/C)</option>
          </select>
        </div>

        <button id="jumpBtn" class="jump-btn" type="button" aria-haspopup="dialog" aria-controls="navOverlay">
          <span class="dot" aria-hidden="true"></span>
          <span>Jump to</span>
        </button>
      </div>
    </div>
  </header>

  <div class="shell">
    <div class="grid frame" aria-label="Paper shell">
      <nav aria-label="Document navigation">
        <p class="nav-title">Questions</p>
        <div id="navList" class="nav-list" tabindex="0" aria-label="Question list"></div>
      </nav>

      <main id="paper" aria-label="Paper content">
        <!-- Injected -->
      </main>
    </div>
  </div>

  <!-- Mobile/Tablet navigation overlay -->
  <div id="navOverlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true" aria-label="Jump to question">
    <div class="drawer">
      <div class="drawer-head">
        <p class="drawer-title">Questions</p>
        <button id="closeOverlay" class="close-btn" type="button">Close</button>
      </div>
      <div id="navListOverlay" class="nav-list" tabindex="0" aria-label="Question list (overlay)"></div>
    </div>
  </div>

  <script>
    (function () {
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

      const paperEl = $("#paper");
      const navListEl = $("#navList");
      const navListOverlayEl = $("#navListOverlay");
      const selectEl = $("#paperSelect");
      const overlayEl = $("#navOverlay");
      const jumpBtnEl = $("#jumpBtn");
      const closeOverlayEl = $("#closeOverlay");

      let current = null;
      let intersectionObserver = null;

      /* ---------- SVG diagram templates (grayscale) ---------- */
      function diagramSVG(type) {
        // All diagrams are inline SVG placeholders only (no external images).
        // Keep strokes grayscale; no fills except none/white.
        if (type === "geometry") {
          return `
            <div class="diagram" aria-label="Diagram">
              <svg viewBox="0 0 480 260" role="img" aria-label="Geometry diagram">
                <rect x="0" y="0" width="480" height="260" fill="none" />
                <circle cx="320" cy="130" r="72" fill="none" stroke="#111" stroke-width="2"/>
                <polygon points="110,200 210,60 310,200" fill="none" stroke="#111" stroke-width="2"/>
                <line x1="110" y1="200" x2="310" y2="200" stroke="#111" stroke-width="2" stroke-dasharray="4 4"/>
                <text x="200" y="48" font-size="14" fill="#111">A</text>
                <text x="98" y="218" font-size="14" fill="#111">B</text>
                <text x="314" y="218" font-size="14" fill="#111">C</text>
                <text x="317" y="130" font-size="14" fill="#111">O</text>
                <text x="351" y="86" font-size="12" fill="#111">r</text>
              </svg>
              <div class="cap">Diagram: triangle ABC and circle with centre O.</div>
            </div>
          `;
        }
        if (type === "bars") {
          return `
            <div class="diagram" aria-label="Diagram">
              <svg viewBox="0 0 480 220" role="img" aria-label="Ratio bars">
                <rect x="0" y="0" width="480" height="220" fill="none" />
                <text x="16" y="28" font-size="14" fill="#111">Ratio bars</text>

                <rect x="16" y="54" width="448" height="34" fill="none" stroke="#111" stroke-width="2"/>
                <line x1="16" y1="71" x2="464" y2="71" stroke="#111" stroke-width="1" stroke-dasharray="2 4"/>
                <line x1="16+112" y1="54" x2="16+112" y2="88" stroke="#111" stroke-width="2"/>
                <line x1="16+224" y1="54" x2="16+224" y2="88" stroke="#111" stroke-width="2"/>
                <line x1="16+336" y1="54" x2="16+336" y2="88" stroke="#111" stroke-width="2"/>
                <text x="16" y="110" font-size="12" fill="#111">4 equal parts</text>

                <rect x="16" y="138" width="448" height="34" fill="none" stroke="#111" stroke-width="2"/>
                <line x1="16+64" y1="138" x2="16+64" y2="172" stroke="#111" stroke-width="2"/>
                <line x1="16+128" y1="138" x2="16+128" y2="172" stroke="#111" stroke-width="2"/>
                <line x1="16+192" y1="138" x2="16+192" y2="172" stroke="#111" stroke-width="2"/>
                <line x1="16+256" y1="138" x2="16+256" y2="172" stroke="#111" stroke-width="2"/>
                <line x1="16+320" y1="138" x2="16+320" y2="172" stroke="#111" stroke-width="2"/>
                <line x1="16+384" y1="138" x2="16+384" y2="172" stroke="#111" stroke-width="2"/>
                <text x="16" y="196" font-size="12" fill="#111">7 equal parts</text>
              </svg>
              <div class="cap">Diagram: two bars split into equal parts.</div>
            </div>
          `;
        }
        if (type === "grid") {
          return `
            <div class="diagram" aria-label="Diagram">
              <svg viewBox="0 0 480 260" role="img" aria-label="Coordinate grid">
                <rect x="0" y="0" width="480" height="260" fill="none" />
                <rect x="40" y="20" width="400" height="200" fill="none" stroke="#111" stroke-width="2"/>
                <!-- grid lines -->
                ${Array.from({ length: 9 }).map((_, i) => `<line x1="${40 + (i * 50)}" y1="20" x2="${40 + (i * 50)}" y2="220" stroke="#111" stroke-width="1" stroke-dasharray="2 4"/>`).join("")}
                ${Array.from({ length: 5 }).map((_, i) => `<line x1="40" y1="${20 + (i * 50)}" x2="440" y2="${20 + (i * 50)}" stroke="#111" stroke-width="1" stroke-dasharray="2 4"/>`).join("")}
                <!-- axes -->
                <line x1="40" y1="220" x2="440" y2="220" stroke="#111" stroke-width="2"/>
                <line x1="40" y1="20" x2="40" y2="220" stroke="#111" stroke-width="2"/>
                <!-- points & line -->
                <circle cx="140" cy="170" r="5" fill="#111"/>
                <circle cx="320" cy="90" r="5" fill="#111"/>
                <line x1="140" y1="170" x2="320" y2="90" stroke="#111" stroke-width="2"/>
                <text x="148" y="186" font-size="12" fill="#111">P</text>
                <text x="328" y="106" font-size="12" fill="#111">Q</text>
              </svg>
              <div class="cap">Diagram: coordinate grid with points P and Q.</div>
            </div>
          `;
        }
        if (type === "table") {
          return `
            <div class="diagram" aria-label="Diagram">
              <svg viewBox="0 0 480 220" role="img" aria-label="Table grid">
                <rect x="0" y="0" width="480" height="220" fill="none" />
                <rect x="40" y="30" width="400" height="160" fill="none" stroke="#111" stroke-width="2"/>
                ${Array.from({ length: 4 }).map((_, i) => `<line x1="${40 + (i * 100)}" y1="30" x2="${40 + (i * 100)}" y2="190" stroke="#111" stroke-width="2"/>`).join("")}
                ${Array.from({ length: 4 }).map((_, i) => `<line x1="40" y1="${30 + (i * 40)}" x2="440" y2="${30 + (i * 40)}" stroke="#111" stroke-width="2"/>`).join("")}
                <text x="52" y="56" font-size="12" fill="#111">A</text>
                <text x="152" y="56" font-size="12" fill="#111">B</text>
                <text x="252" y="56" font-size="12" fill="#111">C</text>
                <text x="352" y="56" font-size="12" fill="#111">D</text>
              </svg>
              <div class="cap">Diagram: a simple table grid.</div>
            </div>
          `;
        }
        return "";
      }

      /* ---------- Helpers to render content blocks & math ---------- */
      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        for (const [k, v] of Object.entries(attrs || {})) {
          if (v === null || v === undefined) continue;
          if (k === "class") node.className = v;
          else if (k === "style") node.setAttribute("style", v);
          else if (k.startsWith("aria-")) node.setAttribute(k, v);
          else if (k === "dataset") {
            for (const [dk, dv] of Object.entries(v)) node.dataset[dk] = dv;
          } else if (k in node) node[k] = v;
          else node.setAttribute(k, v);
        }
        for (const child of children) {
          if (child === null || child === undefined) continue;
          if (typeof child === "string") node.appendChild(document.createTextNode(child));
          else node.appendChild(child);
        }
        return node;
      }

      function renderSegments(container, segments) {
        for (const seg of segments) {
          if (seg.type === "text") {
            container.appendChild(document.createTextNode(seg.value));
          } else if (seg.type === "math") {
            const span = seg.display
              ? el("div", { class: "math-block", dataset: { latex: seg.latex, display: "1" } })
              : el("span", { class: "math-inline", dataset: { latex: seg.latex, display: "0" } });
            // fallback content (visible if KaTeX fails)
            span.appendChild(el("span", { class: "katex-fallback" }, [seg.fallback ?? seg.latex]));
            container.appendChild(span);
          } else if (seg.type === "break") {
            container.appendChild(document.createElement("br"));
          }
        }
      }

      function renderKatex(root) {
        // Render each [data-latex] programmatically. If KaTeX missing, keep fallback text.
        const nodes = $$("[data-latex]", root);
        if (!window.katex || !window.katex.render) {
          return;
        }
        for (const node of nodes) {
          const latex = node.dataset.latex || "";
          const displayMode = node.dataset.display === "1";
          // Clear fallback
          node.textContent = "";
          try {
            window.katex.render(latex, node, {
              throwOnError: false,
              displayMode
            });
          } catch (e) {
            // Graceful fallback
            node.textContent = latex;
          }
        }
      }

      /* ---------- Dataset builders ---------- */
      function segText(value) { return { type: "text", value }; }
      function segInline(latex, fallback) { return { type: "math", latex, display: false, fallback }; }
      function segBlock(latex, fallback) { return { type: "math", latex, display: true, fallback }; }

      function makeWorkingLinesShort() {
        return [
          { kind: "math", display: true, latex: "7 + 8 = 15" },
          { kind: "math", display: true, latex: "15 + 9 = 24" }
        ];
      }

      function makeLongWorkingLines(n, seed = 1) {
        const out = [];
        for (let i = 1; i <= n; i++) {
          const a = (seed * 2 + i) % 9 + 2;
          const b = (seed * 3 + i * 2) % 9 + 1;
          const c = (seed * 5 + i * 3) % 11 + 1;
          // Keep each line as a separate KaTeX display line
          out.push({ kind: "math", display: true, latex: `\\text{Step ${i}:}\\quad ${a}x + ${b} = ${c} \\;\\Rightarrow\\; x = \\frac{${c}-${b}}{${a}}` });
        }
        return out;
      }

      function buildShort() {
        const questions = [
          q("1", "1", 0, [
            p([segText("Calculate "), segInline("7+8+9", "7+8+9"), segText(".")])
          ], a([segText("Answer: "), segInline("24", "24")]),
            w(makeWorkingLinesShort(), false)
          ),
          q("2", "2", 0, [
            p([segText("Work out "), segInline("12\\times 6", "12×6"), segText(".")])
          ], a([segText("Answer: "), segInline("72", "72")]),
            w([{ kind: "math", display: true, latex: "12\\times 6 = 72" }], false)
          ),
          q("3", "3", 0, [
            p([segText("A shop sells pencils for "), segInline("15p", "15p"), segText(" each. How much for "), segInline("8", "8"), segText(" pencils?")])
          ], a([segText("Answer: "), segInline("120p", "120p")]),
            w([{ kind: "math", display: true, latex: "8\\times 15 = 120\\text{ pence}" }], false)
          ),
          // Multi-part
          q("4", "4", 0, [
            p([segText("A rectangle has length "), segInline("10\\text{ cm}", "10 cm"), segText(" and width "), segInline("6\\text{ cm}", "6 cm"), segText(".")])
          ], a([segText("Answer: See parts (a) and (b).")]), w([{ kind: "text", text: "This question has sub-parts." }], false)
          ),
          q("4a", "4a", 1, [
            p([segText("(a) Find the perimeter.")])
          ], a([segText("Answer: "), segInline("32\\text{ cm}", "32 cm")]),
            w([
              { kind: "math", display: true, latex: "P = 2(10+6)" },
              { kind: "math", display: true, latex: "P = 2\\times 16 = 32\\text{ cm}" }
            ], false)
          ),
          q("4b", "4b", 1, [
            p([segText("(b) Find the area.")])
          ], a([segText("Answer: "), segInline("60\\text{ cm}^2", "60 cm²")]),
            w([
              { kind: "math", display: true, latex: "A = 10\\times 6" },
              { kind: "math", display: true, latex: "A = 60\\text{ cm}^2" }
            ], false)
          ),
          q("5", "5", 0, [
            p([segText("Write "), segInline("\\tfrac{3}{4}", "3/4"), segText(" as a decimal.")])
          ], a([segText("Answer: "), segInline("0.75", "0.75")]),
            w([
              { kind: "math", display: true, latex: "\\frac{3}{4} = \\frac{75}{100}" },
              { kind: "math", display: true, latex: "= 0.75" }
            ], false)
          ),
          q("6", "6", 0, [
            p([segText("Solve "), segInline("x+9=21", "x+9=21"), segText(".")])
          ], a([segText("Answer: "), segInline("x=12", "x=12")]),
            w([
              { kind: "math", display: true, latex: "x+9=21" },
              { kind: "math", display: true, latex: "x=21-9=12" }
            ], false)
          ),
        ];
        return dataset("Short paper", "6 questions. Mix of short arithmetic and one multi-part question.", questions, []);
      }

      function buildStandard({ expandedAll = false } = {}) {
        const questions = [];
        // Q1-25 small/medium
        for (let i = 1; i <= 25; i++) {
          if (i === 18) {
            // Deep nesting: Q18(a)(i), Q18(a)(ii), Q18(b)
            questions.push(
              q("18", "18", 0,
                [p([segText("A number machine does two steps to an input "), segInline("x", "x"), segText(".")]), p([segText("It multiplies by "), segInline("3", "3"), segText(" and then adds "), segInline("5", "5"), segText(".")])],
                a([segText("Answer: See parts.")]),
                w([{ kind: "text", text: "Sub-questions follow." }], expandedAll)
              ),
              q("18a", "18a", 1,
                [p([segText("(a) Write an expression for the output.")])],
                a([segText("Answer: "), segInline("3x+5", "3x+5")]),
                w([{ kind: "math", display: true, latex: "\\text{Output} = 3x + 5" }], expandedAll)
              ),
              q("18a_i", "18a(i)", 2,
                [p([segText("(i) Find the output when "), segInline("x=4", "x=4"), segText(".")])],
                a([segText("Answer: "), segInline("17", "17")]),
                w([
                  { kind: "math", display: true, latex: "3(4)+5=12+5=17" }
                ], expandedAll)
              ),
              q("18a_ii", "18a(ii)", 2,
                [p([segText("(ii) Find the input when the output is "), segInline("20", "20"), segText(".")])],
                a([segText("Answer: "), segInline("5", "5")]),
                w([
                  { kind: "math", display: true, latex: "3x+5=20" },
                  { kind: "math", display: true, latex: "3x=15" },
                  { kind: "math", display: true, latex: "x=5" }
                ], expandedAll)
              ),
              q("18b", "18b", 1,
                [p([segText("(b) Explain why the machine always gives an odd output when "), segInline("x", "x"), segText(" is even.")])],
                a([segText("Answer: "), segText("Because "), segInline("3x", "3x"), segText(" is even when "), segInline("x", "x"), segText(" is even, and adding 5 makes it odd.")]),
                w([
                  { kind: "text", text: "If x is even, 3x is also even. Even + 5 (odd) = odd." },
                  { kind: "math", display: true, latex: "\\text{even} + \\text{odd} = \\text{odd}" }
                ], expandedAll)
              )
            );
            continue;
          }

          const prompt = (i % 5 === 0)
            ? [p([segText("Calculate "), segInline(`${i}+${i + 7}`, `${i}+${i + 7}`), segText(".")])]
            : [p([segText("Work out "), segInline(`${i}\\times 4`, `${i}×4`), segText(".")])];

          const answer = (i % 5 === 0)
            ? a([segText("Answer: "), segInline(String(i + i + 7), String(i + i + 7))])
            : a([segText("Answer: "), segInline(String(i * 4), String(i * 4))]);

          const working = (i % 5 === 0)
            ? w([{ kind: "math", display: true, latex: `${i}+${i + 7}=${i + i + 7}` }], expandedAll)
            : w([{ kind: "math", display: true, latex: `${i}\\times 4=${i * 4}` }], expandedAll);

          questions.push(q(String(i), String(i), 0, prompt, answer, working));
        }

        // Q26-35 long algebra, multiple KaTeX block placeholders inside working, with some extremely long workings for selected
        for (let i = 26; i <= 35; i++) {
          const long = (i === 30 || i === 33); // extremely long workings
          const workLines = long ? makeLongWorkingLines(56, i) : [
            { kind: "math", display: true, latex: `\\text{Given:}\\quad 2x + ${i - 20} = ${i + 10}` },
            { kind: "math", display: true, latex: `2x = ${i + 10} - ${i - 20}` },
            { kind: "math", display: true, latex: `2x = 30` },
            { kind: "math", display: true, latex: `x = 15` }
          ];

          // Add deep nesting also for Q30
          if (i === 30) {
            questions.push(
              q("30", "30", 0,
                [p([segText("Solve the following and show your working clearly.")])],
                a([segText("Answer: See parts.")]),
                w([{ kind: "text", text: "Sub-questions follow." }], expandedAll)
              ),
              q("30a", "30a", 1,
                [p([segText("(a) Solve "), segInline("2x+10=40", "2x+10=40"), segText(".")])],
                a([segText("Answer: "), segInline("x=15", "x=15")]),
                w([
                  { kind: "math", display: true, latex: "2x+10=40" },
                  { kind: "math", display: true, latex: "2x=30" },
                  { kind: "math", display: true, latex: "x=15" }
                ], expandedAll)
              ),
              q("30a_i", "30a(i)", 2,
                [p([segText("(i) Check your answer by substitution.")])],
                a([segText("Answer: "), segText("It satisfies the equation.")]),
                w([
                  { kind: "math", display: true, latex: "2(15)+10=30+10=40" }
                ], expandedAll)
              ),
              q("30a_ii", "30a(ii)", 2,
                [p([segText("(ii) What is the value of "), segInline("x+3", "x+3"), segText("?")])],
                a([segText("Answer: "), segInline("18", "18")]),
                w([
                  { kind: "math", display: true, latex: "15+3=18" }
                ], expandedAll)
              ),
              q("30b", "30b", 1,
                [p([segText("(b) A harder variant: solve "), segInline("5x-7=3x+23", "5x-7=3x+23"), segText(".")])],
                a([segText("Answer: "), segInline("x=15", "x=15")]),
                w(workLines, expandedAll) // extremely long
              )
            );
            continue;
          }

          questions.push(
            q(String(i), String(i), 0,
              [
                p([segText("Solve the equation "), segInline(`2x+${i - 20}=${i + 10}`, `2x+${i - 20}=${i + 10}`), segText(".")]),
                p([segText("Write your solution clearly.")])
              ],
              a([segText("Answer: "), segInline("x=15", "x=15")]),
              w(workLines, expandedAll)
            )
          );
        }

        return dataset(
          expandedAll ? "Standard (Workings Expanded)" : "Standard paper",
          expandedAll ? "35 questions. All workings start expanded for stress testing." : "35 questions. Q26–Q35 contain long algebra; workings collapsed by default.",
          questions,
          []
        );
      }

      function buildDiagramHeavy() {
        const questions = [];
        const diagramQs = new Set([2, 4, 6, 8, 10, 12, 14, 16]); // 8 questions contain diagrams
        const types = ["geometry", "bars", "grid", "table"];
        let t = 0;
        for (let i = 1; i <= 20; i++) {
          const blocks = [
            p([segText("Answer the question carefully. "), segText("Use the diagram if given.")])
          ];
          if (diagramQs.has(i)) {
            blocks.push({ type: "diagram", diagram: types[t % types.length] });
            t++;
          }
          blocks.push(p([segText("Calculate "), segInline(`${i}+${i + 3}`, `${i}+${i + 3}`), segText(".")]));
          questions.push(
            q(String(i), String(i), 0,
              blocks,
              a([segText("Answer: "), segInline(String(i + i + 3), String(i + i + 3))]),
              w([
                { kind: "math", display: true, latex: `${i}+${i + 3}=${i + i + 3}` }
              ], false)
            )
          );
        }
        return dataset("Diagram-heavy paper", "20 questions. 8 questions contain diagrams (inline SVG placeholders).", questions, []);
      }

      function buildSectioned() {
        const entries = [];
        // Section A: 35 questions small/medium
        entries.push(section("Section A"));
        for (let i = 1; i <= 35; i++) {
          entries.push(
            q(`A${i}`, String(i), 0,
              [p([segText("Section A question. Work out "), segInline(`${i}\\times 3`, `${i}×3`), segText(".")])],
              a([segText("Answer: "), segInline(String(i * 3), String(i * 3))]),
              w([{ kind: "math", display: true, latex: `${i}\\times 3=${i * 3}` }], false)
            )
          );
        }

        // Section B: 8 medium
        entries.push(section("Section B"));
        for (let i = 1; i <= 8; i++) {
          const qn = i;
          entries.push(
            q(`B${qn}`, String(35 + qn), 0,
              [
                p([segText("Section B question. A number is increased by "), segInline("7", "7"), segText(" and the result is "), segInline(String(20 + qn), String(20 + qn)), segText(". Find the number.")])
              ],
              a([segText("Answer: "), segInline(String(13 + qn), String(13 + qn))]),
              w([
                { kind: "math", display: true, latex: `x+7=${20 + qn}` },
                { kind: "math", display: true, latex: `x=${20 + qn}-7=${13 + qn}` }
              ], false)
            )
          );
        }

        // Section C: 6 very long workings (collapsed by default)
        entries.push(section("Section C"));
        for (let i = 1; i <= 6; i++) {
          const qnum = 43 + i;
          const workLines = makeLongWorkingLines(60, 100 + i); // extremely long
          entries.push(
            q(`C${i}`, String(qnum), 0,
              [
                p([segText("Section C question. Solve and show all steps: "), segInline(`(x+${i})^2=${(i + 5)}x+${20 + i}`, `(x+${i})^2=${(i + 5)}x+${20 + i}`), segText(".")]),
                p([segText("Your working may be long.")])
              ],
              a([segText("Answer: "), segInline("x=15", "x=15")]),
              w(workLines, false)
            )
          );
        }

        return dataset("Sectioned paper", "Original structure: Section A (35), Section B (8), Section C (6, very long workings).", entries, ["Section A", "Section B", "Section C"]);
      }

      /* ---------- Data primitives ---------- */
      function p(segments) { return { type: "p", segments }; }
      function a(segments) { return { segments }; }
      function w(lines, expanded = false) {
        return { lines, expanded };
      }
      function section(label) {
        return { type: "section", label };
      }
      function q(key, label, depth, promptBlocks, answerSegs, working) {
        return {
          type: "q",
          key,
          label,
          navLabel: label, // for deep labels, we'll pass already formatted, e.g. "18a(i)"
          depth,
          promptBlocks,
          answer: answerSegs,
          working
        };
      }
      function dataset(name, description, entries, sectionLabels) {
        return { name, description, entries, sectionLabels };
      }

      function datasets() {
        const standard = buildStandard({ expandedAll: false });
        const standardExpanded = buildStandard({ expandedAll: true });
        return {
          short: buildShort(),
          standard,
          standardExpanded,
          diagram: buildDiagramHeavy(),
          sectioned: buildSectioned()
        };
      }

      /* ---------- Build UI ---------- */
      function clearNode(node) {
        while (node.firstChild) node.removeChild(node.firstChild);
      }

      function buildNavigation(ds, entryRefs) {
        clearNode(navListEl);
        clearNode(navListOverlayEl);

        const makeNavItem = (text, href, depth, isCurrent = false) => {
          const a = el("a", {
            class: `nav-item nav-indent-${Math.min(depth, 3)}`,
            href,
            "aria-current": isCurrent ? "true" : "false"
          }, [text]);
          return a;
        };

        const makeSep = (text) => el("div", { class: "nav-sep" }, [text]);

        for (const item of entryRefs) {
          if (item.kind === "sep") {
            const sep = makeSep(item.label);
            const sep2 = makeSep(item.label);
            navListEl.appendChild(sep);
            navListOverlayEl.appendChild(sep2);
            continue;
          }
          const node = makeNavItem(item.navText, `#${item.domId}`, item.depth, false);
          const node2 = makeNavItem(item.navText, `#${item.domId}`, item.depth, false);

          node.addEventListener("click", (e) => {
            // allow normal anchor navigation; also close overlay if open
            closeOverlay();
          }, { passive: true });

          node2.addEventListener("click", (e) => {
            closeOverlay();
          }, { passive: true });

          navListEl.appendChild(node);
          navListOverlayEl.appendChild(node2);
        }
      }

      function buildPaper(ds) {
        clearNode(paperEl);

        const meta = el("p", { class: "paper-meta" }, [
          el("span", { class: "muted" }, [ds.name + " — "]),
          ds.description
        ]);
        paperEl.appendChild(meta);

        const entryRefs = [];

        for (const entry of ds.entries) {
          if (entry.type === "section") {
            const h = el("div", { class: "section" }, [entry.label]);
            paperEl.appendChild(h);

            // Section labels may appear only as non-clickable plain-text separators in navigation
            entryRefs.push({ kind: "sep", label: entry.label });
            continue;
          }

          if (entry.type === "q") {
            const domId = `q_${entry.key.replace(/[^a-zA-Z0-9_]/g, "_")}`;
            const wrap = el("article", {
              class: "q",
              id: domId,
              style: `--depth:${entry.depth};`
            });

            const inner = el("div", { class: "q-inner" });

            const head = el("div", { class: "q-head" }, [
              el("div", { class: "q-num" }, [entry.label]),
              el("div", { class: "q-title" }, [""])
            ]);

            const body = el("div", { class: "q-body" });

            // Prompt blocks
            const promptWrap = el("div", { class: "prompt" });
            for (const block of entry.promptBlocks) {
              if (block.type === "p") {
                const para = el("div", {});
                renderSegments(para, block.segments);
                promptWrap.appendChild(para);
              } else if (block.type === "diagram") {
                const holder = el("div", {});
                holder.innerHTML = diagramSVG(block.diagram);
                promptWrap.appendChild(holder);
              }
            }

            // Answer
            const ans = el("div", { class: "answer" });
            // Make "Answer:" a stable label while keeping it subordinate
            // If the first segment begins with "Answer:" text, keep as-is.
            renderSegments(ans, entry.answer.segments);

            // Working area
            const working = el("div", { class: "working" });

            const toggleId = `${domId}_work`;
            const previewId = `${domId}_preview`;

            const btn = el("button", {
              class: "toggle",
              type: "button",
              "aria-controls": toggleId,
              "aria-expanded": entry.working.expanded ? "true" : "false"
            }, [
              el("span", { class: "chev", "aria-hidden": "true" }),
              entry.working.expanded ? "Hide working" : "Show working"
            ]);

            const label = el("div", { class: "working-label" }, ["Working"]);

            const topRow = el("div", { class: "working-top" }, [btn, label]);

            const preview = el("div", { class: "working-preview", id: previewId });
            const full = el("div", { class: "working-full", id: toggleId });

            const lines = entry.working.lines || [];
            const previewLines = lines.slice(0, 2);

            // Render preview (1–2 lines only)
            for (const ln of previewLines) {
              const lineEl = el("div", { class: "line" });
              if (ln.kind === "text") {
                lineEl.textContent = ln.text;
              } else {
                const seg = { type: "math", latex: ln.latex, display: !!ln.display, fallback: ln.latex };
                renderSegments(lineEl, [seg]);
              }
              preview.appendChild(lineEl);
            }

            // Render full
            for (const ln of lines) {
              const lineEl = el("div", { class: "line" });
              if (ln.kind === "text") {
                lineEl.textContent = ln.text;
              } else {
                const seg = { type: "math", latex: ln.latex, display: !!ln.display, fallback: ln.latex };
                renderSegments(lineEl, [seg]);
              }
              full.appendChild(lineEl);
            }

            function setExpanded(expanded) {
              btn.setAttribute("aria-expanded", expanded ? "true" : "false");
              btn.lastChild && (btn.lastChild.textContent = expanded ? "Hide working" : "Show working");
              // Also update button label safely
              btn.innerHTML = `<span class="chev" aria-hidden="true"></span>${expanded ? "Hide working" : "Show working"}`;

              if (expanded) {
                full.hidden = false;
                preview.hidden = true;
              } else {
                full.hidden = true;
                preview.hidden = false;
              }
            }

            // Initial state
            setExpanded(!!entry.working.expanded);

            btn.addEventListener("click", () => {
              const now = btn.getAttribute("aria-expanded") === "true";
              setExpanded(!now);
            });

            working.appendChild(topRow);
            working.appendChild(preview);
            working.appendChild(full);

            body.appendChild(promptWrap);
            body.appendChild(ans);
            body.appendChild(working);

            inner.appendChild(head);
            inner.appendChild(body);
            wrap.appendChild(inner);

            paperEl.appendChild(wrap);

            // Navigation entry
            entryRefs.push({
              kind: "item",
              navText: entry.label,
              domId,
              depth: entry.depth
            });
          }
        }

        buildNavigation(ds, entryRefs);

        // Render math programmatically (KaTeX), fallback if missing
        renderKatex(paperEl);

        // Observe visible question for subtle current state (quiet)
        setupActiveNavObserver(entryRefs);
      }

      function setupActiveNavObserver(entryRefs) {
        if (intersectionObserver) {
          try { intersectionObserver.disconnect(); } catch (e) { }
        }
        const items = entryRefs.filter(x => x.kind === "item");
        const targets = items.map(x => document.getElementById(x.domId)).filter(Boolean);

        const markCurrent = (id) => {
          const setCurrent = (root) => {
            $$("a.nav-item", root).forEach(a => a.setAttribute("aria-current", "false"));
            const a = root.querySelector(`a.nav-item[href="#${CSS.escape(id)}"]`);
            if (a) a.setAttribute("aria-current", "true");
          };
          setCurrent(navListEl);
          setCurrent(navListOverlayEl);
        };

        // Default to first question if exists
        if (targets[0]) markCurrent(targets[0].id);

        intersectionObserver = new IntersectionObserver((entries) => {
          // Pick the most visible entry near top
          const visible = entries
            .filter(e => e.isIntersecting)
            .sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
          if (visible && visible.target && visible.target.id) {
            markCurrent(visible.target.id);
          }
        }, {
          root: null,
          threshold: [0.1, 0.25, 0.5, 0.75],
          rootMargin: "-10% 0px -70% 0px"
        });

        for (const t of targets) intersectionObserver.observe(t);
      }

      /* ---------- Overlay (mobile/tablet) ---------- */
      function openOverlay() {
        overlayEl.setAttribute("aria-hidden", "false");
        // Trap focus within overlay
        const focusable = overlayEl.querySelectorAll('button, [href], [tabindex]:not([tabindex="-1"])');
        const first = focusable[0];
        if (first) first.focus();
        document.addEventListener("keydown", onTrapKeydown, true);
      }

      function closeOverlay() {
        if (overlayEl.getAttribute("aria-hidden") === "true") return;
        overlayEl.setAttribute("aria-hidden", "true");
        document.removeEventListener("keydown", onTrapKeydown, true);
        // Return focus to Jump button without forced scrolling
        jumpBtnEl.focus({ preventScroll: true });
      }

      function onTrapKeydown(e) {
        if (overlayEl.getAttribute("aria-hidden") === "true") return;
        if (e.key === "Escape") {
          e.preventDefault();
          closeOverlay();
          return;
        }
        if (e.key !== "Tab") return;
        const focusable = Array.from(overlayEl.querySelectorAll('button, [href], [tabindex]:not([tabindex="-1"])'))
          .filter(el => !el.hasAttribute("disabled") && el.offsetParent !== null);
        if (focusable.length === 0) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }

      overlayEl.addEventListener("click", (e) => {
        // Click outside drawer closes
        if (e.target === overlayEl) closeOverlay();
      });

      jumpBtnEl.addEventListener("click", () => {
        // Always available; overlay is only visible on small screens, but harmless on desktop
        openOverlay();
      });

      closeOverlayEl.addEventListener("click", closeOverlay);

      /* ---------- Paper switching ---------- */
      function setDataset(key) {
        const all = datasets();
        const ds = all[key] || all.short;
        current = key;
        buildPaper(ds);
      }

      selectEl.addEventListener("change", (e) => {
        setDataset(e.target.value);
      });

      // Initial load
      setDataset(selectEl.value);

      // If KaTeX loads after DOM built, re-render once (no reflow tricks, just render)
      window.addEventListener("load", () => {
        renderKatex(paperEl);
      });
    })();
  </script>
</body>

</html>