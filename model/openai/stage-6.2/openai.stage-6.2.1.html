<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>RTQ – Maths Paper Solution Viewer (Prototype)</title>

    <!-- KaTeX (CDN) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" />
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>

    <!-- Markdown-it (CDN) -->
    <script defer src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>

    <style>
        :root {
            --bg: #f6f2eb;
            /* soft-warm neutral base */
            --surface: #fbf8f2;
            /* paper surface */
            --ink: #1d1d1d;
            /* question anchor */
            --ink-2: #3a3a3a;
            /* answer / labels */
            --ink-3: #5a5a5a;
            /* solution text */
            --ink-quiet: #6a6a6a;
            /* nav, metadata */
            --hairline: rgba(0, 0, 0, .10);
            --hairline-2: rgba(0, 0, 0, .08);
            --accent: #2f5f74;
            /* restrained accent (non-content UI + focus only) */

            --frame-max: 1040px;
            --gutter: 18px;

            --fs-0: 14px;
            --fs-1: 15px;
            --fs-2: 17px;
            --fs-3: 19px;

            --lh-0: 1.35;
            --lh-1: 1.5;
            --lh-2: 1.6;

            --space-1: 6px;
            --space-2: 10px;
            --space-3: 14px;
            --space-4: 20px;
            --space-5: 28px;
            --space-6: 40px;
            /* largest: between top-level questions */

            --nav-w: 120px;
            --indent: 18px;

            --focus-ring: 2px solid rgba(47, 95, 116, .55);
            --focus-offset: 2px;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: var(--bg);
            color: var(--ink);
            overflow-x: hidden;
            /* hard guardrail: never allow page horizontal scroll */
        }

        /* Top controls aligned with centered frame */
        .topbar {
            position: sticky;
            top: 0;
            z-index: 40;
            background: color-mix(in srgb, var(--bg) 88%, white 12%);
            border-bottom: 1px solid var(--hairline-2);
            backdrop-filter: blur(6px);
        }

        .topbar-inner {
            max-width: var(--frame-max);
            margin: 0 auto;
            padding: 10px var(--gutter);
            display: flex;
            align-items: center;
            gap: 12px;
            min-height: 52px;
        }

        .brandless-title {
            font-size: var(--fs-1);
            color: var(--ink-2);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            user-select: none;
        }

        .control {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex: 0 0 auto;
        }

        label {
            font-size: var(--fs-0);
            color: var(--ink-quiet);
        }

        select {
            font-size: var(--fs-0);
            line-height: 1.2;
            padding: 8px 10px;
            border: 1px solid var(--hairline);
            background: #fff;
            color: var(--ink-2);
            border-radius: 8px;
            max-width: 260px;
        }

        select:focus {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        .jumpBtn {
            font-size: var(--fs-0);
            line-height: 1.2;
            padding: 8px 10px;
            border: 1px solid var(--hairline);
            background: #fff;
            color: var(--ink-2);
            border-radius: 8px;
            cursor: pointer;
            display: none;
            /* shown on small screens */
            white-space: nowrap;
        }

        .jumpBtn:hover {
            text-decoration: underline;
        }

        .jumpBtn:focus {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        /* Centered content frame containing nav + paper */
        .frame {
            max-width: var(--frame-max);
            margin: 0 auto;
            padding: 0 var(--gutter) var(--space-6);
        }

        .surface {
            background: var(--surface);
            border: 1px solid var(--hairline-2);
            border-radius: 12px;
            padding: var(--space-5);
            margin-top: var(--space-4);
        }

        .columns {
            display: grid;
            grid-template-columns: var(--nav-w) 1fr;
            gap: 26px;
            align-items: start;
        }

        /* Navigation rail (quiet, sticky, scrollbar hidden when scrollable) */
        nav {
            position: sticky;
            top: 74px;
            /* below topbar */
            align-self: start;
            max-height: calc(100vh - 92px);
            overflow: hidden;
            /* outer container */
        }

        .navList {
            max-height: calc(100vh - 92px);
            overflow-y: auto;
            padding-right: 6px;
            /* space for hidden scrollbar */
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* legacy */
        }

        .navList::-webkit-scrollbar {
            display: none;
        }

        /* WebKit/Blink */

        .navSectionLabel {
            font-size: 12px;
            letter-spacing: .04em;
            text-transform: uppercase;
            color: var(--ink-quiet);
            margin: 14px 0 6px;
            user-select: none;
        }

        .navItem {
            display: block;
            width: 100%;
            text-align: left;
            background: transparent;
            border: 0;
            padding: 6px 6px;
            margin: 0;
            font-size: 12.5px;
            line-height: 1.2;
            color: var(--ink-quiet);
            cursor: pointer;
            border-left: 2px solid transparent;
            /* active marker: subtle */
            border-radius: 6px;
        }

        .navItem:hover {
            text-decoration: underline;
        }

        .navItem:focus {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        .navItem[aria-current="true"] {
            color: var(--ink-2);
            font-weight: 600;
            border-left-color: rgba(47, 95, 116, .55);
            /* restrained accent in non-content UI */
        }

        /* Paper content */
        main {
            min-width: 0;
        }

        .paperHeader {
            margin: 0 0 var(--space-5);
            padding-bottom: var(--space-3);
            border-bottom: 1px solid var(--hairline-2);
        }

        .paperLabel {
            font-size: var(--fs-2);
            line-height: var(--lh-1);
            color: var(--ink-2);
            margin: 0;
            font-weight: 600;
        }

        .paperMissing {
            font-size: var(--fs-2);
            color: var(--ink-2);
            padding: var(--space-6) 0;
        }

        /* Question blocks */
        .q {
            margin: 0 0 var(--space-6);
        }

        .q[data-depth="0"] {
            margin-bottom: var(--space-6);
        }

        .q[data-depth="1"] {
            margin-bottom: var(--space-5);
        }

        .q[data-depth="2"] {
            margin-bottom: var(--space-4);
        }

        .q[data-depth="3"] {
            margin-bottom: var(--space-4);
        }

        .qInner {
            padding-left: calc(var(--indent) * var(--depth, 0));
            min-width: 0;
        }

        .qLine {
            display: flex;
            gap: 10px;
            align-items: baseline;
            margin: 0 0 var(--space-2);
        }

        .qid {
            font-size: 12.5px;
            line-height: var(--lh-0);
            color: var(--ink-quiet);
            flex: 0 0 auto;
            min-width: 44px;
        }

        .qPrompt {
            flex: 1 1 auto;
            min-width: 0;
            font-size: var(--fs-3);
            line-height: var(--lh-2);
            color: var(--ink);
        }

        /* Answer */
        .answer {
            margin: 0 0 var(--space-2);
            display: flex;
            gap: 10px;
            align-items: baseline;
            min-width: 0;
        }

        .answerLabel {
            font-size: 12.5px;
            color: var(--ink-quiet);
            min-width: 44px;
            flex: 0 0 auto;
            font-weight: 600;
        }

        .answerBody {
            font-size: var(--fs-2);
            line-height: var(--lh-1);
            color: var(--ink-2);
            flex: 1 1 auto;
            min-width: 0;
        }

        /* Disclosure control (text-first) */
        .toggleRow {
            margin: 0 0 var(--space-3);
            display: flex;
            gap: 10px;
            align-items: baseline;
            min-width: 0;
        }

        .toggleSpacer {
            min-width: 44px;
            flex: 0 0 auto;
        }

        .toggleBtn {
            appearance: none;
            background: transparent;
            border: 0;
            padding: 0;
            font-size: 12.8px;
            line-height: 1.2;
            color: var(--accent);
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .toggleBtn:hover {
            text-decoration: underline;
        }

        .toggleBtn:focus {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        .chev {
            width: 10px;
            height: 10px;
            flex: 0 0 auto;
            transform: translateY(1px);
        }

        /* Solution details (subordinate, subtle surface separation allowed) */
        .solnWrap {
            margin-left: 54px;
            /* aligns under content column (after qid space) */
            padding: var(--space-3) 0 0;
            border-top: 1px solid var(--hairline-2);
        }

        .soln {
            padding: var(--space-3) 0 0;
            color: var(--ink-3);
            font-size: var(--fs-1);
            line-height: var(--lh-1);
        }

        .solnSection {
            margin: 0 0 var(--space-4);
        }

        .solnLabel {
            margin: 0 0 var(--space-2);
            font-size: 12.5px;
            color: var(--ink-2);
            font-weight: 600;
        }

        /* Keep in mind slightly more prominent than working body, but below answer */
        .keepInMind {
            color: color-mix(in srgb, var(--ink-3) 70%, var(--ink-2) 30%);
        }

        .keepInMind .solnLabel {
            display: inline-flex;
            gap: 8px;
            align-items: center;
        }

        .keepIcon {
            width: 12px;
            height: 12px;
            flex: 0 0 auto;
            opacity: .75;
        }

        .formulasUsed {
            color: var(--ink-3);
        }

        /* Working + Alternative working (quiet, denser) */
        .working,
        .altWorking {
            color: var(--ink-3);
        }

        /* Markdown defaults (quiet, paper-like) */
        .md p {
            margin: 0 0 var(--space-2);
        }

        .md p:last-child {
            margin-bottom: 0;
        }

        .md ul,
        .md ol {
            margin: 0 0 var(--space-2) 18px;
            padding: 0;
        }

        .md li {
            margin: 0 0 6px;
        }

        .md li:last-child {
            margin-bottom: 0;
        }

        .md table {
            border-collapse: collapse;
            margin: var(--space-2) 0;
            width: 100%;
            font-size: 13px;
            line-height: 1.35;
            color: var(--ink-3);
        }

        .md th,
        .md td {
            border: 1px solid var(--hairline);
            padding: 6px 8px;
            vertical-align: top;
        }

        .md th {
            font-weight: 600;
            color: var(--ink-2);
            background: transparent;
        }

        /* Table overflow: allow horizontal scroll only within table wrapper */
        .tableWrap {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            max-width: 100%;
        }

        .tableWrap::-webkit-scrollbar {
            display: none;
        }

        /* KaTeX containment invariant */
        .katex {
            max-width: 100%;
        }

        .katex-display {
            max-width: 100%;
            margin: var(--space-2) 0;
            overflow: visible;
            /* container handles overflow */
        }

        .katex-display>.katex {
            display: inline-block;
            max-width: 100%;
        }

        .katexBlock {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 2px 0;
        }

        .katexBlock::-webkit-scrollbar {
            display: none;
        }

        /* Display-math underlay exception: only inside working/altWorking, only display math blocks */
        .working .katexBlock .katex-display,
        .altWorking .katexBlock .katex-display {
            background: rgba(0, 0, 0, .035);
            padding: 6px 8px;
        }

        /* Inline KaTeX must never receive background */
        .katex:not(.katex-display .katex) {
            background: transparent !important;
        }

        /* Inline SVG diagrams: keep grayscale, prevent trapping */
        svg {
            max-width: 100%;
            height: auto;
        }

        /* Collapse/expand continuity (restrained; respects reduced motion) */
        .collapsible {
            overflow: hidden;
            max-height: 0;
            transition: max-height 180ms ease;
        }

        .collapsible.isOpen {
            max-height: 200000px;
            /* large enough; content drives scroll naturally */
            transition: max-height 220ms ease;
        }

        @media (prefers-reduced-motion: reduce) {
            .collapsible {
                transition: none;
            }

            html:focus-within {
                scroll-behavior: auto;
            }
        }

        html {
            scroll-behavior: smooth;
        }

        /* Mobile / tablet: drawer navigation */
        .drawerBackdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .20);
            z-index: 60;
            display: none;
        }

        .drawerBackdrop.isOpen {
            display: block;
        }

        .drawer {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            width: min(320px, 86vw);
            background: var(--surface);
            border-right: 1px solid var(--hairline-2);
            z-index: 70;
            transform: translateX(-102%);
            transition: transform 180ms ease;
            display: flex;
            flex-direction: column;
        }

        .drawer.isOpen {
            transform: translateX(0);
        }

        .drawerHeader {
            padding: 14px 14px 10px;
            border-bottom: 1px solid var(--hairline-2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .drawerTitle {
            margin: 0;
            font-size: 13px;
            color: var(--ink-2);
            font-weight: 600;
        }

        .drawerClose {
            background: transparent;
            border: 0;
            padding: 8px 10px;
            font-size: 13px;
            color: var(--accent);
            cursor: pointer;
        }

        .drawerClose:hover {
            text-decoration: underline;
        }

        .drawerClose:focus {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        .drawerBody {
            padding: 8px 10px 14px;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .drawerBody::-webkit-scrollbar {
            display: none;
        }

        /* Responsive layout switches */
        @media (max-width: 860px) {
            .columns {
                grid-template-columns: 1fr;
            }

            nav {
                display: none;
            }

            .jumpBtn {
                display: inline-flex;
            }

            .surface {
                padding: var(--space-4);
            }

            .solnWrap {
                margin-left: 54px;
            }
        }

        @media (max-width: 520px) {
            :root {
                --gutter: 14px;
            }

            .surface {
                padding: var(--space-4);
                border-radius: 10px;
            }

            .qid {
                min-width: 38px;
            }

            .answerLabel {
                min-width: 38px;
            }

            .toggleSpacer {
                min-width: 38px;
            }

            .solnWrap {
                margin-left: 46px;
            }

            .qPrompt {
                font-size: 18px;
            }
        }
    </style>
</head>

<body>
    <header class="topbar">
        <div class="topbar-inner">
            <div class="control">
                <label for="paperSelect">Paper</label>
                <select id="paperSelect" aria-label="Paper Selector" disabled>
                    <option>Loading…</option>
                </select>
            </div>

            <button id="jumpBtn" class="jumpBtn" type="button" aria-haspopup="dialog" aria-controls="drawer"
                aria-expanded="false">
                Jump to
            </button>

            <div class="brandless-title" id="paperMeta" aria-hidden="true"></div>
        </div>
    </header>

    <div class="frame">
        <div class="surface">
            <div class="columns">
                <nav aria-label="Document navigation">
                    <div id="navList" class="navList"></div>
                </nav>

                <main id="paper" aria-label="Paper content">
                    <div class="paperHeader">
                        <h1 class="paperLabel" id="paperTitle">Paper</h1>
                    </div>

                    <div id="paperContent"></div>
                </main>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div id="drawerBackdrop" class="drawerBackdrop" hidden></div>
    <div id="drawer" class="drawer" role="dialog" aria-modal="true" aria-label="Jump to question" hidden>
        <div class="drawerHeader">
            <p class="drawerTitle">Jump to</p>
            <button id="drawerClose" class="drawerClose" type="button">Close</button>
        </div>
        <div id="drawerNav" class="drawerBody"></div>
    </div>

    <script>
        // Canonical runtime constant (literal path string must appear only here)
        const RTQ_PAPERS_PAYLOAD_PATH = "../../payload/rtq.papers.payload.json";

        (function () {
            const elSelect = document.getElementById('paperSelect');
            const elPaperTitle = document.getElementById('paperTitle');
            const elPaperMeta = document.getElementById('paperMeta');
            const elNavList = document.getElementById('navList');
            const elDrawerNav = document.getElementById('drawerNav');
            const elContent = document.getElementById('paperContent');

            const elJumpBtn = document.getElementById('jumpBtn');
            const elDrawer = document.getElementById('drawer');
            const elBackdrop = document.getElementById('drawerBackdrop');
            const elDrawerClose = document.getElementById('drawerClose');

            let payload = null;
            let currentPaperIndex = 0;
            let md = null;
            let io = null;
            let lastFocusedBeforeDrawer = null;

            function initMarkdown() {
                if (!window.markdownit) return null;
                const instance = window.markdownit({
                    html: true,
                    linkify: false,
                    breaks: false
                });


                // // TeX backslash preservation: disable inline escape rule (required)
                // if (instance && instance.inline && instance.inline.ruler && instance.inline.ruler.disable) {
                //     instance.inline.ruler.disable(['escape']);
                // }






                // Preserve TeX backslashes by disabling inline escape rule
                if (instance && instance.inline && instance.inline.ruler && instance.inline.ruler.disable) {
                    instance.inline.ruler.disable(['escape']);
                }
                // Wrap tables to allow horizontal scroll only inside the wrapper
                const defaultRender = instance.renderer.rules.table_open || function (tokens, idx, options, env, self) {
                    return self.renderToken(tokens, idx, options);
                };
                instance.renderer.rules.table_open = function (tokens, idx, options, env, self) {
                    return '<div class="tableWrap">' + defaultRender(tokens, idx, options, env, self);
                };
                const defaultClose = instance.renderer.rules.table_close || function (tokens, idx, options, env, self) {
                    return self.renderToken(tokens, idx, options);
                };
                instance.renderer.rules.table_close = function (tokens, idx, options, env, self) {
                    return defaultClose(tokens, idx, options, env, self) + '</div>';
                };
                return instance;
            }

            function setShellForMissing() {
                elSelect.innerHTML = '';
                const opt = document.createElement('option');
                opt.textContent = 'Unavailable';
                elSelect.appendChild(opt);
                elSelect.disabled = true;

                elPaperTitle.textContent = 'Paper';
                elPaperMeta.textContent = '';
                elNavList.innerHTML = '';
                elDrawerNav.innerHTML = '';
                elContent.innerHTML = '';
                const msg = document.createElement('div');
                msg.className = 'paperMissing';
                msg.textContent = 'PAPERS PAYLOAD MISSING';
                elContent.appendChild(msg);
            }

            function safeText(v) {
                return (v === null || v === undefined) ? '' : String(v);
            }

            function clearActiveNav() {
                elNavList.querySelectorAll('[aria-current="true"]').forEach(b => b.setAttribute('aria-current', 'false'));
                elDrawerNav.querySelectorAll('[aria-current="true"]').forEach(b => b.setAttribute('aria-current', 'false'));
            }

            function setActiveNavById(id) {
                if (!id) return;
                clearActiveNav();
                const sel = `[data-target="${cssEscape(id)}"]`;
                const a = elNavList.querySelector(sel);
                const b = elDrawerNav.querySelector(sel);
                if (a) a.setAttribute('aria-current', 'true');
                if (b) b.setAttribute('aria-current', 'true');
            }

            function cssEscape(s) {
                if (window.CSS && CSS.escape) return CSS.escape(s);
                // minimal fallback
                return String(s).replace(/["\\]/g, '\\$&');
            }

            function openDrawer() {
                lastFocusedBeforeDrawer = document.activeElement;
                elBackdrop.hidden = false;
                elDrawer.hidden = false;
                elBackdrop.classList.add('isOpen');
                elDrawer.classList.add('isOpen');
                elJumpBtn.setAttribute('aria-expanded', 'true');
                document.body.style.overflow = 'hidden';

                // Focus first focusable in drawer (close button)
                elDrawerClose.focus();

                document.addEventListener('keydown', onDrawerKeydown, true);
                elBackdrop.addEventListener('click', onBackdropClick, { once: true });
            }

            function closeDrawer() {
                elBackdrop.classList.remove('isOpen');
                elDrawer.classList.remove('isOpen');
                elJumpBtn.setAttribute('aria-expanded', 'false');
                document.body.style.overflow = '';

                document.removeEventListener('keydown', onDrawerKeydown, true);

                // Hide after transition completes
                window.setTimeout(() => {
                    elBackdrop.hidden = true;
                    elDrawer.hidden = true;
                }, 190);

                if (lastFocusedBeforeDrawer && typeof lastFocusedBeforeDrawer.focus === 'function') {
                    lastFocusedBeforeDrawer.focus();
                }
            }

            function onBackdropClick() {
                closeDrawer();
            }

            function onDrawerKeydown(e) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeDrawer();
                    return;
                }
                // Basic focus trap
                if (e.key === 'Tab') {
                    const focusables = elDrawer.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
                    const list = Array.from(focusables).filter(x => !x.hasAttribute('disabled'));
                    if (!list.length) return;
                    const first = list[0];
                    const last = list[list.length - 1];
                    if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    } else if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            }

            elJumpBtn.addEventListener('click', () => {
                if (elDrawer.classList.contains('isOpen')) closeDrawer();
                else openDrawer();
            });
            elDrawerClose.addEventListener('click', closeDrawer);

            function scrollToQuestion(targetId) {
                const el = document.getElementById(targetId);
                if (!el) return;
                el.scrollIntoView({ block: 'start' });
            }

            function navButton(label, targetId, depth) {
                const b = document.createElement('button');
                b.type = 'button';
                b.className = 'navItem';
                b.textContent = label;
                b.dataset.target = targetId;
                b.setAttribute('aria-current', 'false');
                b.style.paddingLeft = (6 + Math.min(depth, 5) * 10) + 'px';
                b.addEventListener('click', () => {
                    closeDrawerIfOpen();
                    scrollToQuestion(targetId);
                });
                return b;
            }

            function closeDrawerIfOpen() {
                if (!elDrawer.hidden && elDrawer.classList.contains('isOpen')) {
                    closeDrawer();
                }
            }

            function renderMarkdownInto(container, markdownText) {
                const wrap = document.createElement('div');
                wrap.className = 'md';
                const raw = safeText(markdownText);

                if (md) {
                    // Render Markdown -> HTML (preserve authored structure; inline HTML allowed)
                    wrap.innerHTML = md.render(raw);
                } else {
                    // Fallback: plain text, preserving line breaks reasonably
                    wrap.textContent = raw;
                }
                container.appendChild(wrap);
                return wrap;
            }

            function ensureKatexBlockContainment(root) {
                // Wrap each KaTeX display so horizontal scroll is confined to the math block
                const displays = root.querySelectorAll('.katex-display');
                displays.forEach(d => {
                    if (d.parentElement && d.parentElement.classList.contains('katexBlock')) return;
                    const w = document.createElement('div');
                    w.className = 'katexBlock';
                    d.parentNode.insertBefore(w, d);
                    w.appendChild(d);
                });
            }

            function runKatexAutoRender(container) {
                if (!window.renderMathInElement) return;
                try {
                    window.renderMathInElement(container, {
                        delimiters: [
                            { left: "$$", right: "$$", display: true },
                            { left: "$", right: "$", display: false }
                        ],
                        throwOnError: false
                    });
                } catch (e) {
                    // Graceful fallback: do nothing; content remains as authored text
                }
            }

            function qAnchorId(paperKey, qPath) {
                // Stable DOM id: paperKey + path index string
                return `q_${paperKey}_${qPath.join('_')}`;
            }

            function buildQuestionBlock(node, depth, paperKey, path, expandedAll) {
                const qOuter = document.createElement('section');
                qOuter.className = 'q';
                qOuter.dataset.depth = String(depth);
                qOuter.style.setProperty('--depth', String(depth));
                const anchorId = qAnchorId(paperKey, path);
                qOuter.id = anchorId;

                const qInner = document.createElement('div');
                qInner.className = 'qInner';

                const qLine = document.createElement('div');
                qLine.className = 'qLine';

                const qid = document.createElement('div');
                qid.className = 'qid';
                qid.textContent = safeText(node && node.id);

                const qPrompt = document.createElement('div');
                qPrompt.className = 'qPrompt';
                renderMarkdownInto(qPrompt, node && node.question);

                qLine.appendChild(qid);
                qLine.appendChild(qPrompt);

                const answerRow = document.createElement('div');
                answerRow.className = 'answer';

                const ansLabel = document.createElement('div');
                ansLabel.className = 'answerLabel';
                ansLabel.textContent = 'Answer';

                const ansBody = document.createElement('div');
                ansBody.className = 'answerBody';
                renderMarkdownInto(ansBody, node && node.answer);

                answerRow.appendChild(ansLabel);
                answerRow.appendChild(ansBody);

                qInner.appendChild(qLine);
                qInner.appendChild(answerRow);

                // Solution details (optional)
                const sd = node && node.solutionDetails ? node.solutionDetails : null;
                if (sd) {
                    const toggleRow = document.createElement('div');
                    toggleRow.className = 'toggleRow';

                    const spacer = document.createElement('div');
                    spacer.className = 'toggleSpacer';

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'toggleBtn';
                    btn.setAttribute('aria-expanded', expandedAll ? 'true' : 'false');

                    const chev = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    chev.setAttribute('viewBox', '0 0 12 12');
                    chev.setAttribute('class', 'chev');
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', 'M3 4.5l3 3 3-3');
                    pathEl.setAttribute('fill', 'none');
                    pathEl.setAttribute('stroke', 'currentColor');
                    pathEl.setAttribute('stroke-width', '1.5');
                    pathEl.setAttribute('stroke-linecap', 'round');
                    pathEl.setAttribute('stroke-linejoin', 'round');
                    chev.appendChild(pathEl);

                    const labelSpan = document.createElement('span');
                    labelSpan.textContent = expandedAll ? 'Hide working' : 'Show working';

                    btn.appendChild(labelSpan);
                    btn.appendChild(chev);

                    const solnWrap = document.createElement('div');
                    solnWrap.className = 'solnWrap';

                    const collapsible = document.createElement('div');
                    collapsible.className = 'collapsible' + (expandedAll ? ' isOpen' : '');
                    collapsible.setAttribute('aria-hidden', expandedAll ? 'false' : 'true');

                    const soln = document.createElement('div');
                    soln.className = 'soln';

                    // Keep in mind (optional)
                    if (sd.keepInMind !== undefined && sd.keepInMind !== null && String(sd.keepInMind).trim() !== '') {
                        const sec = document.createElement('section');
                        sec.className = 'solnSection keepInMind';

                        const lab = document.createElement('div');
                        lab.className = 'solnLabel';

                        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        icon.setAttribute('viewBox', '0 0 12 12');
                        icon.setAttribute('class', 'keepIcon');
                        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        c.setAttribute('cx', '6'); c.setAttribute('cy', '6'); c.setAttribute('r', '4.3');
                        c.setAttribute('fill', 'none');
                        c.setAttribute('stroke', 'currentColor');
                        c.setAttribute('stroke-width', '1.2');
                        const l = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        l.setAttribute('d', 'M6 3.7v.2M6 5.3v3');
                        l.setAttribute('stroke', 'currentColor');
                        l.setAttribute('stroke-width', '1.2');
                        l.setAttribute('stroke-linecap', 'round');
                        icon.appendChild(c);
                        icon.appendChild(l);

                        const t = document.createElement('span');
                        t.textContent = 'Keep in mind';

                        lab.appendChild(icon);
                        lab.appendChild(t);

                        sec.appendChild(lab);
                        renderMarkdownInto(sec, sd.keepInMind);
                        soln.appendChild(sec);
                    }

                    // Formulas used (optional)
                    if (sd.formulasUsed !== undefined && sd.formulasUsed !== null && String(sd.formulasUsed).trim() !== '') {
                        const sec = document.createElement('section');
                        sec.className = 'solnSection formulasUsed';

                        const lab = document.createElement('div');
                        lab.className = 'solnLabel';
                        lab.textContent = 'Formulas used';

                        sec.appendChild(lab);
                        renderMarkdownInto(sec, sd.formulasUsed);
                        soln.appendChild(sec);
                    }

                    // Working (primary) (optional)
                    if (sd.working !== undefined && sd.working !== null && String(sd.working).trim() !== '') {
                        const sec = document.createElement('section');
                        sec.className = 'solnSection working';

                        const lab = document.createElement('div');
                        lab.className = 'solnLabel';
                        lab.textContent = 'Working';

                        sec.appendChild(lab);
                        renderMarkdownInto(sec, sd.working);
                        soln.appendChild(sec);
                    }

                    // Alternative working (optional)
                    if (sd.alternativeWorking !== undefined && sd.alternativeWorking !== null && String(sd.alternativeWorking).trim() !== '') {
                        const sec = document.createElement('section');
                        sec.className = 'solnSection altWorking';

                        const lab = document.createElement('div');
                        lab.className = 'solnLabel';
                        lab.textContent = 'Alternative working';

                        sec.appendChild(lab);
                        renderMarkdownInto(sec, sd.alternativeWorking);
                        soln.appendChild(sec);
                    }

                    collapsible.appendChild(soln);
                    solnWrap.appendChild(collapsible);

                    btn.addEventListener('click', () => {
                        const isOpen = collapsible.classList.contains('isOpen');
                        const next = !isOpen;
                        collapsible.classList.toggle('isOpen', next);
                        collapsible.setAttribute('aria-hidden', next ? 'false' : 'true');
                        btn.setAttribute('aria-expanded', next ? 'true' : 'false');
                        labelSpan.textContent = next ? 'Hide working' : 'Show working';

                        // After expand/collapse, rerun KaTeX on this region only if needed
                        // (does not move focus; does not auto-scroll)
                        window.setTimeout(() => {
                            if (next) {
                                runKatexAutoRender(soln);
                                ensureKatexBlockContainment(soln);
                            }
                        }, 0);
                    });

                    toggleRow.appendChild(spacer);
                    toggleRow.appendChild(btn);

                    qInner.appendChild(toggleRow);
                    qInner.appendChild(solnWrap);
                }

                qOuter.appendChild(qInner);
                return qOuter;
            }

            function collectNavEntriesFromQuestions(questions, paperKey, sectionLabel, depthBase, pathBase, out) {
                (questions || []).forEach((q, i) => {
                    const path = pathBase.concat([i]);
                    const anchorId = qAnchorId(paperKey, path);
                    out.push({
                        section: sectionLabel,
                        id: safeText(q && q.id),
                        target: anchorId,
                        depth: depthBase
                    });
                    if (q && Array.isArray(q.children) && q.children.length) {
                        collectNavEntriesFromQuestions(q.children, paperKey, sectionLabel, depthBase + 1, path.concat(['c']), out);
                    }
                });
            }

            function renderPaper(paper) {
                // Reset
                elNavList.innerHTML = '';
                elDrawerNav.innerHTML = '';
                elContent.innerHTML = '';

                if (io) {
                    io.disconnect();
                    io = null;
                }

                const paperKey = safeText(paper && paper.key);
                const paperLabel = safeText(paper && paper.label) || 'Paper';
                elPaperTitle.textContent = paperLabel;
                elPaperMeta.textContent = '';

                const defaults = (paper && paper.defaults) ? paper.defaults : {};
                const expandedAll = !!(defaults && defaults.expandedAll);

                const navEntries = [];
                const fragments = document.createDocumentFragment();

                if (paper && Array.isArray(paper.sections)) {
                    paper.sections.forEach((sec, secIndex) => {
                        const secLabel = safeText(sec && sec.label);
                        const secQuestions = (sec && Array.isArray(sec.questions)) ? sec.questions : [];

                        // Content: section label as structural divider (plain)
                        const divider = document.createElement('div');
                        divider.className = 'q';
                        divider.dataset.depth = "0";
                        divider.style.marginBottom = '26px';

                        const inner = document.createElement('div');
                        inner.className = 'qInner';

                        const line = document.createElement('div');
                        line.className = 'qLine';

                        const left = document.createElement('div');
                        left.className = 'qid';
                        left.textContent = secLabel;

                        const right = document.createElement('div');
                        right.className = 'qPrompt';
                        right.innerHTML = `<div class="md"><p><strong>${secLabel}</strong></p></div>`;

                        line.appendChild(left);
                        line.appendChild(right);
                        inner.appendChild(line);
                        divider.appendChild(inner);
                        fragments.appendChild(divider);

                        // Nav: section separator label (non-clickable)
                        // Questions under section
                        const base = [secIndex, 's'];
                        collectNavEntriesFromQuestions(secQuestions, paperKey, secLabel, 0, base, navEntries);

                        // Render questions in section
                        secQuestions.forEach((q, i) => {
                            const node = q || {};
                            const path = base.concat([i]);
                            fragments.appendChild(buildQuestionTree(node, 0, paperKey, path, expandedAll));
                        });
                    });
                } else {
                    const questions = (paper && Array.isArray(paper.questions)) ? paper.questions : [];
                    collectNavEntriesFromQuestions(questions, paperKey, null, 0, ['q'], navEntries);
                    questions.forEach((q, i) => {
                        const node = q || {};
                        fragments.appendChild(buildQuestionTree(node, 0, paperKey, ['q', i], expandedAll));
                    });
                }

                elContent.appendChild(fragments);

                // Render navigation with section separators (if any)
                const navFragA = document.createDocumentFragment();
                const navFragB = document.createDocumentFragment();

                let lastSection = null;
                navEntries.forEach(ent => {
                    if (ent.section !== lastSection) {
                        lastSection = ent.section;
                        if (lastSection) {
                            const sepA = document.createElement('div');
                            sepA.className = 'navSectionLabel';
                            sepA.textContent = lastSection;
                            navFragA.appendChild(sepA);

                            const sepB = document.createElement('div');
                            sepB.className = 'navSectionLabel';
                            sepB.textContent = lastSection;
                            navFragB.appendChild(sepB);
                        }
                    }
                    const label = safeText(ent.id);
                    const btnA = navButton(label, ent.target, ent.depth);
                    const btnB = navButton(label, ent.target, ent.depth);
                    navFragA.appendChild(btnA);
                    navFragB.appendChild(btnB);
                });

                elNavList.appendChild(navFragA);
                elDrawerNav.appendChild(navFragB);

                // Markdown already rendered; run KaTeX after Markdown
                runKatexAutoRender(elContent);
                ensureKatexBlockContainment(elContent);

                // Active position tracking (quiet)
                setupActiveTracking();
                // Set initial active to first question if exists
                const first = navEntries[0] ? navEntries[0].target : null;
                if (first) setActiveNavById(first);
            }

            function buildQuestionTree(node, depth, paperKey, path, expandedAll) {
                const frag = document.createDocumentFragment();
                frag.appendChild(buildQuestionBlock(node, depth, paperKey, path, expandedAll));

                const children = (node && Array.isArray(node.children)) ? node.children : [];
                children.forEach((child, idx) => {
                    const childPath = path.concat(['c', idx]);
                    frag.appendChild(buildQuestionTree(child, depth + 1, paperKey, childPath, expandedAll));
                });

                return frag;
            }

            function setupActiveTracking() {
                const items = Array.from(document.querySelectorAll('section.q[id]'));
                if (!items.length) return;

                if (io) io.disconnect();
                io = new IntersectionObserver((entries) => {
                    // Choose the topmost visible entry (closest to top)
                    const visible = entries
                        .filter(e => e.isIntersecting)
                        .sort((a, b) => (a.boundingClientRect.top - b.boundingClientRect.top));
                    if (visible.length) {
                        setActiveNavById(visible[0].target.id);
                    }
                }, {
                    root: null,
                    rootMargin: '-18% 0px -70% 0px',
                    threshold: [0, 0.1, 0.2]
                });

                items.forEach(el => io.observe(el));
            }

            function populateSelector() {
                elSelect.innerHTML = '';
                const papers = (payload && Array.isArray(payload.papers)) ? payload.papers : [];
                papers.forEach((p, idx) => {
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    opt.textContent = safeText(p && p.label) || safeText(p && p.key) || `Paper ${idx + 1}`;
                    elSelect.appendChild(opt);
                });
                elSelect.disabled = (papers.length === 0);

                elSelect.value = String(currentPaperIndex);

                elSelect.addEventListener('change', () => {
                    const next = parseInt(elSelect.value, 10);
                    if (!Number.isFinite(next)) return;
                    currentPaperIndex = Math.max(0, Math.min(next, papers.length - 1));
                    renderPaper(papers[currentPaperIndex]);
                });
            }

            async function loadPayload() {
                try {
                    const res = await fetch(RTQ_PAPERS_PAYLOAD_PATH, { cache: 'no-store' });
                    if (!res.ok) throw new Error('bad response');
                    const json = await res.json();
                    payload = json;
                    return true;
                } catch (e) {
                    payload = null;
                    return false;
                }
            }

            function updatePaperMeta() {
                // Intentionally quiet; no progress/status semantics
                elPaperMeta.textContent = '';
            }

            function wireNavKeyboardScroll() {
                // Ensure nav supports keyboard scrolling (focusable region)
                elNavList.setAttribute('tabindex', '0');
                elNavList.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowDown') { elNavList.scrollTop += 24; e.preventDefault(); }
                    if (e.key === 'ArrowUp') { elNavList.scrollTop -= 24; e.preventDefault(); }
                    if (e.key === 'PageDown') { elNavList.scrollTop += 240; e.preventDefault(); }
                    if (e.key === 'PageUp') { elNavList.scrollTop -= 240; e.preventDefault(); }
                    if (e.key === 'Home') { elNavList.scrollTop = 0; e.preventDefault(); }
                    if (e.key === 'End') { elNavList.scrollTop = elNavList.scrollHeight; e.preventDefault(); }
                });
            }

            function boot() {
                md = initMarkdown();
                wireNavKeyboardScroll();

                // Enable selector after payload load
                Promise.all([
                    new Promise(r => {
                        // Wait for deferred scripts reasonably
                        const t0 = Date.now();
                        (function tick() {
                            const ready = !!window.markdownit;
                            if (ready || (Date.now() - t0) > 1200) return r();
                            requestAnimationFrame(tick);
                        })();
                    }),
                    loadPayload()
                ]).then(([, ok]) => {
                    if (!ok || !payload || !Array.isArray(payload.papers)) {
                        setShellForMissing();
                        return;
                    }
                    populateSelector();
                    updatePaperMeta();
                    const papers = payload.papers;
                    const paper = papers[currentPaperIndex] || papers[0];
                    currentPaperIndex = papers.indexOf(paper);
                    elSelect.value = String(currentPaperIndex);
                    renderPaper(paper);
                });
            }

            boot();
        })();
    </script>
</body>

</html>