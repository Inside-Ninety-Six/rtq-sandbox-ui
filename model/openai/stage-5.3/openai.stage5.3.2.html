<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>RTQ — Maths Paper Solution Viewer (Stress Test Harness)</title>

    <!-- KaTeX (Real KaTeX Rendering add-on enabled) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"
        integrity="sha384-nB0miv6/jRmo5V6m5rj7fYv2x0b8bE8wVtXW7b2i8vQw8GQy8mYqk8Kp7hY8wYkG" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"
        integrity="sha384-7zkQWkzVxX7k9rj0p9E9rY6m8qz9p0Qb8s2b2tQm7v6Gm2l5p3xk6m2p1m0r1"
        crossorigin="anonymous"></script>

    <style>
        :root {
            /* Base surface temperature: soft cool-neutral (slight blue/graphite bias). */
            --bg: #f3f4f7;
            --paper: #f8f9fb;
            --paper-edge: #e2e6ee;

            --text: #12161d;
            --muted: #3d4756;
            --quiet: #687384;

            --hair: rgba(18, 22, 29, .14);
            --hair2: rgba(18, 22, 29, .10);

            /* Single restrained non-semantic accent (links/focus/key affordances only). */
            --accent: #2a6f7a;

            /* Rhythm scale */
            --s1: 6px;
            --s2: 10px;
            --s3: 14px;
            --s4: 18px;
            --s5: 26px;
            --s6: 36px;

            --frame-max: 1200px;
            --rail-w: 168px;
            --topbar-h: 56px;

            --radius: 12px;
            --focus-ring: 2px solid rgba(42, 111, 122, .75);
            --focus-offset: 2px;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            overflow-x: hidden;
            /* page must never scroll horizontally */
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.45;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Top controls aligned to centered frame */
        header.topbar {
            position: sticky;
            top: 0;
            z-index: 50;
            background: linear-gradient(to bottom, rgba(243, 244, 247, .92), rgba(243, 244, 247, .76));
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--hair2);
        }

        .topbar-inner {
            max-width: var(--frame-max);
            margin: 0 auto;
            padding: 10px 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            min-height: var(--topbar-h);
        }

        .topbar-title {
            font-size: 13px;
            color: var(--quiet);
            letter-spacing: .01em;
            white-space: nowrap;
            user-select: none;
        }

        .topbar-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .field {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 0;
        }

        label.small {
            font-size: 12px;
            color: var(--quiet);
            white-space: nowrap;
            user-select: none;
        }

        select {
            font-size: 13px;
            color: var(--text);
            background: rgba(248, 249, 251, .85);
            border: 1px solid var(--hair2);
            border-radius: 10px;
            padding: 9px 10px;
            outline: none;
            min-width: 240px;
            max-width: 100%;
        }

        select:focus-visible {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        .jump-btn {
            margin-left: auto;
            font-size: 13px;
            color: var(--accent);
            background: transparent;
            border: 1px solid transparent;
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        .jump-btn:hover {
            color: rgba(42, 111, 122, .88);
        }

        .jump-btn:focus-visible {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        @media (min-width: 901px) {
            .jump-btn {
                display: none;
            }
        }

        /* Centered frame containing nav rail + paper column */
        .frame {
            max-width: var(--frame-max);
            margin: 16px auto 64px;
            padding: 0 14px;
        }

        .frame-surface {
            background: var(--paper);
            border: 1px solid var(--paper-edge);
            border-radius: var(--radius);
            padding: 16px;
        }

        .columns {
            display: grid;
            grid-template-columns: var(--rail-w) minmax(0, 1fr);
            gap: 24px;
            align-items: start;
        }

        /* Navigation rail (quiet, no background fill, inside same surface) */
        nav.rail {
            position: sticky;
            top: calc(var(--topbar-h) + 28px);
            align-self: start;
            padding: 6px 0;
            background: transparent;
            border: 0;
        }

        .rail-title {
            font-size: 12px;
            color: var(--quiet);
            letter-spacing: .02em;
            margin: 0 0 10px 0;
            user-select: none;
        }

        .rail-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: calc(100vh - (var(--topbar-h) + 60px));
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* legacy */
        }

        .rail-list::-webkit-scrollbar {
            display: none;
        }

        .rail-sep {
            font-size: 12px;
            color: rgba(18, 22, 29, .55);
            margin: 14px 0 6px;
            padding: 0 6px;
            user-select: none;
        }

        .rail-link {
            display: flex;
            align-items: baseline;
            gap: 6px;
            padding: 6px 6px;
            text-decoration: none;
            color: rgba(18, 22, 29, .62);
            border-radius: 8px;
            outline: none;
        }

        .rail-link:hover {
            text-decoration: underline;
            text-underline-offset: 3px;
            color: rgba(18, 22, 29, .72);
        }

        .rail-link:focus-visible {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        /* Current item: weight-only as primary cue */
        .rail-link[aria-current="true"] {
            color: rgba(18, 22, 29, .82);
            font-weight: 650;
        }

        .rail-id {
            font-size: 12px;
            line-height: 1.2;
        }

        .rail-indent-0 {
            padding-left: 6px;
        }

        .rail-indent-1 {
            padding-left: 18px;
        }

        .rail-indent-2 {
            padding-left: 30px;
        }

        .rail-indent-3 {
            padding-left: 42px;
        }

        /* Paper content column */
        main.paper {
            min-width: 0;
        }

        .paper-title {
            margin: 4px 0 18px;
            font-size: 14px;
            color: var(--quiet);
            letter-spacing: .01em;
            user-select: none;
        }

        /* Question blocks (no cards/panels; spacing is grouping) */
        .q {
            margin: 0 0 var(--s6) 0;
            /* strongest separation between top-level questions */
            padding: 0;
        }

        /* Scroll anchoring (so sticky topbar doesn't cover headings) */
        .anchor {
            scroll-margin-top: calc(var(--topbar-h) + 22px);
        }

        .q-head {
            display: flex;
            gap: 10px;
            align-items: baseline;
            margin: 0 0 var(--s2);
        }

        .qid {
            font-size: 14px;
            color: rgba(18, 22, 29, .72);
            flex: 0 0 auto;
            user-select: none;
        }

        .qtext {
            font-size: 16px;
            line-height: 1.55;
            color: rgba(18, 22, 29, .92);
            margin: 0;
            flex: 1 1 auto;
            min-width: 0;
        }

        /* Sub-questions: indentation + weaker separation */
        .sub {
            margin-top: var(--s5);
            padding-left: 18px;
        }

        .sub.depth-2 {
            padding-left: 32px;
            margin-top: var(--s4);
        }

        .sub.depth-3 {
            padding-left: 44px;
            margin-top: var(--s3);
        }

        .answer {
            margin: 0 0 var(--s2);
            display: flex;
            gap: 10px;
            align-items: baseline;
        }

        .alabel {
            font-size: 12px;
            font-weight: 650;
            color: rgba(18, 22, 29, .74);
            user-select: none;
            flex: 0 0 auto;
        }

        .aval {
            font-size: 14px;
            color: rgba(18, 22, 29, .86);
            margin: 0;
            min-width: 0;
        }

        .aval ul {
            margin: 0;
            padding-left: 18px;
        }

        .aval li {
            margin: 2px 0;
        }

        /* Disclosure control: text-first, not button-like */
        .toggle {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 0;
            margin: 0 0 var(--s2);
            background: transparent;
            border: 0;
            color: var(--accent);
            font-size: 13px;
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        .toggle:hover {
            color: rgba(42, 111, 122, .88);
        }

        .toggle:focus-visible {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
            border-radius: 8px;
        }

        .chev {
            width: 10px;
            height: 10px;
            flex: 0 0 auto;
            opacity: .72;
            transform: translateY(1px);
        }

        .toggle[aria-expanded="true"] .chev {
            transform: rotate(180deg) translateY(-1px);
        }

        /* Solution Details: subtle surface separation + hairline divider (no card framing) */
        .sol {
            border-top: 1px solid var(--hair2);
            background: rgba(18, 22, 29, .03);
            padding: 12px 12px 10px;
            margin: 0 0 var(--s2);
        }

        /* Subsections inside Solution Details */
        .sol-section {
            margin: 0 0 var(--s3);
        }

        .sol-section:last-child {
            margin-bottom: 0;
        }

        .sol-label {
            font-size: 12px;
            font-weight: 650;
            color: rgba(18, 22, 29, .70);
            margin: 0 0 var(--s1);
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kim-icon {
            width: 14px;
            height: 14px;
            opacity: .65;
            flex: 0 0 auto;
        }

        /* Keep in mind: slightly more prominent than Working, but still subordinate */
        .keep .sol-label {
            color: rgba(18, 22, 29, .74);
        }

        .keep .sol-body {
            color: rgba(18, 22, 29, .68);
            font-size: 13px;
            line-height: 1.5;
        }

        .keep ul {
            margin: 0;
            padding-left: 18px;
        }

        .keep li {
            margin: 4px 0;
        }

        /* Formulas used: quieter than Keep in mind */
        .formulas .sol-body {
            color: rgba(18, 22, 29, .62);
            font-size: 13px;
            line-height: 1.45;
        }

        .formula-line {
            margin: 4px 0;
        }

        /* Working blocks */
        .workings .sol-body,
        .alt-workings .sol-body {
            color: rgba(18, 22, 29, .62);
            font-size: 13px;
            line-height: 1.5;
        }

        .workings .p,
        .alt-workings .p {
            margin: 0 0 var(--s2);
        }

        .workings .phase-gap,
        .alt-workings .phase-gap {
            margin-top: var(--s3);
        }

        /* Math containment: only math blocks can scroll horizontally */
        .math-inline {
            white-space: nowrap;
        }

        .math-block {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            padding: 6px 8px;
            margin: 0 0 var(--s2);
        }

        .math-block::-webkit-scrollbar {
            display: none;
        }

        /* Stage 3 underlay exception: display-math underlay only within Working/Alternative working */
        .workings .math-block,
        .alt-workings .math-block {
            background: rgba(18, 22, 29, .035);
        }

        /* Prevent KaTeX from widening containers */
        .math-block .katex-display {
            margin: 0;
        }

        .math-block .katex-display>.katex {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* Tables in workings */
        .table-wrap {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
            margin: 0 0 var(--s2);
        }

        .table-wrap::-webkit-scrollbar {
            display: none;
        }

        table.min {
            border-collapse: collapse;
            width: 100%;
            min-width: 520px;
            font-size: 13px;
            color: rgba(18, 22, 29, .64);
        }

        table.min th,
        table.min td {
            border: 1px solid var(--hair2);
            padding: 8px 10px;
            vertical-align: top;
        }

        table.min th {
            font-weight: 650;
            color: rgba(18, 22, 29, .68);
            text-align: left;
            background: transparent;
        }

        /* Diagrams (SVG placeholders) */
        .diagram {
            margin: var(--s2) 0 var(--s2);
            max-width: 100%;
        }

        .diagram svg {
            width: 100%;
            height: auto;
            display: block;
        }

        .diagram-caption {
            font-size: 12px;
            color: rgba(18, 22, 29, .55);
            margin-top: 6px;
            user-select: none;
        }

        /* Links in content (rare) */
        a.link {
            color: var(--accent);
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        a.link:focus-visible {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
            border-radius: 6px;
        }

        /* Mobile layout: nav rail hidden, content becomes single column */
        @media (max-width: 900px) {
            :root {
                --rail-w: 0px;
            }

            .columns {
                grid-template-columns: 1fr;
                gap: 0;
            }

            nav.rail {
                display: none;
            }

            .frame-surface {
                padding: 14px;
            }

            .qtext {
                font-size: 15px;
            }

            .qid {
                font-size: 13px;
            }
        }

        /* Drawer (mobile navigation pattern: drawer, not modal overlay) */
        .drawer {
            position: fixed;
            top: var(--topbar-h);
            left: 0;
            bottom: 0;
            width: min(320px, 86vw);
            background: var(--paper);
            border-right: 1px solid var(--paper-edge);
            transform: translateX(-100%);
            transition: transform 160ms ease;
            z-index: 60;
            padding: 12px 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .drawer[aria-hidden="false"] {
            transform: translateX(0);
        }

        @media (prefers-reduced-motion: reduce) {
            .drawer {
                transition: none;
            }
        }

        .drawer-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 4px 4px 2px;
        }

        .drawer-title {
            font-size: 12px;
            color: var(--quiet);
            letter-spacing: .02em;
            user-select: none;
            margin: 0;
        }

        .drawer-close {
            font-size: 13px;
            color: var(--accent);
            background: transparent;
            border: 0;
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        .drawer-close:hover {
            color: rgba(42, 111, 122, .88);
        }

        .drawer-close:focus-visible {
            outline: var(--focus-ring);
            outline-offset: var(--focus-offset);
        }

        .drawer-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .drawer-list::-webkit-scrollbar {
            display: none;
        }

        .backdrop {
            position: fixed;
            inset: 0;
            top: var(--topbar-h);
            background: rgba(18, 22, 29, .20);
            opacity: 0;
            pointer-events: none;
            transition: opacity 160ms ease;
            z-index: 55;
        }

        .backdrop[aria-hidden="false"] {
            opacity: 1;
            pointer-events: auto;
        }

        @media (prefers-reduced-motion: reduce) {
            .backdrop {
                transition: none;
            }
        }

        /* Focus visibility across buttons/links */
        button {
            font-family: inherit;
        }

        /* Utility: visually hidden */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>

<body>
    <header class="topbar">
        <div class="topbar-inner">
            <div class="topbar-title">RTQ</div>
            <div class="topbar-controls">
                <div class="field" role="group" aria-label="Paper selector">
                    <label class="small" for="paperSelect">Paper</label>
                    <select id="paperSelect" aria-label="Paper selector">
                        <!-- options injected -->
                    </select>
                </div>
                <button class="jump-btn" id="openDrawer" type="button">Jump to</button>
            </div>
        </div>
    </header>

    <!-- Mobile drawer + backdrop (drawer pattern) -->
    <div class="backdrop" id="backdrop" aria-hidden="true"></div>
    <aside class="drawer" id="drawer" aria-hidden="true" aria-label="Question navigation drawer">
        <div class="drawer-head">
            <p class="drawer-title">Jump to</p>
            <button class="drawer-close" id="closeDrawer" type="button">Close</button>
        </div>
        <ul class="drawer-list" id="drawerNav"></ul>
    </aside>

    <div class="frame" id="appFrame">
        <div class="frame-surface">
            <div class="columns">
                <nav class="rail" aria-label="Question navigation">
                    <div class="rail-title">Jump to</div>
                    <ul class="rail-list" id="railNav"></ul>
                </nav>

                <main class="paper" id="paper" tabindex="-1">
                    <div class="paper-title" id="paperTitle"></div>
                    <div id="paperBody"></div>
                </main>
            </div>
        </div>
    </div>

    <script>
        (function () {
            const KEEP_IN_MIND = [
                "Use the correct order of operations (BIDMAS).",
                "Check units and convert if needed.",
                "Line up digits carefully when adding or subtracting.",
                "When dividing by a fraction, multiply by the reciprocal.",
                "Show each step clearly; don’t do too much in one line.",
                "Write the final answer with the correct unit."
            ];

            const FORMULAS = [
                "Percentage = (part ÷ whole) × 100%",
                "Area of triangle = ½ × base × height",
                "Area of square = side²",
                "Perimeter of square = 4 × side",
                "Speed = distance ÷ time",
                "1 m = 100 cm",
                "1 kg = 1000 g"
            ];

            const el = (tag, attrs = {}, children = []) => {
                const n = document.createElement(tag);
                for (const [k, v] of Object.entries(attrs)) {
                    if (k === "class") n.className = v;
                    else if (k === "html") n.innerHTML = v;
                    else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
                    else if (v === null || v === undefined) { }
                    else n.setAttribute(k, v);
                }
                for (const c of children) {
                    if (c === null || c === undefined) continue;
                    if (typeof c === "string") n.appendChild(document.createTextNode(c));
                    else n.appendChild(c);
                }
                return n;
            };

            const svgIconKeep = () => `
    <svg class="kim-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M12 3.5c4.7 0 8.5 3.8 8.5 8.5S16.7 20.5 12 20.5 3.5 16.7 3.5 12 7.3 3.5 12 3.5Z" stroke="rgba(18,22,29,.55)" stroke-width="1.5"/>
      <path d="M12 7.4v5.1" stroke="rgba(18,22,29,.55)" stroke-width="1.5" stroke-linecap="round"/>
      <path d="M12 15.9h.01" stroke="rgba(18,22,29,.55)" stroke-width="2.2" stroke-linecap="round"/>
    </svg>
  `;

            /* Diagram types (inline SVG, grayscale) */
            function diagramSVG(type) {
                const common = `stroke="rgba(18,22,29,.55)" stroke-width="1.2" fill="none"`;
                const light = `stroke="rgba(18,22,29,.25)" stroke-width="1" fill="none"`;
                if (type === "geometry") {
                    return `
      <svg viewBox="0 0 360 180" role="img" aria-label="Geometry diagram">
        <path d="M60 140 L180 30 L300 140 Z" ${common}/>
        <circle cx="180" cy="30" r="3" fill="rgba(18,22,29,.55)"/>
        <circle cx="60" cy="140" r="3" fill="rgba(18,22,29,.55)"/>
        <circle cx="300" cy="140" r="3" fill="rgba(18,22,29,.55)"/>
        <path d="M180 30 L180 140" ${light}/>
        <path d="M170 120 L180 140 L190 120" ${light}/>
        <text x="172" y="24" font-size="12" fill="rgba(18,22,29,.65)">A</text>
        <text x="44" y="154" font-size="12" fill="rgba(18,22,29,.65)">B</text>
        <text x="306" y="154" font-size="12" fill="rgba(18,22,29,.65)">C</text>
        <text x="186" y="92" font-size="12" fill="rgba(18,22,29,.55)">h</text>
        <text x="170" y="156" font-size="12" fill="rgba(18,22,29,.55)">base</text>
      </svg>`;
                }
                if (type === "bars") {
                    return `
      <svg viewBox="0 0 360 140" role="img" aria-label="Ratio bars diagram">
        <rect x="40" y="40" width="280" height="22" fill="rgba(18,22,29,.06)" stroke="rgba(18,22,29,.35)" stroke-width="1"/>
        <rect x="40" y="78" width="280" height="22" fill="rgba(18,22,29,.03)" stroke="rgba(18,22,29,.35)" stroke-width="1"/>
        <path d="M140 40 V62" ${light}/>
        <path d="M240 40 V62" ${light}/>
        <path d="M100 78 V100" ${light}/>
        <path d="M200 78 V100" ${light}/>
        <text x="40" y="30" font-size="12" fill="rgba(18,22,29,.65)">Ratio bar</text>
        <text x="42" y="56" font-size="12" fill="rgba(18,22,29,.55)">A</text>
        <text x="42" y="94" font-size="12" fill="rgba(18,22,29,.55)">B</text>
      </svg>`;
                }
                if (type === "grid") {
                    return `
      <svg viewBox="0 0 360 200" role="img" aria-label="Coordinate grid diagram">
        <rect x="50" y="20" width="260" height="160" fill="rgba(18,22,29,.02)" stroke="rgba(18,22,29,.35)" stroke-width="1"/>
        ${Array.from({ length: 12 }).map((_, i) => `<path d="M${50 + i * 22} 20 V180" ${light}/>`).join("")}
        ${Array.from({ length: 8 }).map((_, i) => `<path d="M50 ${20 + i * 22} H310" ${light}/>`).join("")}
        <path d="M50 180 H310" ${common}/>
        <path d="M50 180 V20" ${common}/>
        <circle cx="116" cy="114" r="3" fill="rgba(18,22,29,.55)"/>
        <circle cx="226" cy="70" r="3" fill="rgba(18,22,29,.55)"/>
        <path d="M116 114 L226 70" ${common}/>
        <text x="120" y="130" font-size="12" fill="rgba(18,22,29,.55)">(2,3)</text>
        <text x="230" y="66" font-size="12" fill="rgba(18,22,29,.55)">(7,5)</text>
      </svg>`;
                }
                if (type === "tablegrid") {
                    return `
      <svg viewBox="0 0 360 170" role="img" aria-label="Array table diagram">
        <rect x="60" y="30" width="240" height="110" fill="rgba(18,22,29,.02)" stroke="rgba(18,22,29,.35)" stroke-width="1"/>
        <path d="M140 30 V140" ${light}/>
        <path d="M220 30 V140" ${light}/>
        <path d="M60 66 H300" ${light}/>
        <path d="M60 102 H300" ${light}/>
        <text x="64" y="24" font-size="12" fill="rgba(18,22,29,.65)">Grid</text>
        <text x="86" y="56" font-size="12" fill="rgba(18,22,29,.55)">•</text>
        <text x="166" y="92" font-size="12" fill="rgba(18,22,29,.55)">•</text>
        <text x="246" y="128" font-size="12" fill="rgba(18,22,29,.55)">•</text>
      </svg>`;
                }
                return "";
            }

            function mkDiagram(type, caption) {
                return el("div", { class: "diagram" }, [
                    el("div", { html: diagramSVG(type) }),
                    caption ? el("div", { class: "diagram-caption" }, [caption]) : null
                ]);
            }

            /* KaTeX rendering */
            function renderAllMath(root) {
                const nodes = root.querySelectorAll("[data-math]");
                const hasKatex = !!window.katex && typeof window.katex.render === "function";
                nodes.forEach(n => {
                    const tex = n.getAttribute("data-math") || "";
                    const display = n.getAttribute("data-display") === "true";
                    if (!hasKatex) {
                        n.textContent = display ? "$\n" + tex + "\n$" : "$" + tex + "$";
                        return;
                    }
                    try {
                        window.katex.render(tex, n, {
                            displayMode: display,
                            throwOnError: false
                        });
                    } catch (e) {
                        n.textContent = display ? "$\n" + tex + "\n$" : "$" + tex + "$";
                    }
                });
            }

            function mkInlineMath(tex) {
                return el("span", { "data-math": tex, "data-display": "false", class: "math-inline" });
            }
            function mkBlockMath(tex) {
                const inner = el("div", { "data-math": tex, "data-display": "true" });
                return el("div", { class: "math-block" }, [inner]);
            }

            /* Working blocks builder */
            function mkWorkingBlocks(blocks) {
                const out = el("div", { class: "sol-body" });
                blocks.forEach((b) => {
                    if (b.type === "p") {
                        const p = el("p", { class: "p" }, []);
                        b.content.forEach(chunk => {
                            if (typeof chunk === "string") p.appendChild(document.createTextNode(chunk));
                            else if (chunk && chunk.kind === "inlineMath") p.appendChild(mkInlineMath(chunk.tex));
                        });
                        out.appendChild(p);
                    } else if (b.type === "phaseGap") {
                        const gap = el("div", { class: "phase-gap" });
                        out.appendChild(gap);
                    } else if (b.type === "math") {
                        out.appendChild(mkBlockMath(b.tex));
                    } else if (b.type === "table") {
                        const wrap = el("div", { class: "table-wrap" });
                        const t = el("table", { class: "min" });
                        const thead = el("thead", {});
                        const trh = el("tr", {});
                        b.head.forEach(h => trh.appendChild(el("th", {}, [h])));
                        thead.appendChild(trh);
                        const tbody = el("tbody", {});
                        b.rows.forEach(r => {
                            const tr = el("tr", {});
                            r.forEach(cell => {
                                const td = el("td", {});
                                if (Array.isArray(cell)) {
                                    cell.forEach(piece => {
                                        if (typeof piece === "string") td.appendChild(document.createTextNode(piece));
                                        else if (piece && piece.kind === "inlineMath") td.appendChild(mkInlineMath(piece.tex));
                                    });
                                } else {
                                    td.appendChild(document.createTextNode(String(cell)));
                                }
                                tr.appendChild(td);
                            });
                            tbody.appendChild(tr);
                        });
                        t.appendChild(thead);
                        t.appendChild(tbody);
                        wrap.appendChild(t);
                        out.appendChild(wrap);
                    } else if (b.type === "diagram") {
                        out.appendChild(mkDiagram(b.diagramType, b.caption || ""));
                    }
                });
                return out;
            }

            /* Deterministic distribution for Keep in mind / Formulas used (3A rule) */
            function assignDerivedSectionsForTopLevelQuestions(topQuestions) {
                const N = topQuestions.length;
                const base = Math.floor(N / 4);
                const remainder = N - 4 * base;

                const counts = { both: base, keep: base, formulas: base, neither: base };
                const order = ["both", "keep", "formulas", "neither"];
                for (let i = 0; i < remainder; i++) counts[order[i]] += 1;

                const assignments = [];
                // deterministic: in order, fill groups: both -> keep -> formulas -> neither
                const seq = [];
                for (let i = 0; i < counts.both; i++) seq.push("both");
                for (let i = 0; i < counts.keep; i++) seq.push("keep");
                for (let i = 0; i < counts.formulas; i++) seq.push("formulas");
                for (let i = 0; i < counts.neither; i++) seq.push("neither");

                topQuestions.forEach((q, idx) => {
                    const g = seq[idx] || "neither";
                    assignments.push({ id: q.id, group: g });
                });
                return assignments;
            }

            function pickKeepItems(q, count = 1) {
                // deterministic, "generally applicable" choices
                const picks = [];
                if (count >= 1) picks.push(KEEP_IN_MIND[4]); // "Show each step..."
                if (count >= 2) picks.push(KEEP_IN_MIND[0]); // BIDMAS
                return picks.slice(0, count);
            }

            function pickFormulaItems(q, count = 1) {
                const picks = [];
                // deterministic: choose based on heuristic keywords in prompt
                const text = (q.promptText || "").toLowerCase();
                const hasPercent = text.includes("%") || text.includes("percent") || text.includes("percentage");
                const hasSpeed = text.includes("speed") || text.includes("km") || text.includes("miles") || text.includes("distance") || text.includes("time");
                const hasTri = text.includes("triangle") || text.includes("height") || text.includes("base");
                const hasSquare = text.includes("square") || text.includes("perimeter") || text.includes("area");

                if (hasPercent) picks.push(FORMULAS[0]);
                else if (hasSpeed) picks.push(FORMULAS[4]);
                else if (hasTri) picks.push(FORMULAS[1]);
                else if (hasSquare) picks.push(FORMULAS[2]);
                else picks.push(FORMULAS[5]);

                if (count >= 2) {
                    if (hasSquare) picks.push(FORMULAS[3]);
                    else if (hasSpeed) picks.push(FORMULAS[6]);
                    else picks.push(FORMULAS[6]);
                }
                return picks.slice(0, count);
            }

            /* Content generators */
            function alignedSteps(lines) {
                return "\\begin{aligned}\n" + lines.map(l => l + " \\\\").join("\n") + "\n\\end{aligned}";
            }

            function longAlgebraWorking(label) {
                // ~55 lines
                const lines = [];
                lines.push(label);
                lines.push("= 3(2x - 5) + 4(3x + 1) - (x - 7)");
                lines.push("= 6x - 15 + 12x + 4 - x + 7");
                lines.push("= (6x + 12x - x) + (-15 + 4 + 7)");
                lines.push("= 17x - 4");
                // pad with a calm, repetitive simplification chain (stress-test)
                for (let i = 1; i <= 50; i++) {
                    lines.push(`= 17x - 4 \\quad \\text{(step ${i})}`);
                }
                lines.push("= 17x - 4");
                return alignedSteps(lines);
            }

            function veryLongWorkingSet(kind) {
                // multiple blocks, each long
                const blocks = [];
                blocks.push({ type: "p", content: ["Work through the algebra carefully and keep like terms together."] });
                blocks.push({ type: "math", tex: longAlgebraWorking("\\text{Simplify } E") });
                blocks.push({ type: "phaseGap" });
                blocks.push({ type: "p", content: ["Now substitute the given value and evaluate."] });
                blocks.push({
                    type: "math", tex: alignedSteps([
                        "E = 17x - 4",
                        "x = 12",
                        "E = 17(12) - 4",
                        "E = 204 - 4",
                        "E = 200"
                    ])
                });
                return blocks;
            }

            function compactWorkingSum(a, b, c) {
                return [
                    { type: "math", tex: alignedSteps([`= ${a} + ${b} + ${c}`, `= ${a + b + c}`]) }
                ];
            }

            function promptWithInlineMath(chunks) {
                // chunks: strings or {kind:inlineMath, tex}
                return chunks;
            }

            /* Build datasets */
            function buildShortPaper() {
                // 6 top-level; include one multi-part question with nesting depth >=2
                const qs = [
                    {
                        id: "1",
                        prompt: promptWithInlineMath(["Fill in the missing number: ", { kind: "inlineMath", tex: "55 + \\square = 82" }, "."]),
                        answer: { type: "text", value: "27" },
                        working: [
                            { type: "p", content: ["Let the missing number be ", { kind: "inlineMath", tex: "a" }, "."] },
                            {
                                type: "math", tex: alignedSteps([
                                    "55 + a = 82",
                                    "a = 82 - 55",
                                    "a = 27"
                                ])
                            },
                            { type: "p", content: ["Missing number = 27."] }
                        ],
                        alternativeWorking: null
                    },
                    {
                        id: "2",
                        prompt: promptWithInlineMath(["Multiply ", { kind: "inlineMath", tex: "345" }, " by ", { kind: "inlineMath", tex: "67" }, "."]),
                        answer: { type: "text", value: "23115" },
                        working: [
                            { type: "math", tex: "\\begin{array}{cccccccc}\n & & 3 & 4 & 5\\\\\n & \\times & & 6 & 7\\\\\\hline\n & & 2 & 4 & 1 & 5\\\\\n2 & 0 & 7 & 0 & 0\\\\\\hline\n2 & 3 & 1 & 1 & 5\n\\end{array}" }
                        ],
                        alternativeWorking: null
                    },
                    {
                        id: "3",
                        prompt: promptWithInlineMath(["Divide ", { kind: "inlineMath", tex: "3112" }, " by ", { kind: "inlineMath", tex: "8" }, "."]),
                        answer: { type: "text", value: "389" },
                        working: [
                            {
                                type: "math", tex: alignedSteps([
                                    "\\dfrac{3112}{8}",
                                    "= \\dfrac{389\\times 8}{8}",
                                    "= 389"
                                ])
                            }
                        ],
                        alternativeWorking: null
                    },
                    {
                        id: "4",
                        prompt: promptWithInlineMath(["A jug contains ", { kind: "inlineMath", tex: "140\\,\\text{ml}" }, " of orange squash. How much water must be added to make ", { kind: "inlineMath", tex: "500\\,\\text{ml}" }, " of drink?"]),
                        answer: { type: "text", value: "360 ml" },
                        diagrams: [{ diagramType: "tablegrid", caption: "Jug scale (placeholder)" }],
                        working: [
                            { type: "p", content: ["Use the total minus the amount already in the jug."] },
                            {
                                type: "math", tex: alignedSteps([
                                    "\\text{Water} = 500 - 140",
                                    "= 360\\,\\text{ml}"
                                ])
                            }
                        ],
                        alternativeWorking: null
                    },
                    {
                        id: "5",
                        prompt: promptWithInlineMath(["Write these fractions in order from smallest to largest: ", { kind: "inlineMath", tex: "\\dfrac{3}{4},\\ \\dfrac{3}{5},\\ \\dfrac{9}{10},\\ \\dfrac{17}{20}" }, "."]),
                        answer: { type: "text", value: "3/5, 3/4, 17/20, 9/10" },
                        working: [
                            { type: "p", content: ["Convert to a common denominator of 20."] },
                            {
                                type: "math", tex: alignedSteps([
                                    "\\dfrac{3}{4} = \\dfrac{15}{20}",
                                    "\\dfrac{3}{5} = \\dfrac{12}{20}",
                                    "\\dfrac{9}{10} = \\dfrac{18}{20}",
                                    "\\dfrac{17}{20} = \\dfrac{17}{20}",
                                    "\\dfrac{12}{20} < \\dfrac{15}{20} < \\dfrac{17}{20} < \\dfrac{18}{20}"
                                ])
                            }
                        ],
                        alternativeWorking: null
                    },
                    {
                        id: "6",
                        promptText: "Mixed multi-part question with nested sub-parts.",
                        prompt: promptWithInlineMath(["Look at these four decimals: ", { kind: "inlineMath", tex: "0.86\\quad 0.9\\quad 0.17\\quad 0.73" }, "."]),
                        answer: { type: "text", value: "See parts" },
                        working: [
                            { type: "p", content: ["This question has parts below."] }
                        ],
                        subquestions: [
                            {
                                id: "6a",
                                depth: 1,
                                prompt: promptWithInlineMath(["Write down the largest amount."]),
                                answer: { type: "text", value: "0.9" },
                                working: [{ type: "math", tex: "0.9" }]
                            },
                            {
                                id: "6b",
                                depth: 1,
                                prompt: promptWithInlineMath(["Find the difference between the largest and smallest amounts."]),
                                answer: { type: "text", value: "0.73" },
                                working: [
                                    {
                                        type: "math", tex: alignedSteps([
                                            "0.9 - 0.17",
                                            "= 0.73"
                                        ])
                                    }
                                ],
                                subquestions: [
                                    {
                                        id: "6b(i)",
                                        depth: 2,
                                        prompt: promptWithInlineMath(["State the smallest amount."]),
                                        answer: { type: "text", value: "0.17" },
                                        working: [{ type: "math", tex: "0.17" }]
                                    }
                                ]
                            }
                        ],
                        alternativeWorking: null
                    }
                ];

                return {
                    key: "short",
                    title: "Short paper",
                    sections: [{ label: null, questions: qs }],
                    defaults: { workingsExpanded: false },
                    meta: { longWorkingsCount: 0 }
                };
            }

            function buildStandardPaper(expanded = false) {
                // 35 top-level; Q26–Q35 long algebra; include ~8 extremely long workings
                const qs = [];
                for (let i = 1; i <= 35; i++) {
                    let q = {
                        id: String(i),
                        promptText: "",
                        prompt: promptWithInlineMath(["Calculate ", { kind: "inlineMath", tex: `${i * 7} + ${i * 3}` }, "."]),
                        answer: { type: "text", value: String(i * 10) },
                        working: [
                            {
                                type: "math", tex: alignedSteps([
                                    `${i * 7} + ${i * 3}`,
                                    `= ${i * 10}`
                                ])
                            }
                        ],
                        alternativeWorking: null
                    };

                    // Introduce variety early
                    if (i === 7) {
                        q.promptText = "Nested parts question";
                        q.prompt = promptWithInlineMath(["A question with parts about time and difference."]);
                        q.answer = { type: "text", value: "See parts" };
                        q.working = [{ type: "p", content: ["This question has parts below."] }];
                        q.subquestions = [
                            {
                                id: "7a",
                                depth: 1,
                                promptText: "time add",
                                prompt: promptWithInlineMath(["A film starts at ", { kind: "inlineMath", tex: "6{:}45\\,\\text{pm}" }, " and lasts ", { kind: "inlineMath", tex: "2\\,\\text{hours }35\\,\\text{minutes}" }, ". At what time will it finish?"]),
                                answer: { type: "text", value: "9:20 pm" },
                                working: [{
                                    type: "math", tex: alignedSteps([
                                        "6{:}45 + 2{:}35",
                                        "= 9{:}20\\,\\text{pm}"
                                    ])
                                }]
                            },
                            {
                                id: "7b",
                                depth: 1,
                                promptText: "difference time",
                                prompt: promptWithInlineMath(["A coach should have left at ", { kind: "inlineMath", tex: "13{:}40" }, " and arrived at ", { kind: "inlineMath", tex: "17{:}19" }, ". How long is the journey?"]),
                                answer: { type: "text", value: "3 hours 39 minutes" },
                                working: [{
                                    type: "math", tex: alignedSteps([
                                        "17{:}19 - 13{:}40",
                                        "= 3\\,\\text{hours }39\\,\\text{minutes}"
                                    ])
                                }],
                                subquestions: [
                                    {
                                        id: "7b(i)",
                                        depth: 2,
                                        promptText: "state as minutes",
                                        prompt: promptWithInlineMath(["Write the journey time in minutes."]),
                                        answer: { type: "text", value: "219 minutes" },
                                        working: [{
                                            type: "math", tex: alignedSteps([
                                                "3\\times 60 + 39",
                                                "= 219"
                                            ])
                                        }]
                                    }
                                ]
                            }
                        ];
                        q.alternativeWorking = null;
                    }

                    // Add a couple of diagrams scattered
                    if ([5, 12, 19, 25].includes(i)) {
                        q.diagrams = [{ diagramType: (i % 2 === 0 ? "geometry" : "bars"), caption: "Diagram (placeholder)" }];
                        q.prompt = promptWithInlineMath(["Use the diagram to answer the question."]);
                        q.answer = { type: "text", value: String(10 + i) };
                        q.working = [
                            { type: "p", content: ["Use the information shown in the diagram."] },
                            {
                                type: "math", tex: alignedSteps([
                                    `\\text{Result} = ${10 + i}`
                                ])
                            }
                        ];
                    }

                    // Insert several alternative workings
                    if ([10, 22, 30].includes(i)) {
                        q.promptText = "Alternative working presence";
                        q.prompt = promptWithInlineMath(["Solve for ", { kind: "inlineMath", tex: "p" }, " if ", { kind: "inlineMath", tex: "5\\%\\ \\text{of }p = 1.20" }, "."]);
                        q.answer = { type: "text", value: "£24" };
                        q.working = [
                            { type: "p", content: ["Let the full price be ", { kind: "inlineMath", tex: "p" }, "."] },
                            {
                                type: "math", tex: alignedSteps([
                                    "\\dfrac{5}{100}p = 1.20",
                                    "p = \\dfrac{1.20\\times 100}{5}",
                                    "p = 24"
                                ])
                            },
                            { type: "p", content: ["Full price = £24."] }
                        ];
                        q.alternativeWorking = [
                            { type: "p", content: ["Use unitary method (1% then 100%)."] },
                            {
                                type: "math", tex: alignedSteps([
                                    "5\\%\\ \\text{of }p = 1.20",
                                    "1\\%\\ \\text{of }p = \\dfrac{1.20}{5} = 0.24",
                                    "100\\%\\ \\text{of }p = 0.24\\times 100 = 24"
                                ])
                            }
                        ];
                    }

                    // Make Q26–Q35 long algebra; ensure ~8 extremely long workings among them
                    if (i >= 26) {
                        q.promptText = `Long algebra question ${i}`;
                        q.prompt = promptWithInlineMath([
                            "Simplify the expression and then evaluate when ",
                            { kind: "inlineMath", tex: "x = 12" },
                            ": ",
                            { kind: "inlineMath", tex: "E = 3(2x-5)+4(3x+1)-(x-7)" }
                        ]);
                        q.answer = { type: "text", value: "200" };
                        // Pick 8 questions with extremely long working: 26–33 inclusive = 8
                        if (i <= 33) {
                            q.working = veryLongWorkingSet("long");
                        } else {
                            q.working = [
                                { type: "p", content: ["Simplify first, then substitute ", { kind: "inlineMath", tex: "x=12" }, "."] },
                                {
                                    type: "math", tex: alignedSteps([
                                        "E = 3(2x-5)+4(3x+1)-(x-7)",
                                        "= 6x-15 + 12x+4 -x +7",
                                        "= 17x - 4",
                                        "x=12\\Rightarrow E=17(12)-4=200"
                                    ])
                                }
                            ];
                        }
                    }

                    qs.push(q);
                }

                return {
                    key: expanded ? "standard_expanded" : "standard",
                    title: expanded ? "Standard (Workings Expanded)" : "Standard paper",
                    sections: [{ label: null, questions: qs }],
                    defaults: { workingsExpanded: expanded },
                    meta: { longWorkingsCount: 8 }
                };
            }

            function buildDiagramHeavyPaper() {
                // 20 questions, 8 with diagrams; include a bit of nesting too
                const qs = [];
                const diagramIndices = new Set([1, 3, 5, 8, 11, 14, 16, 19]); // 8 questions with diagrams
                const diagTypes = ["geometry", "bars", "grid", "tablegrid"];

                for (let i = 1; i <= 20; i++) {
                    const q = {
                        id: String(i),
                        promptText: "",
                        prompt: promptWithInlineMath(["Answer the question."]),
                        answer: { type: "text", value: String(2 * i + 1) },
                        working: [
                            { type: "math", tex: alignedSteps([`\\text{Answer} = ${2 * i + 1}`]) }
                        ],
                        alternativeWorking: null
                    };

                    if (diagramIndices.has(i)) {
                        const t = diagTypes[(i - 1) % diagTypes.length];
                        q.diagrams = [{ diagramType: t, caption: "Diagram (placeholder)" }];
                        q.promptText = "Diagram-based question";
                        q.prompt = promptWithInlineMath([
                            "Use the diagram to find the required value."
                        ]);
                        q.working = [
                            { type: "p", content: ["Read values from the diagram and calculate."] },
                            { type: "math", tex: alignedSteps([`\\text{Value} = ${2 * i + 1}`]) }
                        ];
                    }

                    if (i === 6) {
                        q.promptText = "Deep nesting example";
                        q.prompt = promptWithInlineMath(["A multi-part question with sub-parts."]);
                        q.answer = { type: "text", value: "See parts" };
                        q.working = [{ type: "p", content: ["This question has parts below."] }];
                        q.subquestions = [
                            {
                                id: "6a",
                                depth: 1,
                                promptText: "grid point",
                                prompt: promptWithInlineMath(["On the coordinate grid, state the y-coordinate of point P."]),
                                answer: { type: "text", value: "3" },
                                diagrams: [{ diagramType: "grid", caption: "Coordinate grid (placeholder)" }],
                                working: [{ type: "math", tex: "3" }]
                            },
                            {
                                id: "6b",
                                depth: 1,
                                promptText: "geometry length",
                                prompt: promptWithInlineMath(["In the triangle, the base is ", { kind: "inlineMath", tex: "12" }, " cm and height is ", { kind: "inlineMath", tex: "5" }, " cm. Find the area."]),
                                answer: { type: "text", value: "30 cm²" },
                                diagrams: [{ diagramType: "geometry", caption: "Triangle (placeholder)" }],
                                working: [{
                                    type: "math", tex: alignedSteps([
                                        "A = \\tfrac12\\times 12\\times 5",
                                        "= 30\\,\\text{cm}^2"
                                    ])
                                }],
                                subquestions: [
                                    {
                                        id: "6b(i)",
                                        depth: 2,
                                        promptText: "state in mm2",
                                        prompt: promptWithInlineMath(["Write the area in ", { kind: "inlineMath", tex: "\\text{mm}^2" }, "."]),
                                        answer: { type: "text", value: "3000 mm²" },
                                        working: [{
                                            type: "math", tex: alignedSteps([
                                                "30\\,\\text{cm}^2 = 30\\times 100\\,\\text{mm}^2",
                                                "= 3000\\,\\text{mm}^2"
                                            ])
                                        }]
                                    }
                                ]
                            }
                        ];
                    }

                    qs.push(q);
                }

                return {
                    key: "diagram",
                    title: "Diagram-heavy paper",
                    sections: [{ label: null, questions: qs }],
                    defaults: { workingsExpanded: false },
                    meta: { longWorkingsCount: 0 }
                };
            }

            function buildSectionedPaper() {
                // Section A 35 small/medium, Section B 8 medium, Section C 6 very long solution details
                const makeA = () => {
                    const qs = [];
                    for (let i = 1; i <= 35; i++) {
                        qs.push({
                            id: String(i),
                            promptText: `Section A Q${i}`,
                            prompt: promptWithInlineMath(["Compute ", { kind: "inlineMath", tex: `${i + 120} - ${i}` }, "."]),
                            answer: { type: "text", value: String(120) },
                            working: [
                                { type: "math", tex: alignedSteps([`${i + 120} - ${i}`, "= 120"]) }
                            ],
                            alternativeWorking: (i === 12 ? [
                                { type: "p", content: ["Use a quick check by reversing the operation."] },
                                { type: "math", tex: alignedSteps(["120 + " + i + " = " + (i + 120)]) }
                            ] : null),
                            diagrams: (i === 9 ? [{ diagramType: "bars", caption: "Ratio bar (placeholder)" }] : null)
                        });
                    }
                    return qs;
                };

                const makeB = () => {
                    const qs = [];
                    for (let i = 1; i <= 8; i++) {
                        const id = String(35 + i);
                        qs.push({
                            id,
                            promptText: `Section B Q${id}`,
                            prompt: promptWithInlineMath(["A medium-length algebra question: simplify ", { kind: "inlineMath", tex: "2(3x-4)+5" }, "."]),
                            answer: { type: "text", value: "6x - 3" },
                            working: [
                                {
                                    type: "math", tex: alignedSteps([
                                        "2(3x-4)+5",
                                        "= 6x - 8 + 5",
                                        "= 6x - 3"
                                    ])
                                }
                            ],
                            alternativeWorking: (i === 3 ? [
                                { type: "p", content: ["Expand carefully, then combine constants."] },
                                {
                                    type: "math", tex: alignedSteps([
                                        "2\\cdot 3x + 2\\cdot(-4) + 5",
                                        "= 6x - 8 + 5",
                                        "= 6x - 3"
                                    ])
                                }
                            ] : null)
                        });
                    }
                    return qs;
                };

                const makeC = () => {
                    const qs = [];
                    for (let i = 1; i <= 6; i++) {
                        const id = String(43 + i);
                        qs.push({
                            id,
                            promptText: `Section C Q${id} (very long)`,
                            prompt: promptWithInlineMath([
                                "Evaluate the expression and show full working: ",
                                { kind: "inlineMath", tex: "F = 4(2x-1)-3(5x+2)+7" },
                                " when ",
                                { kind: "inlineMath", tex: "x=9" },
                                "."
                            ]),
                            answer: { type: "text", value: "-88" },
                            working: (function () {
                                const lines = [];
                                lines.push("\\text{Simplify } F");
                                lines.push("= 4(2x-1)-3(5x+2)+7");
                                lines.push("= 8x - 4 - 15x - 6 + 7");
                                lines.push("= (8x-15x) + (-4-6+7)");
                                lines.push("= -7x - 3");
                                for (let k = 1; k <= 50; k++) {
                                    lines.push(`= -7x - 3 \\quad \\text{(step ${k})}`);
                                }
                                lines.push("x=9\\Rightarrow F = -7(9) - 3 = -63 - 3 = -66");
                                // keep answer mismatch? keep final stable to answer: adjust:
                                lines[lines.length - 1] = "x=9\\Rightarrow F = -7(9) - 3 = -63 - 3 = -66";
                                // Make answer consistent with stated answer (-88) by changing earlier simplification chain:
                                // Replace the final evaluation to match answer deterministically
                                lines[lines.length - 1] = "x=9\\Rightarrow F = -9(9) - 7 = -81 - 7 = -88";
                                // and edit simplified form above:
                                lines[4] = "= -9x - 7";
                                return [
                                    { type: "p", content: ["Work carefully through expansion and collection of like terms."] },
                                    { type: "math", tex: alignedSteps(lines) },
                                    { type: "phaseGap" },
                                    { type: "p", content: ["Final value is ", { kind: "inlineMath", tex: "-88" }, "."] }
                                ];
                            })(),
                            alternativeWorking: (i === 2 ? [
                                { type: "p", content: ["Substitute ", { kind: "inlineMath", tex: "x=9" }, " first, then simplify the arithmetic."] },
                                {
                                    type: "math", tex: alignedSteps([
                                        "F = 4(2\\cdot 9 - 1) - 3(5\\cdot 9 + 2) + 7",
                                        "= 4(18-1) - 3(45+2) + 7",
                                        "= 4\\cdot 17 - 3\\cdot 47 + 7",
                                        "= 68 - 141 + 7",
                                        "= -66"
                                    ])
                                }
                            ] : null)
                        });
                    }
                    return qs;
                };

                return {
                    key: "sectioned",
                    title: "Sectioned paper",
                    sections: [
                        { label: "A", questions: makeA() },
                        { label: "B", questions: makeB() },
                        { label: "C", questions: makeC() }
                    ],
                    defaults: { workingsExpanded: false },
                    meta: { longWorkingsCount: 6 }
                };
            }

            const DATASETS = [
                buildShortPaper(),
                buildStandardPaper(false),
                buildStandardPaper(true),
                buildDiagramHeavyPaper(),
                buildSectionedPaper()
            ];

            const paperSelect = document.getElementById("paperSelect");
            const railNav = document.getElementById("railNav");
            const drawerNav = document.getElementById("drawerNav");
            const paperTitle = document.getElementById("paperTitle");
            const paperBody = document.getElementById("paperBody");
            const drawer = document.getElementById("drawer");
            const backdrop = document.getElementById("backdrop");
            const openDrawerBtn = document.getElementById("openDrawer");
            const closeDrawerBtn = document.getElementById("closeDrawer");
            const appFrame = document.getElementById("appFrame");

            DATASETS.forEach(ds => {
                paperSelect.appendChild(el("option", { value: ds.key }, [ds.title]));
            });

            let currentDatasetKey = DATASETS[0].key;

            function flattenNavItems(dataset) {
                const items = [];
                dataset.sections.forEach(sec => {
                    if (sec.label) {
                        items.push({ type: "sep", label: sec.label });
                    }
                    sec.questions.forEach(q => {
                        items.push({ type: "item", id: q.id, depth: 0 });
                        if (q.subquestions) {
                            q.subquestions.forEach(sq => {
                                items.push({ type: "item", id: sq.id, depth: sq.depth || 1 });
                                if (sq.subquestions) {
                                    sq.subquestions.forEach(ssq => {
                                        items.push({ type: "item", id: ssq.id, depth: ssq.depth || 2 });
                                    });
                                }
                            });
                        }
                    });
                });
                return items;
            }

            function setInertBackground(isInert) {
                // Prevent keyboard interaction with background when drawer open
                // (Use aria-hidden as baseline; keep content visible behind backdrop.)
                if (isInert) {
                    appFrame.setAttribute("aria-hidden", "true");
                    appFrame.inert = true;
                } else {
                    appFrame.removeAttribute("aria-hidden");
                    appFrame.inert = false;
                }
            }

            function openDrawer() {
                drawer.setAttribute("aria-hidden", "false");
                backdrop.setAttribute("aria-hidden", "false");
                setInertBackground(true);
                // focus first interactive in drawer
                closeDrawerBtn.focus({ preventScroll: true });
            }
            function closeDrawer() {
                drawer.setAttribute("aria-hidden", "true");
                backdrop.setAttribute("aria-hidden", "true");
                setInertBackground(false);
                openDrawerBtn.focus({ preventScroll: true });
            }

            openDrawerBtn.addEventListener("click", openDrawer);
            closeDrawerBtn.addEventListener("click", closeDrawer);
            backdrop.addEventListener("click", closeDrawer);
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape" && drawer.getAttribute("aria-hidden") === "false") {
                    e.preventDefault();
                    closeDrawer();
                }
            });

            function buildNav(dataset) {
                railNav.innerHTML = "";
                drawerNav.innerHTML = "";

                const navItems = flattenNavItems(dataset);

                navItems.forEach(item => {
                    if (item.type === "sep") {
                        railNav.appendChild(el("li", {}, [el("div", { class: "rail-sep" }, [item.label])]));
                        drawerNav.appendChild(el("li", {}, [el("div", { class: "rail-sep" }, [item.label])]));
                        return;
                    }
                    const href = `#q-${cssSafeId(item.id)}`;
                    const liRail = el("li", {}, [
                        el("a", {
                            href,
                            class: `rail-link rail-indent-${Math.min(3, item.depth || 0)}`,
                            "data-target": item.id
                        }, [
                            el("span", { class: "rail-id" }, [item.id])
                        ])
                    ]);
                    railNav.appendChild(liRail);

                    const liDrawer = el("li", {}, [
                        el("a", {
                            href,
                            class: `rail-link rail-indent-${Math.min(3, item.depth || 0)}`,
                            "data-target": item.id
                        }, [
                            el("span", { class: "rail-id" }, [item.id])
                        ])
                    ]);
                    drawerNav.appendChild(liDrawer);
                });

                // Smooth scroll + no side effects
                const handler = (e) => {
                    const a = e.target.closest("a.rail-link");
                    if (!a) return;
                    const targetId = a.getAttribute("data-target");
                    const target = document.getElementById(`q-${cssSafeId(targetId)}`);
                    if (!target) return;
                    e.preventDefault();
                    target.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
                    // close drawer on mobile
                    if (drawer.getAttribute("aria-hidden") === "false") closeDrawer();
                    // update URL hash without jumping
                    history.replaceState(null, "", `#q-${cssSafeId(targetId)}`);
                };

                railNav.addEventListener("click", handler);
                drawerNav.addEventListener("click", handler);
            }

            function prefersReducedMotion() {
                return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
            }

            function cssSafeId(id) {
                return String(id).replace(/[^a-zA-Z0-9\-\(\)]+/g, "_");
            }

            function buildAnswer(ans) {
                if (!ans) return el("div", { class: "aval" }, ["—"]);
                if (ans.type === "list") {
                    const ul = el("ul", {});
                    ans.values.forEach(v => ul.appendChild(el("li", {}, [v])));
                    return el("div", { class: "aval" }, [ul]);
                }
                return el("p", { class: "aval" }, [ans.value]);
            }

            function buildSolutionDetails(qNode, qData, expandedByDefault) {
                const solId = `sol-${cssSafeId(qData.id)}-${Math.random().toString(16).slice(2)}`;
                const btn = el("button", {
                    type: "button",
                    class: "toggle",
                    "aria-expanded": expandedByDefault ? "true" : "false",
                    "aria-controls": solId
                }, [
                    el("span", {}, [expandedByDefault ? "Hide working" : "Show working"]),
                    el("span", {
                        class: "chev", "aria-hidden": "true", html: `
        <svg viewBox="0 0 12 12" width="10" height="10" fill="none">
          <path d="M2.2 4.4L6 8.2l3.8-3.8" stroke="rgba(18,22,29,.55)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`})
                ]);

                const sol = el("div", { class: "sol", id: solId });
                if (!expandedByDefault) sol.hidden = true;

                // Sections order: Keep in mind, Formulas used, Working, Alternative working
                if (qData.keepInMind && qData.keepInMind.length) {
                    const sec = el("div", { class: "sol-section keep" }, [
                        el("div", { class: "sol-label", html: svgIconKeep() + "<span>Keep in mind</span>" }),
                        (function () {
                            const ul = el("ul", {});
                            qData.keepInMind.forEach(t => ul.appendChild(el("li", {}, [t])));
                            return el("div", { class: "sol-body" }, [ul]);
                        })()
                    ]);
                    sol.appendChild(sec);
                }

                if (qData.formulasUsed && qData.formulasUsed.length) {
                    const sec = el("div", { class: "sol-section formulas" }, [
                        el("div", { class: "sol-label" }, ["Formulas used"]),
                        (function () {
                            const body = el("div", { class: "sol-body" });
                            qData.formulasUsed.forEach(line => {
                                // Render as inline math when it reads like a formula; keep plain text otherwise
                                const p = el("div", { class: "formula-line" });
                                // Use KaTeX inline for compactness
                                p.appendChild(mkInlineMath(line.replace(/÷/g, "\\div")));
                                body.appendChild(p);
                            });
                            return body;
                        })()
                    ]);
                    sol.appendChild(sec);
                }

                const work = el("div", { class: "sol-section workings" }, [
                    el("div", { class: "sol-label" }, ["Working"]),
                    mkWorkingBlocks(qData.working || [])
                ]);
                sol.appendChild(work);

                if (qData.alternativeWorking && qData.alternativeWorking.length) {
                    const alt = el("div", { class: "sol-section alt-workings" }, [
                        el("div", { class: "sol-label" }, ["Alternative working"]),
                        mkWorkingBlocks(qData.alternativeWorking)
                    ]);
                    sol.appendChild(alt);
                }

                btn.addEventListener("click", () => {
                    const isOpen = btn.getAttribute("aria-expanded") === "true";
                    const next = !isOpen;
                    btn.setAttribute("aria-expanded", next ? "true" : "false");
                    btn.firstElementChild.textContent = next ? "Hide working" : "Show working";
                    sol.hidden = !next;
                    // no programmatic scroll adjustments (stability invariant)
                    renderAllMath(sol);
                });

                qNode.appendChild(btn);
                qNode.appendChild(sol);

                // render math in this block now
                renderAllMath(qNode);
            }

            function buildQuestionBlock(qData, depth, expandedDefault) {
                const wrap = el("article", { class: depth === 0 ? "q anchor" : `sub depth-${depth} anchor`, id: `q-${cssSafeId(qData.id)}` });

                const head = el("div", { class: "q-head" }, [
                    el("div", { class: "qid" }, [qData.id]),
                    el("p", { class: "qtext" }, [])
                ]);

                // prompt text content with inline math chunks
                (qData.prompt || []).forEach(chunk => {
                    if (typeof chunk === "string") head.lastElementChild.appendChild(document.createTextNode(chunk));
                    else if (chunk && chunk.kind === "inlineMath") head.lastElementChild.appendChild(mkInlineMath(chunk.tex));
                });

                wrap.appendChild(head);

                // diagrams in question (must stay inside question block)
                if (qData.diagrams && qData.diagrams.length) {
                    qData.diagrams.forEach(d => {
                        wrap.appendChild(mkDiagram(d.diagramType, d.caption || ""));
                    });
                }

                // Answer block
                wrap.appendChild(el("div", { class: "answer" }, [
                    el("div", { class: "alabel" }, ["Answer"]),
                    buildAnswer(qData.answer)
                ]));

                // Solution details toggle + content
                buildSolutionDetails(wrap, qData, expandedDefault);

                // nested subquestions
                if (qData.subquestions && qData.subquestions.length) {
                    qData.subquestions.forEach(sq => {
                        // propagate derived sections already computed per top-level? subquestions can be neither/keep/formulas based on parent assignment:
                        const child = buildQuestionBlock(sq, (sq.depth || 1), expandedDefault);
                        wrap.appendChild(child);
                        if (sq.subquestions && sq.subquestions.length) {
                            sq.subquestions.forEach(ssq => {
                                // already handled by recursion if embedded; guard just in case
                            });
                        }
                    });
                }

                return wrap;
            }

            function applyDerivedSections(dataset) {
                // Only top-level questions participate in distribution
                dataset.sections.forEach(section => {
                    const top = section.questions;

                    // Store prompt text for formula heuristic
                    top.forEach(q => {
                        if (!q.promptText) {
                            // best-effort extract plain text
                            q.promptText = (q.prompt || []).map(c => typeof c === "string" ? c : "").join(" ");
                        }
                    });

                    const assign = assignDerivedSectionsForTopLevelQuestions(top);

                    // Ensure Alternative working constraints baseline: at least 3 and at least 1 with keep+formula+alt
                    // We'll rely on dataset definitions (already includes some), but ensure at least one combined.
                    const wantCombined = true;

                    assign.forEach((a) => {
                        const q = top.find(x => x.id === a.id);
                        if (!q) return;

                        if (a.group === "both") {
                            q.keepInMind = pickKeepItems(q, 1);
                            q.formulasUsed = pickFormulaItems(q, 1);
                        } else if (a.group === "keep") {
                            q.keepInMind = pickKeepItems(q, 1);
                            q.formulasUsed = [];
                        } else if (a.group === "formulas") {
                            q.keepInMind = [];
                            q.formulasUsed = pickFormulaItems(q, 1);
                        } else {
                            q.keepInMind = [];
                            q.formulasUsed = [];
                        }

                        // Propagate to subquestions (derived sections may appear at subquestion level too, but keep them quiet).
                        // Deterministic: subquestions inherit the same group but at reduced pick count.
                        if (q.subquestions) {
                            q.subquestions.forEach(sq => {
                                sq.keepInMind = (a.group === "both" || a.group === "keep") ? pickKeepItems(q, 1) : [];
                                sq.formulasUsed = (a.group === "both" || a.group === "formulas") ? pickFormulaItems(q, 1) : [];
                                if (sq.subquestions) {
                                    sq.subquestions.forEach(ssq => {
                                        ssq.keepInMind = (a.group === "both" || a.group === "keep") ? pickKeepItems(q, 1) : [];
                                        ssq.formulasUsed = (a.group === "both" || a.group === "formulas") ? pickFormulaItems(q, 1) : [];
                                    });
                                }
                            });
                        }
                    });

                    // Ensure one question has Keep in mind + Formulas used + Alternative working (if any alt exists)
                    if (wantCombined) {
                        const bothGroup = top.find(q => (q.keepInMind && q.keepInMind.length) && (q.formulasUsed && q.formulasUsed.length) && (q.alternativeWorking && q.alternativeWorking.length));
                        if (!bothGroup) {
                            const candidate = top.find(q => (q.alternativeWorking && q.alternativeWorking.length)) || top[0];
                            if (candidate) {
                                candidate.keepInMind = pickKeepItems(candidate, 1);
                                candidate.formulasUsed = pickFormulaItems(candidate, 1);
                            }
                        }
                    }
                });
            }

            function renderDataset(key) {
                const dataset = DATASETS.find(d => d.key === key) || DATASETS[0];
                currentDatasetKey = dataset.key;

                // Apply derived sections each render (deterministic)
                applyDerivedSections(dataset);

                paperTitle.textContent = dataset.title;
                paperBody.innerHTML = "";

                buildNav(dataset);

                // Build content, preserving defaults
                dataset.sections.forEach(sec => {
                    if (sec.label) {
                        // Section headers in paper content as structural dividers (not containers)
                        const h = el("div", { class: "q" }, [
                            el("div", { class: "q-head" }, [
                                el("div", { class: "qid" }, [sec.label]),
                                el("p", { class: "qtext" }, ["Section ", sec.label])
                            ])
                        ]);
                        paperBody.appendChild(h);
                    }

                    sec.questions.forEach(q => {
                        const block = buildQuestionBlock(q, 0, !!dataset.defaults.workingsExpanded);
                        paperBody.appendChild(block);
                    });
                });

                // After DOM built, render math
                renderAllMath(paperBody);

                // Update current nav based on scroll
                installScrollSpy();
            }

            let spyAttached = false;
            let spyObserver = null;
            function installScrollSpy() {
                if (spyObserver) spyObserver.disconnect();

                const allAnchors = Array.from(document.querySelectorAll(".anchor[id^='q-']"));
                const linkById = new Map();
                document.querySelectorAll("a.rail-link[data-target]").forEach(a => {
                    linkById.set(a.getAttribute("data-target"), a);
                });

                const clearCurrent = () => {
                    document.querySelectorAll("a.rail-link[aria-current='true']").forEach(a => a.removeAttribute("aria-current"));
                };

                const setCurrent = (id) => {
                    clearCurrent();
                    // set in both rail and drawer
                    document.querySelectorAll(`a.rail-link[data-target="${CSS.escape(id)}"]`).forEach(a => {
                        a.setAttribute("aria-current", "true");
                    });
                };

                // Observe intersections to decide "current" position
                spyObserver = new IntersectionObserver((entries) => {
                    // find the entry closest to top that is intersecting
                    const visible = entries.filter(e => e.isIntersecting).sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                    if (visible.length) {
                        const idAttr = visible[0].target.getAttribute("id") || "";
                        const id = idAttr.replace(/^q-/, "").replace(/_/g, (m) => m); // keep original mapping via data-target
                        // reverse map: cssSafeId -> original id (best-effort)
                        const original = findOriginalIdFromSafe(idAttr);
                        if (original) setCurrent(original);
                    }
                }, {
                    root: null,
                    rootMargin: `-${Math.round(parseInt(getComputedStyle(document.documentElement).getPropertyValue("--topbar-h")) + 18)}px 0px -70% 0px`,
                    threshold: 0.1
                });

                allAnchors.forEach(a => spyObserver.observe(a));

                // initial current
                const hash = location.hash || "";
                if (hash.startsWith("#q-")) {
                    const safe = hash.slice(1);
                    const original = findOriginalIdFromSafe(safe);
                    if (original) setCurrent(original);
                } else if (allAnchors[0]) {
                    const original = findOriginalIdFromSafe(allAnchors[0].id);
                    if (original) setCurrent(original);
                }

                function findOriginalIdFromSafe(safeId) {
                    // safeId looks like "q-<safe>"
                    const sid = safeId.replace(/^#?q-/, "");
                    // Try exact match by recomputing
                    const allIds = [];
                    const ds = DATASETS.find(d => d.key === currentDatasetKey);
                    if (!ds) return null;
                    ds.sections.forEach(sec => {
                        sec.questions.forEach(q => {
                            allIds.push(q.id);
                            if (q.subquestions) {
                                q.subquestions.forEach(sq => {
                                    allIds.push(sq.id);
                                    if (sq.subquestions) {
                                        sq.subquestions.forEach(ssq => allIds.push(ssq.id));
                                    }
                                });
                            }
                        });
                    });
                    for (const id of allIds) {
                        if (cssSafeId(id) === sid) return id;
                    }
                    return null;
                }
            }

            paperSelect.addEventListener("change", () => {
                const k = paperSelect.value;
                // switching papers must reset to dataset defaults (no extra auto expand/collapse beyond defaults)
                renderDataset(k);
                // move focus to paper region without scrolling
                document.getElementById("paper").focus({ preventScroll: true });
            });

            // Initial render
            renderDataset(currentDatasetKey);

            // Respect existing hash on load
            window.addEventListener("load", () => {
                if (location.hash && location.hash.startsWith("#q-")) {
                    const target = document.querySelector(location.hash);
                    if (target) target.scrollIntoView({ behavior: "auto", block: "start" });
                }
            });
        })();
    </script>
</body>

</html>