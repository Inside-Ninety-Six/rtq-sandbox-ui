<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"ABC","indexWithinVariant":"120","totalWithinVariant":"320","hueFamily":"cyan","intensityMode":"deep_theme","timestamp":"2026-01-07T15:01:19.804Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;ABC&quot;,&quot;indexWithinVariant&quot;:&quot;120&quot;,&quot;totalWithinVariant&quot;:&quot;320&quot;,&quot;hueFamily&quot;:&quot;cyan&quot;,&quot;intensityMode&quot;:&quot;deep_theme&quot;,&quot;timestamp&quot;:&quot;2026-01-07T15:01:19.804Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer (Stage 6 Baseline)</title>

    <!-- Tailwind CSS (via CDN for prototyping) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS & JS (No SRI, per Stage 6.0.7b) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Markdown-it (No SRI) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <style>
        /* 
         * STAGE 6 ADD-ON: COLORLAB C (DEEP THEME) + COLORLAB B (CYAN) 
         * Light Mode Only. OKLCH color space.
         * Hue: 230 (Cyan/Blue range)
         */
        :root {
            /* Deep Theme Surfaces (Chromatic) */
            --color-page-bg: oklch(0.94 0.08 230);
            --color-frame-bg: oklch(0.92 0.10 230);
            --color-paper-bg: oklch(0.98 0.06 230);
            
            /* Text (Neutral-ish) */
            --color-text-primary: oklch(0.20 0.01 230);
            --color-text-secondary: oklch(0.35 0.02 230);
            --color-text-tertiary: oklch(0.50 0.02 230); /* For Nav/Subtle */

            /* Accent (Cyan - Links, Focus, Toggles) */
            --color-accent: oklch(0.55 0.20 230);
            
            /* Structural */
            --color-border-hairline: oklch(0.85 0.03 230);
            --color-wash-solution: oklch(0.95 0.07 230); /* Solution Details Wash */
            --color-wash-keep-in-mind: oklch(0.95 0.07 230); 
            
            /* Focus Ring */
            --color-focus-ring: oklch(0.55 0.20 230);
        }

        body {
            background-color: var(--color-page-bg);
            color: var(--color-text-primary);
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
        }

        /* 
         * STAGE 3 LAYOUT GRAMMAR 
         */
        .document-frame-shell {
            background-color: var(--color-frame-bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        @media (min-width: 1024px) {
            .document-frame-shell {
                flex-direction: row;
                max-width: 1280px; /* max-w-screen-xl */
                margin: 0 auto;
                border-left: 1px solid var(--color-border-hairline);
                border-right: 1px solid var(--color-border-hairline);
            }
            
            .nav-column {
                width: 260px;
                flex-shrink: 0;
                position: sticky;
                top: 0;
                height: 100vh;
                overflow-y: auto;
                border-right: 1px solid var(--color-border-hairline);
            }

            .paper-column {
                flex-grow: 1;
                /* No independent scroll; uses window scroll */
            }
        }

        /* Paper Surface */
        .paper-surface {
            background-color: var(--color-paper-bg);
            padding: 2rem 1.5rem; /* responsive padding handled via utility if needed */
            min-height: 100%;
        }
        @media (min-width: 768px) {
            .paper-surface { padding: 3rem 4rem; }
        }

        /* 
         * KATEX & MATH RULES (LOCKED)
         */
        /* Containment Invariant */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 4px; /* Space for scrollbar */
        }
        
        /* Inline math - transparent bg */
        .katex {
            background-color: transparent !important;
        }

        /* Block math underlay (optional Stage 3 cue) */
        .katex-display > .katex {
            background-color: transparent; /* Baseline is transparent, can add subtle wash if strictly needed, but Stage 5.8 says minimal */
        }

        /* 
         * SCROLLBAR HIDING (Nav)
         */
        .hide-scrollbar {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .hide-scrollbar::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        /* 
         * TYPOGRAPHY & HIERARCHY
         */
        .type-question-id {
            color: var(--color-text-secondary);
            font-weight: 500;
            margin-right: 0.5em;
        }
        .type-question-body p {
            margin-bottom: 0.75em;
            line-height: 1.6;
        }
        .type-question-body p:last-child {
            margin-bottom: 0;
        }
        .type-label {
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--color-text-secondary);
            margin-bottom: 0.25rem;
            display: block;
        }
        
        /* Solution Details Subsections */
        .solution-details-region {
            /* Stage 3: Optional Wash */
            background-color: var(--color-wash-solution);
            border-radius: 4px; /* Subtle corner radius for the region, not card-like */
            margin-top: 1rem;
            padding: 1.25rem;
        }
        
        /* Nav Hierarchy */
        .nav-item {
            display: block;
            padding: 0.35rem 1rem;
            color: var(--color-text-secondary);
            text-decoration: none;
            font-size: 0.925rem;
            border-left: 3px solid transparent;
            transition: color 0.1s, border-color 0.1s;
        }
        .nav-item:hover {
            color: var(--color-accent);
            background-color: rgba(0,0,0,0.02); /* Very subtle hover interaction */
        }
        .nav-item.active {
            color: var(--color-text-primary);
            font-weight: 600;
            border-left-color: var(--color-accent);
        }
        .nav-section-label {
            padding: 1.5rem 1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--color-text-tertiary);
        }
        
        /* Controls */
        .btn-disclosure {
            appearance: none;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--color-accent);
            font-weight: 500;
            font-size: 0.9rem;
            padding: 0;
            display: inline-flex;
            align-items: center;
            gap: 0.25em;
        }
        .btn-disclosure:hover {
            text-decoration: underline;
        }
        
        /* Focus styles */
        *:focus-visible {
            outline: 2px solid var(--color-focus-ring);
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* 
         * TABLES (Minimal)
         */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
            font-size: 0.95em;
        }
        th, td {
            border: 1px solid var(--color-border-hairline);
            padding: 0.5em 0.75em;
            text-align: left;
        }
        th {
            font-weight: 600;
            background-color: rgba(0,0,0,0.02);
        }
        
        /* Mobile Drawer Transitions */
        .drawer-overlay {
            transition: opacity 0.2s ease-out;
        }
        .drawer-content {
            transition: transform 0.2s ease-out;
        }
    </style>
</head>
<body>

    <!-- STAGE 3: DocumentFrameShell -->
    <div id="app" class="document-frame-shell">
        <!-- Generated Content Will Be Injected Here -->
    </div>

    <!-- MAIN SCRIPT -->
    <script>
        // --- STAGE 0: CONSTANTS ---
        // Canonical Paths
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // --- STAGE 6 ADD-ON: MARKDOWN-IT CONFIG (AUTHORITATIVE) ---
        const md = window.markdownit ? window.markdownit({
            html: true, // Inline SVG passthrough
            linkify: true,
            breaks: false // Critical: prevent <br> in math
        }) : null;

        if (md) {
            // Disable escape rule to preserve TeX backslashes
            md.inline.ruler.disable(['escape']);
        }

        // --- STATE & UTILS ---
        const state = {
            papers: [],
            activePaperKey: null,
            expandedNodes: new Set(),
            isDrawerOpen: false,
            payloadLoaded: false,
            error: false
        };

        // --- DOM ELEMENTS ---
        const app = document.getElementById('app');

        // --- INITIALIZATION ---
        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Fetch failed");
                const payload = await response.json();
                
                state.papers = payload.papers || [];
                state.payloadLoaded = true;

                if (state.papers.length > 0) {
                    // Load first paper by default
                    selectPaper(state.papers[0].key);
                } else {
                    renderError("NO PAPERS IN PAYLOAD");
                }
            } catch (e) {
                console.error(e);
                renderError("PAPERS PAYLOAD MISSING");
            }
        }

        function renderError(msg) {
            app.innerHTML = `
                <div class="flex items-center justify-center w-full h-screen text-lg font-bold text-[var(--color-text-secondary)]">
                    ${msg}
                </div>
            `;
        }

        function selectPaper(key) {
            const paper = state.papers.find(p => p.key === key);
            if (!paper) return;

            state.activePaperKey = key;
            
            // Set Defaults
            state.expandedNodes.clear();
            const expandAll = paper.defaults?.expandedAll !== false; // Default true unless explicitly false

            if (expandAll) {
                // We handle "expanded by default" logic in the render check usually, 
                // but to track manual toggles, we can treat "expandedNodes" as overrides 
                // OR treat state.expandedNodes as the source of truth.
                // Simplified: Let's assume state.expandedNodes stores IDs that are OPEN.
                // If default is open, we pre-fill. 
                // HOWEVER, recursing the whole tree to pre-fill is expensive. 
                // STRATEGY: state.expandedNodes tracks explicit state. 
                // But Stage 3 says "expanded by default when present".
                // We will implement a helper `isExpanded(id)` that defaults to true.
            }

            renderApp();
            
            // Post-render: Scroll to top
            window.scrollTo(0, 0);
        }

        function isExpanded(nodeId) {
            // If explicit state tracking is needed for toggling:
            // We use a Set. If the ID is in the Set, it is expanded.
            // If default is expanded, we initialize the Set with ALL IDs? No.
            // Better: Set tracks *collapsed* items if default is expanded?
            // Let's stick to: Set tracks EXPANDED items. 
            // If paper default is expanded, we assume expanded unless in "collapsedSet".
            // Implementation: We'll use a `collapsedNodes` Set if default=true, `expandedNodes` Set if default=false.
            
            const paper = state.papers.find(p => p.key === state.activePaperKey);
            const defaultsExpanded = paper.defaults?.expandedAll !== false;

            if (defaultsExpanded) {
                return !state.expandedNodes.has(nodeId); // Here expandedNodes acts as "collapsedNodes" for storage
            } else {
                return state.expandedNodes.has(nodeId);
            }
        }

        function toggleNode(nodeId) {
            const paper = state.papers.find(p => p.key === state.activePaperKey);
            const defaultsExpanded = paper.defaults?.expandedAll !== false;

            if (defaultsExpanded) {
                // If currently "expanded" (not in set), add to set to collapse.
                // If currently "collapsed" (in set), remove from set to expand.
                if (state.expandedNodes.has(nodeId)) {
                    state.expandedNodes.delete(nodeId);
                } else {
                    state.expandedNodes.add(nodeId);
                }
            } else {
                // Default collapsed
                if (state.expandedNodes.has(nodeId)) {
                    state.expandedNodes.delete(nodeId);
                } else {
                    state.expandedNodes.add(nodeId);
                }
            }
            renderApp(true); // Preserve scroll roughly
        }

        // --- RENDERING CORE ---

        function renderApp(preserveScroll = false) {
            if (!state.activePaperKey) return;
            const paper = state.papers.find(p => p.key === state.activePaperKey);

            // Structure:
            // Mobile: Header (Top Controls) -> Drawer
            // Desktop: Nav Column | Paper Column (with Top Controls inside? No, prompt says "Top controls region... aligned to frame")
            
            // To keep "DocumentFrameShell" containing Nav and Paper, Top Controls typically sit above or within.
            // Design Brief: "Top control area... must remain visually aligned with the same DocumentFrameShell".
            // We will put Top Controls inside the Shell on mobile, or just above content.
            // On desktop, the Shell has 2 columns. The Paper Selector is "Top controls region".
            
            // Desktop Layout:
            // [ Nav Rail ] [ Top Controls + Paper Content ]
            
            const scrollPos = window.scrollY;

            const contentHTML = `
                <!-- MOBILE HEADER -->
                <div class="lg:hidden flex items-center justify-between p-4 border-b border-[var(--color-border-hairline)] bg-[var(--color-frame-bg)] sticky top-0 z-20">
                    <div class="font-bold text-[var(--color-text-primary)]">${paper.label}</div>
                    <div class="flex items-center gap-3">
                        ${renderPaperSelector(true)}
                        <button onclick="toggleDrawer()" class="text-[var(--color-accent)] font-medium text-sm">Jump to</button>
                    </div>
                </div>

                <!-- NAV COLUMN (Desktop) -->
                <nav class="hidden lg:block nav-column hide-scrollbar p-6">
                     <div class="mb-6">
                        <label class="type-label text-xs uppercase tracking-wider mb-2">Paper</label>
                        ${renderPaperSelector(false)}
                     </div>
                     ${renderNavList(paper)}
                </nav>

                <!-- PAPER COLUMN -->
                <main class="paper-column flex flex-col">
                    <!-- Desktop Header Area -->
                    <div class="hidden lg:block p-8 pb-4 border-b border-[var(--color-border-hairline)] bg-[var(--color-paper-bg)]">
                        <h1 class="text-2xl font-bold text-[var(--color-text-primary)]">${paper.label}</h1>
                    </div>
                    
                    <!-- Paper Surface -->
                    <div class="paper-surface">
                        ${renderPaperContent(paper)}
                    </div>
                </main>

                <!-- MOBILE DRAWER -->
                ${renderDrawer(paper)}
            `;

            app.innerHTML = contentHTML;

            // Post-render: KaTeX
            renderMathInElement(app, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });

            // Scroll restoration for toggles
            if (preserveScroll) {
                window.scrollTo(0, scrollPos);
            }
        }

        function renderPaperSelector(isMobile) {
            const options = state.papers.map(p => 
                `<option value="${p.key}" ${p.key === state.activePaperKey ? 'selected' : ''}>${p.label}</option>`
            ).join('');
            
            // Mobile: Minimal select. Desktop: Standard styled select.
            return `
                <select onchange="selectPaper(this.value)" 
                    class="bg-transparent border border-[var(--color-border-hairline)] rounded px-2 py-1 text-sm text-[var(--color-text-primary)] focus:border-[var(--color-accent)] focus:ring-1 focus:ring-[var(--color-accent)] outline-none">
                    ${options}
                </select>
            `;
        }

        function renderNavList(paper) {
            let html = '<div class="flex flex-col gap-1">';
            
            // Flatten logic or Section loop
            if (paper.sections) {
                paper.sections.forEach(section => {
                    if (section.label && section.label.trim().length > 0) {
                        html += `<div class="nav-section-label">${section.label}</div>`;
                    }
                    if (section.questions) {
                        section.questions.forEach(q => html += renderNavNode(q));
                    }
                });
            } else if (paper.questions) {
                paper.questions.forEach(q => html += renderNavNode(q));
            }
            
            html += '</div>';
            return html;
        }

        function renderNavNode(node) {
            let html = '';
            // Render self
            html += `<a href="#${node.id}" onclick="closeDrawer()" class="nav-item">${node.id}</a>`;
            // Render children (Recursive)
            if (node.children) {
                node.children.forEach(child => {
                    // Stage 5.4.5: Flat list, hierarchy via type scale/quietness. 
                    // We can add a class to make children slightly distinct if desired, but "flat list" is strict.
                    // We will just render them. 
                    html += renderNavNode(child);
                });
            }
            return html;
        }

        function renderPaperContent(paper) {
            let html = '<div class="space-y-12">'; // SPC__TOP_LEVEL_INTER_QUESTION_SPACING
            
            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    // Section Wrapper
                    html += `<div class="section-block">`;
                    
                    // Section Header (if present)
                    if (section.label && section.label.trim().length > 0) {
                        html += `
                            <div class="border-b border-[var(--color-border-hairline)] pb-2 mb-8 mt-4">
                                <h2 class="text-lg font-bold text-[var(--color-text-primary)]">${section.label}</h2>
                            </div>
                        `;
                    }
                    
                    // Questions List
                    html += `<div class="space-y-12">`;
                    if (section.questions) {
                        section.questions.forEach(q => html += renderQuestionNode(q, 0));
                    }
                    html += `</div>`; // Close Q List
                    
                    html += `</div>`; // Close Section
                    
                    // Spacer between sections
                    if (idx < paper.sections.length - 1) {
                        html += `<div class="h-8"></div>`;
                    }
                });
            } else if (paper.questions) {
                paper.questions.forEach(q => html += renderQuestionNode(q, 0));
            }
            
            html += '</div>';
            return html;
        }

        function renderQuestionNode(node, depth) {
            // ID for anchors
            const anchorId = node.id;
            
            // Spacing for nesting
            const isChild = depth > 0;
            const nestingClass = isChild ? "ml-0 mt-6 pl-4 border-l-2 border-[var(--color-border-hairline)]" : ""; // Indentation adapt via spacing/border per Stage 3 options
            
            // Markdown Rendering
            const qBodyHTML = md ? md.render(node.question || "") : node.question;
            
            // Solution Block
            const sb = node.solutionBlock;
            const hasAnswer = sb && sb.answer;
            const hasDetails = sb && sb.solutionDetails;
            
            let solutionBlockHTML = "";
            
            if (sb) {
                // Answer
                if (hasAnswer) {
                    const ansHTML = md ? md.render(sb.answer) : sb.answer;
                    solutionBlockHTML += `
                        <div class="mt-4 mb-2">
                            <span class="type-label">Answer</span>
                            <div class="text-[var(--color-text-primary)] font-medium">
                                ${ansHTML}
                            </div>
                        </div>
                    `;
                }
                
                // Solution Details
                if (hasDetails) {
                    const expanded = isExpanded(node.id);
                    const toggleText = expanded ? "Hide working" : "Show working";
                    const chevron = expanded ? "▼" : "▶";
                    
                    let detailsContent = "";
                    if (expanded) {
                        const sd = sb.solutionDetails;
                        
                        // Keep In Mind
                        if (sd.keepInMind) {
                            const kimHTML = md ? md.render(sd.keepInMind) : sd.keepInMind;
                            detailsContent += `
                                <div class="mb-6 bg-[var(--color-wash-keep-in-mind)] p-3 rounded-sm border-l-4 border-[var(--color-accent)] bg-opacity-30">
                                    <div class="type-label text-[var(--color-accent)] flex items-center gap-2">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                        Keep in mind
                                    </div>
                                    <div class="text-sm mt-1 space-y-1">${kimHTML}</div>
                                </div>
                            `;
                        }
                        
                        // Formulas
                        if (sd.formulasUsed) {
                            const formHTML = md ? md.render(sd.formulasUsed) : sd.formulasUsed;
                            detailsContent += `
                                <div class="mb-6">
                                    <span class="type-label">Formulas used</span>
                                    <div class="text-sm text-[var(--color-text-secondary)] space-y-1">${formHTML}</div>
                                </div>
                            `;
                        }
                        
                        // Working
                        if (sd.working) {
                            const workHTML = md ? md.render(sd.working) : sd.working;
                            // Internal Grammar: Mixed Prose + Math.
                            // We use CSS to separate paragraphs.
                            detailsContent += `
                                <div class="mb-6">
                                    <span class="type-label">Working</span>
                                    <div class="text-[var(--color-text-secondary)] space-y-3 leading-relaxed">
                                        ${workHTML}
                                    </div>
                                </div>
                            `;
                        }
                        
                        // Alternative Working
                        if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                            sd.alternativeWorking.forEach((alt, idx) => {
                                const altHTML = md ? md.render(alt) : alt;
                                detailsContent += `
                                    <div class="mt-8 pt-4 border-t border-[var(--color-border-hairline)]">
                                        <span class="type-label">Alternative working</span>
                                        <div class="text-[var(--color-text-secondary)] space-y-3 leading-relaxed mt-2">
                                            ${altHTML}
                                        </div>
                                    </div>
                                `;
                            });
                        } else if (sd.alternativeWorking) {
                             // String case fallback
                             const altHTML = md ? md.render(sd.alternativeWorking) : sd.alternativeWorking;
                             detailsContent += `
                                    <div class="mt-8 pt-4 border-t border-[var(--color-border-hairline)]">
                                        <span class="type-label">Alternative working</span>
                                        <div class="text-[var(--color-text-secondary)] space-y-3 leading-relaxed mt-2">
                                            ${altHTML}
                                        </div>
                                    </div>
                                `;
                        }
                    }

                    solutionBlockHTML += `
                        <div class="mt-4">
                            <button onclick="toggleNode('${node.id}')" class="btn-disclosure mb-2">
                                <span class="text-[0.7em]">${chevron}</span> ${toggleText}
                            </button>
                            ${expanded ? `<div class="solution-details-region">${detailsContent}</div>` : ''}
                        </div>
                    `;
                }
            }

            // Children
            let childrenHTML = "";
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    childrenHTML += renderQuestionNode(child, depth + 1);
                });
            }

            return `
                <div id="${anchorId}" class="question-node relative ${nestingClass}">
                    <!-- Question Body -->
                    <div class="type-question-body text-[var(--color-text-primary)]">
                        <div class="flex items-baseline">
                            <span class="type-question-id shrink-0 select-none">${node.id}</span>
                            <div class="grow space-y-2">
                                ${qBodyHTML}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Solution Block -->
                    ${solutionBlockHTML ? `<div class="pl-[2.5em] md:pl-0 mt-2">${solutionBlockHTML}</div>` : ''}
                    
                    <!-- Children Container -->
                    ${childrenHTML}
                </div>
            `;
        }

        // --- DRAWER LOGIC ---
        function toggleDrawer() {
            state.isDrawerOpen = !state.isDrawerOpen;
            renderApp(true);
        }
        function closeDrawer() {
            state.isDrawerOpen = false;
            renderApp(true);
        }

        function renderDrawer(paper) {
            const hiddenClass = state.isDrawerOpen ? "" : "pointer-events-none opacity-0";
            const translateClass = state.isDrawerOpen ? "translate-x-0" : "-translate-x-full";
            
            return `
                <div class="fixed inset-0 z-50 lg:hidden ${hiddenClass}">
                    <!-- Scrim -->
                    <div class="absolute inset-0 bg-black/20 drawer-overlay ${state.isDrawerOpen ? 'opacity-100' : 'opacity-0'}" onclick="closeDrawer()"></div>
                    
                    <!-- Drawer Panel -->
                    <div class="absolute inset-y-0 left-0 w-[85%] max-w-[300px] bg-[var(--color-frame-bg)] drawer-content flex flex-col ${translateClass} shadow-xl">
                        <div class="p-4 border-b border-[var(--color-border-hairline)] flex items-center justify-between">
                            <h2 class="font-bold text-[var(--color-text-primary)]">Jump to</h2>
                            <button onclick="closeDrawer()" class="p-2 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)]">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                            </button>
                        </div>
                        <div class="flex-1 overflow-y-auto p-4 hide-scrollbar">
                            ${renderNavList(paper)}
                        </div>
                    </div>
                </div>
            `;
        }

        // --- BOOTSTRAP ---
        init();

    </script>
</body>
</html>
