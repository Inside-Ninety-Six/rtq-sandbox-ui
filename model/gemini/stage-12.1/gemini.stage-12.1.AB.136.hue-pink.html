<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"136","totalWithinVariant":"200","hueFamily":"pink","intensityMode":"","timestamp":"2026-01-07T06:28:13.947Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;136&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;pink&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-07T06:28:13.947Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer (Proto)</title>

    <!-- Tailwind CSS (via CDN, no SRI) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS (no SRI) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- KaTeX JS (no SRI) -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Markdown-it (no SRI) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <!-- Tailwind Config for ColorLab B (Pink) -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        // Semantic mapping for ColorLab B (Pink Forced)
                        // Base neutrals
                        background: '#fafafa', // warm/neutral-50
                        surface: '#ffffff',
                        
                        // Text hierarchy
                        'text-primary': '#171717', // neutral-900
                        'text-secondary': '#525252', // neutral-600
                        'text-tertiary': '#a3a3a3', // neutral-400

                        // Accent (Pink) - Used for links, focus, active markers, toggles
                        accent: {
                            DEFAULT: '#db2777', // pink-600
                            hover: '#be185d', // pink-700
                            light: '#fce7f3', // pink-100
                            focus: '#f472b6', // pink-400
                        },
                        
                        // Borders
                        border: '#e5e5e5', // neutral-200
                        'border-light': '#f5f5f5', // neutral-100
                    }
                }
            }
        }
    </script>

    <style>
        /* Base styles */
        body {
            background-color: theme('colors.background');
            color: theme('colors.text-primary');
            -webkit-font-smoothing: antialiased;
        }

        /* Focus management */
        :focus-visible {
            outline: 2px solid theme('colors.accent.focus');
            outline-offset: 2px;
        }

        /* KaTeX Containment Invariant */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding: 0.5em 0;
            /* Scrollbar hiding for clean look but functional */
            scrollbar-width: thin; 
        }
        
        /* Table styles per Stage 5.8.5 */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
            font-size: 0.95em;
        }
        th, td {
            border: 1px solid theme('colors.border');
            padding: 0.5rem;
            text-align: left;
        }
        th {
            font-weight: 600;
        }
        
        /* Hide scrollbar for nav but allow scroll */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Typography spacing for rendered markdown */
        .markdown-body p {
            margin-bottom: 1em;
            line-height: 1.6;
        }
        .markdown-body p:last-child {
            margin-bottom: 0;
        }
        .markdown-body ul {
            list-style-type: disc;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }
        .markdown-body ol {
            list-style-type: decimal;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        /* Sticky Nav cues */
        .nav-item-active {
            font-weight: 700;
            color: theme('colors.accent.DEFAULT');
        }
        .nav-item-inactive {
            color: theme('colors.text-secondary');
        }
        .nav-item-inactive:hover {
            color: theme('colors.text-primary');
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Top Controls Region -->
    <header class="flex-none border-b border-border bg-surface z-10">
        <div class="max-w-6xl mx-auto px-4 md:px-6 h-14 flex items-center justify-between">
            <div class="flex items-center gap-4">
                <!-- Paper Selector -->
                <select id="paper-selector" class="text-sm bg-transparent font-medium focus:outline-none cursor-pointer hover:text-accent">
                    <option disabled selected>Loading papers...</option>
                </select>
            </div>
            
            <!-- Mobile Jump To Trigger -->
            <button id="mobile-jump-trigger" class="md:hidden text-sm font-medium text-accent">
                Jump to
            </button>
        </div>
    </header>

    <!-- DocumentFrameShell -->
    <div class="flex-1 overflow-hidden relative">
        <div class="max-w-6xl mx-auto h-full flex md:px-6">
            
            <!-- Desktop Navigation Rail (Sticky) -->
            <nav class="hidden md:block w-48 lg:w-56 flex-none h-full overflow-y-auto no-scrollbar py-8 pr-6 border-r border-transparent">
                <div id="desktop-nav-list" class="flex flex-col gap-1">
                    <!-- Nav items generated here -->
                </div>
            </nav>

            <!-- Paper Document Column -->
            <main id="paper-scroll-container" class="flex-1 h-full overflow-y-auto bg-surface relative">
                <div id="paper-content" class="max-w-3xl mx-auto py-12 px-4 md:px-12 min-h-full">
                    <div class="flex items-center justify-center h-64 text-text-secondary animate-pulse">
                        Loading payload...
                    </div>
                </div>
            </main>

        </div>
    </div>

    <!-- Mobile Navigation Drawer -->
    <div id="mobile-drawer" class="fixed inset-0 z-50 hidden" aria-modal="true" role="dialog">
        <!-- Backdrop -->
        <div id="mobile-drawer-backdrop" class="absolute inset-0 bg-black/20 backdrop-blur-sm transition-opacity opacity-0"></div>
        <!-- Drawer Panel -->
        <div id="mobile-drawer-panel" class="absolute right-0 top-0 bottom-0 w-64 bg-surface shadow-xl transform translate-x-full transition-transform duration-300 flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-border">
                <h2 class="font-semibold text-text-primary">Jump to</h2>
                <button id="mobile-drawer-close" class="text-text-secondary hover:text-text-primary p-1">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="mobile-nav-list" class="flex-1 overflow-y-auto p-4 space-y-1">
                <!-- Mobile nav items generated here -->
            </div>
        </div>
    </div>

    <!-- App Scripts -->
    <script>
        // --- STAGE 0: CONSTANTS ---
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";
        const RTQ_COLORLAB_FORCE_HUE_FAMILY = "pink"; // Stage 6 Add-on

        // --- STATE ---
        let appState = {
            papers: [],
            currentPaper: null,
            expandedWorkings: new Set(), // Set of question IDs
            payloadLoaded: false
        };

        // --- MARKDOWN SETUP (Stage 6 Hardening) ---
        let md = null;
        if (window.markdownit) {
            md = window.markdownit({
                html: true,
                linkify: true,
                breaks: false // MUST be false
            });
            // Disable inline escape to preserve TeX backslashes
            md.inline.ruler.disable(['escape']);
        }

        // --- MAIN INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            initMobileDrawer();
            await loadPayload();
        });

        // --- PAYLOAD LOADING ---
        async function loadPayload() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error('Fetch failed');
                const data = await response.json();
                
                if (!data.papers || !Array.isArray(data.papers)) {
                    throw new Error('Invalid payload format');
                }

                appState.papers = data.papers;
                appState.payloadLoaded = true;
                
                initPaperSelector();
                // Load first paper by default
                if (appState.papers.length > 0) {
                    loadPaper(appState.papers[0].key);
                }
            } catch (err) {
                renderError("PAPERS PAYLOAD MISSING");
                console.error(err);
            }
        }

        function renderError(msg) {
            const container = document.getElementById('paper-content');
            container.innerHTML = `<div class="flex items-center justify-center h-full text-lg font-medium text-text-secondary">${msg}</div>`;
            document.getElementById('paper-selector').innerHTML = '<option>Error</option>';
            document.getElementById('paper-selector').disabled = true;
        }

        // --- PAPER SELECTOR ---
        function initPaperSelector() {
            const selector = document.getElementById('paper-selector');
            selector.innerHTML = '';
            
            appState.papers.forEach(paper => {
                const opt = document.createElement('option');
                opt.value = paper.key;
                opt.textContent = paper.label || paper.key;
                selector.appendChild(opt);
            });

            selector.addEventListener('change', (e) => {
                loadPaper(e.target.value);
            });
        }

        function loadPaper(key) {
            const paper = appState.papers.find(p => p.key === key);
            if (!paper) return;

            appState.currentPaper = paper;
            
            // Handle defaults
            const expandAll = paper.defaults?.expandedAll !== false; // Default true unless false
            appState.expandedWorkings.clear();
            
            if (expandAll) {
                // We need to recursively find all questions with solutionDetails and add them
                const collectIds = (nodes) => {
                    nodes.forEach(node => {
                        if (node.solutionBlock?.solutionDetails) {
                            appState.expandedWorkings.add(node.id);
                        }
                        if (node.children) collectIds(node.children);
                    });
                };
                // Flatten sections if needed
                if (paper.sections) {
                    paper.sections.forEach(s => collectIds(s.questions));
                } else if (paper.questions) {
                    collectIds(paper.questions);
                }
            }

            // Reset scroll
            document.getElementById('paper-scroll-container').scrollTop = 0;

            renderApp();
        }

        // --- RENDERING CORE ---
        function renderApp() {
            const paperContent = document.getElementById('paper-content');
            const desktopNav = document.getElementById('desktop-nav-list');
            const mobileNav = document.getElementById('mobile-nav-list');

            // Clear
            paperContent.innerHTML = '';
            desktopNav.innerHTML = '';
            mobileNav.innerHTML = '';

            const paper = appState.currentPaper;

            // Render Navigation
            const navHTML = buildNavigationHTML(paper);
            desktopNav.innerHTML = navHTML;
            mobileNav.innerHTML = navHTML;
            
            // Attach Nav Events
            attachNavEvents(desktopNav);
            attachNavEvents(mobileNav);

            // Render Content
            if (paper.sections) {
                paper.sections.forEach((section, index) => {
                    // Section Header (only if label exists)
                    if (section.label && section.label.trim() !== "") {
                        const secHeader = document.createElement('div');
                        secHeader.className = "mb-8 pt-4 border-b border-border pb-2";
                        secHeader.innerHTML = `<h2 class="text-xl font-bold text-text-primary">${section.label}</h2>`;
                        paperContent.appendChild(secHeader);
                    }
                    // Render Questions
                    renderQuestionList(section.questions, paperContent, true);
                    
                    // Spacer between sections
                    if (index < paper.sections.length - 1) {
                        const spacer = document.createElement('div');
                        spacer.className = "h-16"; // Large vertical separation
                        paperContent.appendChild(spacer);
                    }
                });
            } else if (paper.questions) {
                renderQuestionList(paper.questions, paperContent, true);
            }

            // Post-Render: Math
            renderMathInElement(paperContent, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });
        }

        function renderQuestionList(questions, container, isTopLevel) {
            questions.forEach((q, idx) => {
                const node = renderQuestionNode(q, isTopLevel);
                container.appendChild(node);
                
                // Top level spacing
                if (isTopLevel && idx < questions.length - 1) {
                    const spacer = document.createElement('div');
                    spacer.className = "h-12 md:h-16"; // SPC__TOP_LEVEL_INTER_QUESTION_SPACING
                    container.appendChild(spacer);
                }
            });
        }

        // --- NODE RENDERER ---
        function renderQuestionNode(q, isTopLevel) {
            const wrapper = document.createElement('div');
            wrapper.className = "flex flex-col gap-4"; // SPC__QUESTION_NODE_INTERNAL
            wrapper.id = `q-${q.id}`; // Anchor for nav

            // 1. Question Body
            const qBody = document.createElement('div');
            qBody.className = "flex gap-3 md:gap-4";
            
            const qId = document.createElement('div');
            qId.className = `flex-none font-semibold text-text-primary ${isTopLevel ? 'text-lg' : 'text-base'}`;
            qId.textContent = q.id;

            const qPrompt = document.createElement('div');
            qPrompt.className = `flex-1 text-text-primary markdown-body ${isTopLevel ? 'text-lg leading-relaxed' : 'text-base leading-relaxed'}`;
            qPrompt.innerHTML = renderMarkdown(q.question);

            qBody.append(qId, qPrompt);
            wrapper.appendChild(qBody);

            // 2. Solution Block (Optional)
            if (q.solutionBlock) {
                const sb = q.solutionBlock;
                const hasDetails = !!sb.solutionDetails;
                
                // Container for solution block
                const sbContainer = document.createElement('div');
                sbContainer.className = "ml-8 md:ml-10 flex flex-col gap-4"; // Indented to align with content

                // Answer (if present)
                if (sb.answer) {
                    const ansRow = document.createElement('div');
                    ansRow.className = "flex flex-col sm:flex-row gap-1 sm:gap-4 items-start";
                    
                    const ansLabel = document.createElement('span');
                    ansLabel.className = "text-sm font-bold text-accent uppercase tracking-wide pt-1";
                    ansLabel.textContent = "Answer";
                    
                    const ansContent = document.createElement('div');
                    ansContent.className = "markdown-body text-text-primary font-medium";
                    ansContent.innerHTML = renderMarkdown(sb.answer);

                    ansRow.append(ansLabel, ansContent);
                    sbContainer.appendChild(ansRow);
                }

                // Solution Details (if present)
                if (hasDetails) {
                    const isExpanded = appState.expandedWorkings.has(q.id);
                    
                    // Disclosure Control
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = "flex items-center gap-2 text-sm font-medium text-accent hover:text-accent-hover transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-1 rounded px-1 -ml-1 w-fit";
                    toggleBtn.innerHTML = `
                        <span class="transform transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg>
                        </span>
                        <span>${isExpanded ? 'Hide working' : 'Show working'}</span>
                    `;
                    
                    toggleBtn.onclick = () => {
                        if (appState.expandedWorkings.has(q.id)) {
                            appState.expandedWorkings.delete(q.id);
                        } else {
                            appState.expandedWorkings.add(q.id);
                        }
                        // Re-render just this node's parent container or easier: re-render app (simplest for prototype correctness, though inefficient)
                        // For efficiency in prototype, we'll just re-render this node? No, layout might shift. 
                        // Let's preserve scroll position effectively by just re-rendering app, which we do in toggle logic.
                        const scrollPos = document.getElementById('paper-scroll-container').scrollTop;
                        renderApp();
                        document.getElementById('paper-scroll-container').scrollTop = scrollPos;
                    };
                    
                    sbContainer.appendChild(toggleBtn);

                    // Expanded Content
                    if (isExpanded) {
                        const sd = sb.solutionDetails;
                        const detailsRegion = document.createElement('div');
                        detailsRegion.className = "mt-2 pl-4 border-l-2 border-border-light space-y-6"; // Demarcation: Spacing + light line
                        
                        // Keep in mind
                        if (sd.keepInMind) {
                            const kim = document.createElement('div');
                            kim.innerHTML = `
                                <div class="text-sm font-bold text-text-secondary mb-1 flex items-center gap-2">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                    Keep in mind
                                </div>
                                <div class="markdown-body text-sm text-text-secondary">${renderMarkdown(sd.keepInMind)}</div>
                            `;
                            detailsRegion.appendChild(kim);
                        }

                        // Formulas used
                        if (sd.formulasUsed) {
                            const form = document.createElement('div');
                            form.innerHTML = `
                                <div class="text-sm font-bold text-text-secondary mb-1">Formulas used</div>
                                <div class="markdown-body text-sm text-text-secondary">${renderMarkdown(sd.formulasUsed)}</div>
                            `;
                            detailsRegion.appendChild(form);
                        }

                        // Working
                        if (sd.working) {
                            const work = document.createElement('div');
                            work.innerHTML = `
                                <div class="text-sm font-bold text-text-secondary mb-2">Working</div>
                                <div class="markdown-body text-base text-text-primary">${renderMarkdown(sd.working)}</div>
                            `;
                            detailsRegion.appendChild(work);
                        }

                        // Alternative working
                        if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                            sd.alternativeWorking.forEach((alt, idx) => {
                                const altBlock = document.createElement('div');
                                altBlock.className = "pt-4 border-t border-dashed border-border";
                                altBlock.innerHTML = `
                                    <div class="text-sm font-bold text-text-secondary mb-2">Alternative working</div>
                                    <div class="markdown-body text-base text-text-primary">${renderMarkdown(alt)}</div>
                                `;
                                detailsRegion.appendChild(altBlock);
                            });
                        }

                        sbContainer.appendChild(detailsRegion);
                    }
                }
                wrapper.appendChild(sbContainer);
            }

            // 3. Children
            if (q.children && q.children.length > 0) {
                const childContainer = document.createElement('div');
                childContainer.className = "flex flex-col gap-6 mt-4"; // Spacing for sub-questions
                // Nesting indentation handled via margin if needed, but visually flat aligned left for prompt text usually works best with id offset.
                // However, Brief says "Horizontal indentation... optional". 
                // Let's add a small indent for hierarchy.
                childContainer.className += " ml-4 md:ml-8"; 
                
                q.children.forEach((child) => {
                    childContainer.appendChild(renderQuestionNode(child, false));
                });
                wrapper.appendChild(childContainer);
            }

            return wrapper;
        }

        function renderMarkdown(text) {
            if (!text || !md) return text || '';
            return md.render(text);
        }

        // --- NAVIGATION GENERATION ---
        function buildNavigationHTML(paper) {
            let html = '';
            
            if (paper.sections) {
                paper.sections.forEach(sec => {
                    // Section Label (Non-clickable)
                    if (sec.label) {
                        html += `<div class="px-2 py-2 text-xs font-bold text-text-tertiary uppercase tracking-wider mt-4 first:mt-0 select-none">${sec.label}</div>`;
                    }
                    html += buildNavItems(sec.questions);
                });
            } else if (paper.questions) {
                html += buildNavItems(paper.questions);
            }
            return html;
        }

        function buildNavItems(questions) {
            let html = '';
            questions.forEach(q => {
                html += `<button data-target="q-${q.id}" class="w-full text-left px-2 py-1 text-sm rounded transition-colors nav-item-inactive hover:bg-black/5 focus:outline-none focus:bg-black/5 truncate">${q.id}</button>`;
                if (q.children) {
                    // Recursive, flat visually but ordered
                    html += buildNavItems(q.children);
                }
            });
            return html;
        }

        function attachNavEvents(container) {
            const btns = container.querySelectorAll('button[data-target]');
            btns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetId = btn.getAttribute('data-target');
                    const targetEl = document.getElementById(targetId);
                    if (targetEl) {
                        targetEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        // Update active state visually (simple version)
                        updateActiveNav(targetId);
                        
                        // Close mobile drawer if open
                        closeMobileDrawer();
                    }
                });
            });
        }

        // --- SCROLL SPY & ACTIVE STATE ---
        // Simple IntersectionObserver for active nav state
        let observer;
        function updateActiveNav(activeId) {
            // Remove active class from all
            document.querySelectorAll('.nav-item-active').forEach(el => {
                el.classList.remove('nav-item-active');
                el.classList.add('nav-item-inactive');
            });
            // Add to current
            const navLinks = document.querySelectorAll(`button[data-target="${activeId}"]`);
            navLinks.forEach(el => {
                el.classList.remove('nav-item-inactive');
                el.classList.add('nav-item-active');
            });
        }
        
        // Setup observer once rendering is stable
        // For this prototype, we rely on click-to-set active mostly, 
        // but let's add a scroll listener to Paper Scroll Container to auto-update
        const scrollContainer = document.getElementById('paper-scroll-container');
        scrollContainer.addEventListener('scroll', throttle(() => {
            // Find visible question
            // Logic: Find the question closest to top of viewport
            const headers = document.querySelectorAll('[id^="q-"]');
            let current = null;
            for (let h of headers) {
                const rect = h.getBoundingClientRect();
                // 100px buffer
                if (rect.top < 200 && rect.bottom > 0) {
                    current = h.id;
                    // Keep searching to find the one that starts nearest top but hasn't scrolled off
                }
            }
            // Actually, find the first one with top >= 0 or the one just above it
            // A simple approach for prototype:
            let found = null;
            for (let h of headers) {
                const rect = h.getBoundingClientRect();
                if (rect.top >= 0 && rect.top < window.innerHeight / 2) {
                    found = h.id;
                    break;
                }
            }
            if (!found && headers.length > 0) {
                // Check if we are way down
                // Just keep the last active one effectively
            } else if (found) {
                updateActiveNav(found);
            }
        }, 100));

        function throttle(func, limit) {
            let lastFunc;
            let lastRan;
            return function() {
                const context = this;
                const args = arguments;
                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(context, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            }
        }

        // --- MOBILE DRAWER ---
        function initMobileDrawer() {
            const trigger = document.getElementById('mobile-jump-trigger');
            const drawer = document.getElementById('mobile-drawer');
            const closeBtn = document.getElementById('mobile-drawer-close');
            const backdrop = document.getElementById('mobile-drawer-backdrop');
            const panel = document.getElementById('mobile-drawer-panel');

            trigger.addEventListener('click', () => {
                drawer.classList.remove('hidden');
                // Force reflow
                void drawer.offsetWidth;
                backdrop.classList.remove('opacity-0');
                panel.classList.remove('translate-x-full');
            });

            const close = () => {
                backdrop.classList.add('opacity-0');
                panel.classList.add('translate-x-full');
                setTimeout(() => {
                    drawer.classList.add('hidden');
                }, 300);
            };

            closeBtn.addEventListener('click', close);
            backdrop.addEventListener('click', close);
            window.closeMobileDrawer = close;
        }

    </script>
</body>
</html>
