<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"44","totalWithinVariant":"200","hueFamily":"red","intensityMode":"","timestamp":"2026-01-06T21:35:09.930Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;44&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;red&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-06T21:35:09.930Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer</title>

    <!-- KaTeX CSS (No integrity/SRI as per Stage 6 rules) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- Markdown-it -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
    
    <!-- KaTeX JS -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        /* 
         * COLORLAB B: FORCED HUE FAMILY = RED
         * STAGE 6 ADD-ON: LIGHT MODE ONLY
         */
        :root {
            /* Base Palette - Red Hue Family (Hue ~350-360) */
            --hue-primary: 355; 
            
            /* Neutrals (tinted slightly red for warmth/consistency) */
            --color-bg-page: hsl(var(--hue-primary), 20%, 98%);
            --color-bg-paper: #ffffff;
            --color-surface-nav: var(--color-bg-page); /* Shared surface context */
            
            /* Text */
            --color-text-primary: hsl(var(--hue-primary), 10%, 15%);   /* Question text */
            --color-text-secondary: hsl(var(--hue-primary), 5%, 35%);  /* Subordinate text */
            --color-text-tertiary: hsl(var(--hue-primary), 5%, 55%);   /* Quiet text */
            
            /* Accents (Restrained Red) */
            --color-accent: hsl(var(--hue-primary), 70%, 45%);         /* Links, focus, active markers */
            --color-accent-hover: hsl(var(--hue-primary), 70%, 35%);
            --color-focus-ring: hsla(var(--hue-primary), 80%, 50%, 0.4);

            /* Structural / Separators */
            --color-hairline: hsl(var(--hue-primary), 10%, 90%);
            --color-wash-solution: hsl(var(--hue-primary), 10%, 99%); /* Extremely subtle wash */
            
            /* Spacing Units */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2.5rem; /* Top level separation */
            
            /* Typography */
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-base: 16px;
            --line-height-prose: 1.6;
            --line-height-tight: 1.4;
        }

        /* Reset & Base */
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-family);
            background-color: var(--color-bg-page);
            color: var(--color-text-primary);
            line-height: var(--line-height-prose);
            -webkit-font-smoothing: antialiased;
        }
        
        button { font-family: inherit; }

        /* Focus Management */
        *:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* 
         * LAYOUT ARCHITECTURE (Stage 3)
         */
        .app-shell {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Top Controls Region */
        .top-controls {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: var(--color-bg-page); /* Matches page bg */
            border-bottom: 1px solid var(--color-hairline);
            padding: var(--space-md) 0;
        }
        
        .top-controls-inner {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 var(--space-lg);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .paper-selector {
            padding: var(--space-sm);
            font-size: 0.95rem;
            border: 1px solid var(--color-hairline);
            border-radius: 4px;
            background: var(--color-bg-paper);
            color: var(--color-text-primary);
        }

        .mobile-jump-trigger {
            display: none; /* Desktop default */
            background: none;
            border: 1px solid var(--color-hairline);
            border-radius: 4px;
            padding: var(--space-sm) var(--space-md);
            color: var(--color-accent);
            font-weight: 500;
            cursor: pointer;
        }

        /* Document Frame Shell */
        .document-frame {
            flex: 1;
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            position: relative;
        }

        /* Navigation Rail (Desktop) */
        .nav-col {
            width: 240px;
            flex-shrink: 0;
            padding-top: var(--space-lg);
            padding-bottom: var(--space-lg);
            padding-left: var(--space-lg); /* Gutter */
            position: sticky;
            top: 70px; /* Offset for top controls */
            height: calc(100vh - 70px);
            overflow-y: auto;
            /* Scrollbar hiding */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .nav-col::-webkit-scrollbar { display: none; }

        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        /* Nav Items - Flat List, Type Scale Hierarchy */
        .nav-section-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--color-text-tertiary);
            text-transform: uppercase;
            padding: var(--space-md) 0 var(--space-xs) 0;
            pointer-events: none;
            border-top: 1px solid transparent; /* Spacer */
        }
        .nav-section-label:first-child { padding-top: 0; }

        .nav-item {
            display: block;
            text-decoration: none;
            color: var(--color-text-secondary);
            font-size: 0.95rem;
            padding: 4px 0;
            cursor: pointer;
            transition: color 0.1s ease;
            border-left: 2px solid transparent;
            padding-left: var(--space-sm);
            margin-left: -2px; /* Pull border flush */
        }
        
        .nav-item:hover {
            color: var(--color-text-primary);
        }

        .nav-item.active {
            color: var(--color-accent);
            font-weight: 600;
            border-left-color: var(--color-accent); /* Active marker */
        }

        /* Sub-questions quieter */
        .nav-item.is-child {
            font-size: 0.85rem;
            color: var(--color-text-tertiary);
        }
        .nav-item.is-child.active {
            color: var(--color-accent);
        }

        /* Paper Content Column */
        .paper-col {
            flex: 1;
            padding: var(--space-lg);
            min-width: 0; /* Prevent flex overflow */
        }

        /* Section Headers in Paper */
        .paper-section-header {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--color-text-primary);
            border-bottom: 1px solid var(--color-hairline);
            padding-bottom: var(--space-sm);
            margin-top: var(--space-xl);
            margin-bottom: var(--space-lg);
        }
        .paper-section-header:first-child { margin-top: 0; }

        /* Question Node Structure */
        .question-node {
            margin-bottom: var(--space-xl); /* Top level separation */
        }
        
        /* Children container - weaker separation */
        .children-container {
            margin-top: var(--space-md);
            padding-left: var(--space-md); /* Indentation for children */
            border-left: 1px solid transparent; /* Alignment aid only */
        }
        
        /* Responsive indentation adjustment */
        @media (max-width: 600px) {
            .children-container {
                padding-left: var(--space-sm);
            }
        }

        .question-node.is-child {
            margin-bottom: var(--space-lg);
        }

        /* Question Body */
        .question-body {
            display: flex;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm); /* Spacing to solution block */
        }
        
        .question-id {
            font-weight: 700;
            color: var(--color-text-secondary);
            flex-shrink: 0;
            min-width: 1.5rem;
        }
        
        .question-prompt {
            color: var(--color-text-primary);
            flex: 1;
        }

        /* Solution Block (Answer + Details) */
        .solution-block {
            margin-left: 2rem; /* Indent under prompt */
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }
        @media (max-width: 600px) {
            .solution-block { margin-left: 0; padding-top: var(--space-sm); }
        }

        /* Answer */
        .answer-region {
            font-weight: 500;
            color: var(--color-text-primary);
            display: flex;
            gap: var(--space-sm);
            align-items: baseline;
        }
        .answer-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--color-text-tertiary);
            font-weight: 700;
        }

        /* Solution Details (Expandable) */
        .solution-details-wrapper {
            margin-top: var(--space-xs);
        }

        .disclosure-control {
            background: none;
            border: none;
            padding: 0;
            font-size: 0.9rem;
            color: var(--color-accent);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
            font-weight: 500;
        }
        .disclosure-control:hover {
            text-decoration: underline;
            color: var(--color-accent-hover);
        }
        .chevron {
            transition: transform 0.2s ease;
            width: 1em; height: 1em;
            fill: currentColor;
        }
        .disclosure-control[aria-expanded="true"] .chevron {
            transform: rotate(180deg);
        }

        .solution-details-content {
            display: none;
            margin-top: var(--space-sm);
            padding: var(--space-md);
            background-color: var(--color-wash-solution); /* Subtle differentiation */
            border-left: 1px solid var(--color-hairline); /* Quiet boundary cue */
        }
        .solution-details-content.expanded {
            display: block;
            animation: reveal 0.2s ease-out;
        }

        @keyframes reveal {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Solution Subsections */
        .sd-subsection {
            margin-bottom: var(--space-lg);
        }
        .sd-subsection:last-child { margin-bottom: 0; }

        .sd-label {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-xs);
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        /* Specific Prominence Rules */
        .sd-keep-in-mind .sd-label { color: var(--color-text-primary); }
        .sd-formulas .sd-label { color: var(--color-text-tertiary); }
        
        .sd-body {
            font-size: 0.95rem;
            color: var(--color-text-secondary); /* Subordinate */
        }
        /* Anti-faded guardrail */
        .sd-body { --color-text-secondary: hsl(var(--hue-primary), 5%, 30%); }

        /* KaTeX / Math Containment */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0.5em 0;
            margin: 0.5em 0;
            -webkit-overflow-scrolling: touch;
            max-width: 100%;
        }
        /* ColorLab B: No accents on math backgrounds unless block math */
        /* We keep block math background strictly transparent or neutral wash */

        /* Tables in Markdown */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: var(--space-sm) 0;
            font-size: 0.9rem;
        }
        th, td {
            border: 1px solid var(--color-hairline);
            padding: var(--space-sm);
            text-align: left;
        }
        th { font-weight: 600; color: var(--color-text-primary); }

        /* Mobile Drawer */
        .drawer-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 100;
            display: none;
        }
        .drawer-overlay.open { display: block; }

        .drawer {
            position: fixed;
            top: 0; bottom: 0; right: 0; /* Right side drawer per typical mobile pattern or left? Brief says "Navigation Drawer", doesn't specify side. Right is cleaner for thumbs. Let's stick to Right or Left. Material is Left. Let's do Left for consistency with Desktop Rail. */
            left: 0;
            width: 80%;
            max-width: 300px;
            background: var(--color-bg-paper);
            z-index: 101;
            transform: translateX(-100%);
            transition: transform 0.25s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }
        .drawer.open { transform: translateX(0); }

        .drawer-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-hairline);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .drawer-title { font-weight: 600; }
        .drawer-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--color-text-secondary);
            cursor: pointer;
        }
        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-md);
        }

        /* Responsive */
        @media (max-width: 900px) {
            .nav-col { display: none; }
            .mobile-jump-trigger { display: block; }
            .top-controls-inner { padding: 0 var(--space-md); }
            .paper-col { padding: var(--space-md); }
        }

        /* Utility */
        .hidden { display: none; }
        .error-message {
            padding: var(--space-xl);
            text-align: center;
            color: var(--color-text-secondary);
            font-weight: 600;
        }

        /* Markdown spacing */
        p { margin-top: 0; margin-bottom: 0.8em; }
        p:last-child { margin-bottom: 0; }
        ul, ol { margin-top: 0; margin-bottom: 0.8em; padding-left: 1.2em; }
    </style>
</head>
<body>

<div id="app" class="app-shell">
    <!-- Top Controls -->
    <header class="top-controls">
        <div class="top-controls-inner">
            <select id="paperSelector" class="paper-selector" aria-label="Select Paper">
                <option value="" disabled selected>Loading papers...</option>
            </select>
            <button id="mobileJumpBtn" class="mobile-jump-trigger">Jump to...</button>
        </div>
    </header>

    <!-- Main Content Shell -->
    <div class="document-frame">
        <!-- Desktop Navigation Rail -->
        <nav class="nav-col" aria-label="Paper navigation">
            <div id="desktopNavList" class="nav-list"></div>
        </nav>

        <!-- Paper Content -->
        <main id="paperContent" class="paper-col" role="main">
            <!-- Content injected here -->
        </main>
    </div>

    <!-- Mobile Navigation Drawer -->
    <div id="drawerOverlay" class="drawer-overlay"></div>
    <div id="drawer" class="drawer" role="dialog" aria-modal="true" aria-label="Navigation">
        <div class="drawer-header">
            <span class="drawer-title">Jump to</span>
            <button id="drawerCloseBtn" class="drawer-close">&times;</button>
        </div>
        <div id="mobileNavContent" class="drawer-content">
            <div id="mobileNavList" class="nav-list"></div>
        </div>
    </div>
</div>

<script>
    /**
     * STAGE 0: CONSTANTS
     */
    const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
    const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

    // App State
    let papersData = [];
    let currentPaper = null;
    let md = null;

    /**
     * INITIALIZATION & SETUP
     */
    document.addEventListener('DOMContentLoaded', async () => {
        setupMarkdown();
        await loadPayload();
        setupInteractions();
    });

    function setupMarkdown() {
        if (window.markdownit) {
            md = window.markdownit({
                html: true, // Allow inline SVG per Stage 6
                linkify: true,
                breaks: false // CRITICAL: false to prevent <br> in math
            });
            // Disable escape rule to preserve TeX backslashes
            md.inline.ruler.disable(['escape']);
        } else {
            console.error("Markdown-it not loaded");
        }
    }

    async function loadPayload() {
        try {
            const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
            if (!response.ok) throw new Error("Payload not found");
            const data = await response.json();
            
            if (data && data.papers) {
                papersData = data.papers;
                populatePaperSelector();
                // Load first paper by default
                if (papersData.length > 0) {
                    loadPaper(papersData[0].key);
                }
            } else {
                renderError("PAPERS PAYLOAD MISSING");
            }
        } catch (e) {
            console.error(e);
            renderError("PAPERS PAYLOAD MISSING");
        }
    }

    function renderError(msg) {
        document.getElementById('paperContent').innerHTML = `<div class="error-message">${msg}</div>`;
        document.getElementById('paperSelector').disabled = true;
    }

    /**
     * PAPER RENDERING
     */
    function populatePaperSelector() {
        const selector = document.getElementById('paperSelector');
        selector.innerHTML = '';
        papersData.forEach(paper => {
            const opt = document.createElement('option');
            opt.value = paper.key;
            opt.textContent = paper.label || paper.key;
            selector.appendChild(opt);
        });
        selector.addEventListener('change', (e) => loadPaper(e.target.value));
    }

    function loadPaper(paperKey) {
        const paper = papersData.find(p => p.key === paperKey);
        if (!paper) return;
        currentPaper = paper;

        // Render Content
        const container = document.getElementById('paperContent');
        container.innerHTML = '';

        if (paper.sections) {
            // Sectioned Paper
            paper.sections.forEach(section => {
                if (section.label && section.label.trim() !== "") {
                    const header = document.createElement('div');
                    header.className = 'paper-section-header';
                    header.textContent = section.label; // Plain text per spec
                    container.appendChild(header);
                }
                renderQuestionList(section.questions, container, paper);
            });
        } else if (paper.questions) {
            // Flat Paper
            renderQuestionList(paper.questions, container, paper);
        }

        // Render Navigation
        renderNavigation(paper);

        // KaTeX Auto-Render
        renderMathInElement(container, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            throwOnError: false
        });

        // Reset Scroll
        window.scrollTo(0, 0);
    }

    function renderQuestionList(questions, container, paper) {
        questions.forEach(q => {
            container.appendChild(createQuestionNode(q, paper));
        });
    }

    function createQuestionNode(data, paper, isChild = false) {
        const node = document.createElement('div');
        node.className = `question-node ${isChild ? 'is-child' : ''}`;
        node.id = `q-${data.id}`; // Anchor for nav

        // 1. Question Body
        const body = document.createElement('div');
        body.className = 'question-body';
        
        const idEl = document.createElement('div');
        idEl.className = 'question-id';
        idEl.textContent = data.id; // Identifier only

        const promptEl = document.createElement('div');
        promptEl.className = 'question-prompt prose';
        promptEl.innerHTML = renderMarkdown(data.question || "");

        body.append(idEl, promptEl);
        node.appendChild(body);

        // 2. Solution Block (Optional)
        if (data.solutionBlock) {
            const block = document.createElement('div');
            block.className = 'solution-block';

            // Answer (Visible by default if present)
            if (data.solutionBlock.answer) {
                const answerRegion = document.createElement('div');
                answerRegion.className = 'answer-region';
                
                const ansLabel = document.createElement('span');
                ansLabel.className = 'answer-label';
                ansLabel.textContent = "Answer";
                
                const ansContent = document.createElement('div');
                ansContent.className = 'prose';
                ansContent.innerHTML = renderMarkdown(data.solutionBlock.answer);
                
                answerRegion.append(ansLabel, ansContent);
                block.appendChild(answerRegion);
            }

            // Solution Details (Expandable)
            if (data.solutionBlock.solutionDetails) {
                const details = data.solutionBlock.solutionDetails;
                const wrapper = document.createElement('div');
                wrapper.className = 'solution-details-wrapper';

                // Determine default state
                const defaultExpanded = paper.defaults?.expandedAll !== false; // Default true unless explicitly false

                // Toggle Control
                const toggle = document.createElement('button');
                toggle.className = 'disclosure-control';
                toggle.setAttribute('aria-expanded', defaultExpanded);
                // Icon (Chevron)
                const chevron = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                chevron.setAttribute("viewBox", "0 0 24 24");
                chevron.setAttribute("class", "chevron");
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z");
                chevron.appendChild(path);

                const labelSpan = document.createElement('span');
                labelSpan.textContent = defaultExpanded ? "Hide working" : "Show working";

                toggle.append(labelSpan, chevron);
                
                // Content Region
                const contentRegion = document.createElement('div');
                contentRegion.className = `solution-details-content ${defaultExpanded ? 'expanded' : ''}`;

                // Structure: Keep in mind -> Formulas -> Working -> Alt Working
                if (details.keepInMind) contentRegion.appendChild(createSDSubsection("Keep in mind", details.keepInMind, "sd-keep-in-mind"));
                if (details.formulasUsed) contentRegion.appendChild(createSDSubsection("Formulas used", details.formulasUsed, "sd-formulas"));
                if (details.working) contentRegion.appendChild(createSDSubsection("Working", details.working, "sd-working"));
                
                if (details.alternativeWorking && Array.isArray(details.alternativeWorking)) {
                    details.alternativeWorking.forEach(alt => {
                        contentRegion.appendChild(createSDSubsection("Alternative working", alt, "sd-alt-working"));
                    });
                }

                // Event Listener
                toggle.addEventListener('click', () => {
                    const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
                    toggle.setAttribute('aria-expanded', !isExpanded);
                    labelSpan.textContent = !isExpanded ? "Hide working" : "Show working";
                    contentRegion.classList.toggle('expanded');
                });

                wrapper.append(toggle, contentRegion);
                block.appendChild(wrapper);
            }

            node.appendChild(block);
        }

        // 3. Children (Recursive)
        if (data.children && data.children.length > 0) {
            const childContainer = document.createElement('div');
            childContainer.className = 'children-container';
            data.children.forEach(child => {
                childContainer.appendChild(createQuestionNode(child, paper, true));
            });
            node.appendChild(childContainer);
        }

        return node;
    }

    function createSDSubsection(label, markdown, className) {
        const div = document.createElement('div');
        div.className = `sd-subsection ${className}`;
        
        const labelDiv = document.createElement('div');
        labelDiv.className = 'sd-label';
        labelDiv.textContent = label;
        
        const bodyDiv = document.createElement('div');
        bodyDiv.className = 'sd-body prose';
        bodyDiv.innerHTML = renderMarkdown(markdown);
        
        div.append(labelDiv, bodyDiv);
        return div;
    }

    function renderMarkdown(text) {
        if (!md) return text; // Fallback
        return md.render(text || "");
    }

    /**
     * NAVIGATION
     */
    function renderNavigation(paper) {
        // Collect flat list of items
        const items = [];
        
        const traverse = (nodes, depth = 0) => {
            nodes.forEach(q => {
                items.push({ id: q.id, depth: depth });
                if (q.children) traverse(q.children, depth + 1);
            });
        };

        const buildList = (container) => {
            container.innerHTML = '';
            
            if (paper.sections) {
                paper.sections.forEach((sec, idx) => {
                    // Section Label (only if present)
                    if (sec.label && sec.label.trim()) {
                        const secLabel = document.createElement('li');
                        secLabel.className = 'nav-section-label';
                        secLabel.textContent = sec.label;
                        container.appendChild(secLabel);
                    }
                    // Section Items
                    const secItems = [];
                    traverse(sec.questions);
                    // Add items immediately (traverse pushed to local closure scope? No, traverse pushes to 'items' array which we must reset)
                    // Let's refactor traverse to return items or handle per section
                    const currentSecItems = [];
                    const localTraverse = (nodes, depth=0) => {
                        nodes.forEach(q => {
                            currentSecItems.push({id: q.id, depth});
                            if(q.children) localTraverse(q.children, depth+1);
                        });
                    };
                    localTraverse(sec.questions);
                    
                    currentSecItems.forEach(item => appendNavItem(container, item));
                });
            } else if (paper.questions) {
                const flatItems = [];
                const localTraverse = (nodes, depth=0) => {
                    nodes.forEach(q => {
                        flatItems.push({id: q.id, depth});
                        if(q.children) localTraverse(q.children, depth+1);
                    });
                };
                localTraverse(paper.questions);
                flatItems.forEach(item => appendNavItem(container, item));
            }
        };

        buildList(document.getElementById('desktopNavList'));
        buildList(document.getElementById('mobileNavList'));
        
        setupScrollSpy();
    }

    function appendNavItem(container, item) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.className = `nav-item ${item.depth > 0 ? 'is-child' : ''}`;
        a.textContent = item.id;
        a.dataset.targetId = `q-${item.id}`;
        
        a.addEventListener('click', (e) => {
            e.preventDefault();
            const target = document.getElementById(a.dataset.targetId);
            if (target) {
                // Smooth scroll with offset for sticky header
                const headerOffset = 80;
                const elementPosition = target.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
                
                window.scrollTo({
                    top: offsetPosition,
                    behavior: "smooth"
                });
                
                // Close mobile drawer if open
                closeDrawer();
            }
        });
        
        li.appendChild(a);
        container.appendChild(li);
    }

    /**
     * INTERACTIONS & OBSERVERS
     */
    function setupInteractions() {
        // Mobile Drawer
        const jumpBtn = document.getElementById('mobileJumpBtn');
        const drawer = document.getElementById('drawer');
        const overlay = document.getElementById('drawerOverlay');
        const closeBtn = document.getElementById('drawerCloseBtn');

        const openDrawer = () => {
            drawer.classList.add('open');
            overlay.classList.add('open');
            document.body.style.overflow = 'hidden'; // Lock body scroll
        };

        const closeDrawer = () => {
            drawer.classList.remove('open');
            overlay.classList.remove('open');
            document.body.style.overflow = '';
        };

        jumpBtn.addEventListener('click', openDrawer);
        closeBtn.addEventListener('click', closeDrawer);
        overlay.addEventListener('click', closeDrawer);
        window.closeDrawer = closeDrawer; // Expose for nav click
    }

    function setupScrollSpy() {
        // Simple IntersectionObserver for Active State
        const observerOptions = {
            root: null,
            rootMargin: '-10% 0px -80% 0px', // Active zone near top
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id;
                    // Update Active Class
                    document.querySelectorAll('.nav-item').forEach(nav => {
                        nav.classList.toggle('active', nav.dataset.targetId === id);
                    });
                }
            });
        }, observerOptions);

        document.querySelectorAll('.question-node').forEach(node => {
            observer.observe(node);
        });
    }

</script>
</body>
</html>
