<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"ABC","indexWithinVariant":"248","totalWithinVariant":"320","hueFamily":"cyan","intensityMode":"deep_theme","timestamp":"2026-01-07T21:11:19.838Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;ABC&quot;,&quot;indexWithinVariant&quot;:&quot;248&quot;,&quot;totalWithinVariant&quot;:&quot;320&quot;,&quot;hueFamily&quot;:&quot;cyan&quot;,&quot;intensityMode&quot;:&quot;deep_theme&quot;,&quot;timestamp&quot;:&quot;2026-01-07T21:11:19.838Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer</title>
    
    <!-- KaTeX CSS (No SRI/Integrity per Stage 6) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- Markdown-it -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
    
    <!-- KaTeX JS (No SRI/Integrity per Stage 6) -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        /* =========================================
           COLORLAB C: DEEP THEME (CYAN) - LIGHT ONLY
           Hue: ~210 (Cyan/Blue range)
           Intensity Mode: deep_theme
           ========================================= */
        :root {
            /* Palette Definition (OKLCH) */
            /* Hue = 210 */
            
            /* Major Surfaces (Must be chromatic and distinguishable) */
            /* Page: L[0.92..0.98], C[0.08..0.16] */
            --c-page-bg: oklch(0.94 0.10 210);
            
            /* Frame: L[0.90..0.96], C[0.08..0.16] */
            --c-frame-bg: oklch(0.92 0.10 210);
            
            /* Paper: L[0.94..0.99], C[0.06..0.14] */
            --c-paper-bg: oklch(0.97 0.08 210);

            /* Text (High legibility, mostly neutral) */
            /* Primary: L[0.15..0.25], C<=0.015 */
            --c-text-primary: oklch(0.20 0.015 210);
            /* Secondary: L[0.25..0.40], C<=0.020 */
            --c-text-secondary: oklch(0.35 0.02 210);
            
            /* Accent (Link, Focus, Nav Marker) */
            /* L[0.45..0.65], C[0.16..0.26] */
            --c-accent: oklch(0.55 0.20 210);

            /* Wash Surfaces (Solution Details) */
            /* C[0.05..0.10] */
            --c-wash-solution: oklch(0.93 0.06 210); 
            
            /* Hairlines/Dividers */
            /* C<=0.02 */
            --c-divider: oklch(0.85 0.02 210);

            /* Spacing Units */
            --sp-xs: 4px;
            --sp-sm: 8px;
            --sp-md: 16px;
            --sp-lg: 24px;
            --sp-xl: 32px;
            --sp-xxl: 48px;
            
            /* Typography */
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-base: 16px;
            --line-height-base: 1.5;
            --font-size-sm: 14px;
        }

        /* =========================================
           RESET & BASE
           ========================================= */
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-family);
            background-color: var(--c-page-bg);
            color: var(--c-text-primary);
            font-size: var(--font-size-base);
            line-height: var(--line-height-base);
            -webkit-font-smoothing: antialiased;
            overflow-y: scroll; /* Force scrollbar to prevent shift */
        }
        
        button {
            font-family: inherit;
            border: none;
            background: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            color: inherit;
        }

        a { color: var(--c-accent); text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* Focus styling (Stage 5.5.2) */
        :focus-visible {
            outline: 2px solid var(--c-accent);
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* =========================================
           LAYOUT: SHELL & COLUMNS
           ========================================= */
        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .top-controls-region {
            /* Aligned to frame via max-width wrapper inside */
            padding: var(--sp-md) var(--sp-md);
            background-color: var(--c-page-bg); /* Blend with page */
            border-bottom: 1px solid transparent; /* Placeholder for optional divider */
            z-index: 10;
        }

        .document-frame-shell {
            flex: 1;
            display: flex;
            flex-direction: column; /* Mobile default */
            max-width: 1024px;
            margin: 0 auto;
            background-color: var(--c-frame-bg);
            /* Desktop/Large overrides below */
        }

        /* Desktop Layout */
        @media (min-width: 768px) {
            .document-frame-shell {
                flex-direction: row;
                margin-top: var(--sp-md);
                margin-bottom: var(--sp-md);
                /* Ensure paper mental model: minimal rounding or shadow if desired, but kept flat per instructions */
            }
            
            .nav-column {
                width: 240px;
                flex-shrink: 0;
                position: sticky;
                top: var(--sp-md);
                height: calc(100vh - var(--sp-md) * 2);
                overflow-y: auto;
                /* Hide scrollbar */
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .nav-column::-webkit-scrollbar { display: none; }
            
            .paper-column {
                flex: 1;
                min-width: 0; /* Prevent flex blowout */
                padding-left: var(--sp-xl); /* Gap between nav and paper */
            }
        }

        /* Mobile Layout */
        @media (max-width: 767px) {
            .nav-column { display: none; } /* Drawer used instead */
            .document-frame-shell { background-color: transparent; } /* Use page bg on mobile if needed, or frame bg */
            .paper-column { padding: 0 var(--sp-md); }
        }

        /* =========================================
           CONTROLS
           ========================================= */
        .controls-inner {
            max-width: 1024px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .paper-selector {
            font-size: var(--font-size-sm);
            padding: var(--sp-xs) var(--sp-sm);
            border: 1px solid var(--c-divider);
            border-radius: 4px;
            background: var(--c-paper-bg);
            color: var(--c-text-primary);
        }

        .jump-to-trigger {
            display: none;
            font-size: var(--font-size-sm);
            color: var(--c-accent);
            font-weight: 500;
        }
        @media (max-width: 767px) {
            .jump-to-trigger { display: block; }
        }

        /* =========================================
           NAVIGATION (Desktop & Drawer)
           ========================================= */
        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .nav-section-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--c-text-secondary);
            margin-top: var(--sp-md);
            margin-bottom: var(--sp-xs);
            padding-left: var(--sp-sm); /* Keep left edge alignment logic, but label text needs slight offset to read separate */
            font-weight: 600;
        }
        
        .nav-item {
            display: block;
            padding: 2px 0 2px var(--sp-sm);
            font-size: 13px;
            color: var(--c-text-secondary);
            border-left: 2px solid transparent;
            cursor: pointer;
            transition: color 0.1s, border-color 0.1s;
        }

        .nav-item:hover {
            color: var(--c-text-primary);
            border-left-color: var(--c-divider);
        }

        .nav-item.active {
            color: var(--c-text-primary);
            font-weight: 700;
            border-left-color: var(--c-accent); /* Accent marker allowed in nav */
        }

        /* Hierarchy via type scale (Stage 5.4.5) - Flat left edge */
        .nav-item[data-depth="0"] { font-size: 14px; margin-top: 4px; }
        .nav-item[data-depth="1"] { font-size: 13px; color: var(--c-text-secondary); }
        .nav-item[data-depth="2"] { font-size: 12px; opacity: 0.9; }

        /* Drawer */
        .drawer-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.2);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .drawer-overlay.open { display: block; opacity: 1; }
        
        .drawer {
            position: fixed;
            top: 0; right: 0; bottom: 0;
            width: 280px;
            background: var(--c-frame-bg);
            transform: translateX(100%);
            transition: transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 16px rgba(0,0,0,0.05);
        }
        .drawer.open { transform: translateX(0); }
        
        .drawer-header {
            padding: var(--sp-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--c-divider);
        }
        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--sp-md);
        }

        /* =========================================
           PAPER CONTENT
           ========================================= */
        .paper-surface {
            background-color: var(--c-paper-bg);
            min-height: 80vh;
            padding: var(--sp-xxl) var(--sp-xl);
            /* No shadow, paper is a surface region */
        }
        
        @media (max-width: 767px) {
            .paper-surface { padding: var(--sp-lg) var(--sp-sm); }
        }

        .section-header-block {
            margin-top: var(--sp-xl);
            margin-bottom: var(--sp-lg);
            border-bottom: 1px solid var(--c-divider);
            padding-bottom: var(--sp-xs);
        }
        .section-header-text {
            font-size: 18px;
            font-weight: 700;
            color: var(--c-text-primary);
        }

        /* Question Node */
        .question-node {
            margin-bottom: var(--sp-xl); /* Top level spacing */
        }
        
        .question-node[data-depth="0"] { margin-bottom: var(--sp-xxl); }
        .question-node[data-depth="0"] + .question-node[data-depth="0"] {
            border-top: 1px solid transparent; /* Optional separator slot */
        }

        /* Nesting indentation */
        .children-container {
            margin-top: var(--sp-md);
            padding-left: var(--sp-md); /* Adaptive indentation */
        }
        @media (min-width: 768px) {
            .children-container { padding-left: var(--sp-xl); }
        }

        /* Question Body */
        .question-body {
            display: flex;
            gap: var(--sp-sm);
            margin-bottom: var(--sp-sm);
        }
        .question-id {
            font-weight: 700;
            color: var(--c-text-secondary); /* Secondary importance */
            min-width: 2em;
        }
        .question-prompt {
            flex: 1;
            font-weight: 500; /* Primary anchor */
            color: var(--c-text-primary);
        }

        /* Solution Block */
        .solution-block {
            margin-left: 0; /* Aligns with whole node, logic handles internal spacing */
            /* Indent relative to question body? No, keep left align but use hierarchy */
            padding-top: var(--sp-xs);
        }
        /* Push solution block to align with prompt text (skipping ID)? 
           Design brief says "Question body" includes ID. Solution block is subordinate. 
           Let's keep it simple: indented slightly or flush. Flush works best for responsive.
           We'll rely on spacing.
        */

        /* Answer */
        .answer-region {
            margin-bottom: var(--sp-sm);
            color: var(--c-text-primary);
            font-size: 0.95em;
        }
        .answer-label {
            font-weight: 700;
            font-size: 0.85em;
            text-transform: uppercase;
            color: var(--c-text-secondary);
            margin-right: var(--sp-xs);
        }

        /* Disclosure Control */
        .disclosure-control {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--c-accent); /* Allowed: Text-first disclosure */
            font-size: 14px;
            font-weight: 500;
            margin-bottom: var(--sp-sm);
            user-select: none;
        }
        .disclosure-icon {
            font-size: 10px;
            transition: transform 0.2s;
        }
        .disclosure-control[aria-expanded="true"] .disclosure-icon {
            transform: rotate(180deg);
        }

        /* Solution Details Region */
        .solution-details-region {
            display: none;
            background-color: var(--c-wash-solution); /* Wash surface (Deep theme req: C[0.05..0.10]) */
            padding: var(--sp-md);
            margin-top: var(--sp-xs);
            /* No border radius per "no rounded corners/cards" constraints? 
               Constraint says "No heavy borders... no rounded corners... no framed blocks". 
               Wash is permitted. Square edges fit "paper" model better. */
        }
        .solution-details-region.expanded {
            display: block;
            animation: reveal 0.2s ease-out;
        }
        
        @keyframes reveal {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Subsections */
        .sd-subsection {
            margin-bottom: var(--sp-md);
        }
        .sd-subsection:last-child { margin-bottom: 0; }

        .sd-label {
            font-weight: 700;
            font-size: 12px;
            color: var(--c-text-secondary);
            margin-bottom: var(--sp-xs);
            display: block;
        }
        
        .keep-in-mind-block .sd-label { color: var(--c-text-primary); } /* Slightly stronger */
        
        /* Typography Content */
        .md-content p { margin: 0 0 0.8em 0; }
        .md-content p:last-child { margin-bottom: 0; }
        .md-content ul, .md-content ol { margin: 0 0 0.8em 0; padding-left: 1.5em; }
        .md-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 0.8em 0;
            font-size: 0.9em;
        }
        .md-content th, .md-content td {
            border: 1px solid var(--c-divider);
            padding: 4px 8px;
            text-align: left;
        }

        /* KaTeX Overflow Handling (Invariant) */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding: 0.5em 0;
            /* Hide scrollbar visually but keep functional */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .katex-display::-webkit-scrollbar { display: none; }
        
        /* Display Math Underlay (Permitted Stage 3/5) - Subtle Wash in Working */
        /* Only apply if needed for clarity. Deep theme wash is already present in SD region. 
           Internal math blocks usually don't need extra wash if SD is washed. 
           Stage 5.8.2 says plain display math with standard spacing only. */

        /* Utility */
        .hidden { display: none !important; }
        
        /* Markdown generated images/diagrams */
        .md-content img, .md-content svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: var(--sp-sm) 0;
        }

        /* Loading / Error */
        .status-message {
            padding: var(--sp-xl);
            text-align: center;
            color: var(--c-text-secondary);
            font-weight: 700;
        }

    </style>
</head>
<body>

<div id="app-root" class="app-container">
    <!-- Top Controls -->
    <div class="top-controls-region">
        <div class="controls-inner">
            <select id="paper-selector" class="paper-selector" aria-label="Select paper">
                <option value="" disabled selected>Loading papers...</option>
            </select>
            <button id="jump-to-trigger" class="jump-to-trigger">Jump to</button>
        </div>
    </div>

    <!-- Document Shell -->
    <div class="document-frame-shell">
        
        <!-- Desktop Nav Column -->
        <nav class="nav-column" aria-label="Paper navigation">
            <div id="desktop-nav-content">
                <!-- Injected via JS -->
            </div>
        </nav>

        <!-- Paper Column -->
        <main class="paper-column">
            <div id="paper-region" class="paper-surface">
                <!-- Content injected via JS -->
                <div id="loading-indicator" class="status-message">Loading payload...</div>
            </div>
        </main>
    </div>

    <!-- Mobile Drawer -->
    <div id="drawer-overlay" class="drawer-overlay"></div>
    <div id="drawer" class="drawer" aria-hidden="true">
        <div class="drawer-header">
            <span style="font-weight:700;">Jump to</span>
            <button id="drawer-close" style="padding:8px;">&times;</button>
        </div>
        <div class="drawer-content">
            <div id="drawer-nav-content">
                <!-- Injected via JS -->
            </div>
        </div>
    </div>
</div>

<script>
    // =========================================================
    // STAGE 0: CONSTANTS
    // =========================================================
    const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
    
    // =========================================================
    // APP LOGIC
    // =========================================================
    
    // State
    let payload = null;
    let currentPaperKey = null;
    let currentPaper = null;
    let expandedStates = new Set(); // Stores IDs of questions with expanded details
    let navItems = []; // For intersection observer or scroll spy

    // --- Markdown renderer (authoritative config) ---
    const md = window.markdownit
      ? window.markdownit({
          html: true, // allow inline SVG and other inline HTML in payload Markdown
          linkify: true,
          breaks: false, // MUST stay false: prevents <br> inside $...$ / $$...$$
        })
      : null;

    if (md) {
      // Preserve TeX backslashes: do not let markdown-it escape them before KaTeX runs
      md.inline.ruler.disable(["escape"]);
    }

    // --- Initialization ---
    async function init() {
        try {
            const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
            if (!response.ok) throw new Error("Fetch failed");
            payload = await response.json();
            
            if (!payload.papers || payload.papers.length === 0) {
                throw new Error("No papers");
            }

            renderSelector();
            
            // Select first paper by default
            switchPaper(payload.papers[0].key);

        } catch (err) {
            console.error(err);
            document.getElementById('paper-region').innerHTML = 
                '<div class="status-message">PAPERS PAYLOAD MISSING</div>';
        }
    }

    // --- Rendering ---

    function renderSelector() {
        const select = document.getElementById('paper-selector');
        select.innerHTML = '';
        payload.papers.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.key;
            opt.textContent = p.label || p.key;
            select.appendChild(opt);
        });
        select.addEventListener('change', (e) => switchPaper(e.target.value));
    }

    function switchPaper(key) {
        currentPaperKey = key;
        currentPaper = payload.papers.find(p => p.key === key);
        
        if (!currentPaper) return;

        // Reset state
        expandedStates.clear();
        
        // Handle defaults
        const expandAll = currentPaper.defaults?.expandedAll !== false; // Default true unless false
        if (expandAll) {
            // We need to traverse and add all IDs to expandedStates? 
            // Or just check if state is missing?
            // Easier: we'll check logic in render: if !set.has(id) => return default.
            // But if user toggles, we add/delete.
            // Let's rely on a helper `isExpanded(id)`
        }

        renderPaperContent();
        renderNavigation();
        
        // Reset scroll
        window.scrollTo(0, 0);
        document.querySelector('.nav-column').scrollTop = 0;
    }

    function isExpanded(id) {
        // If explicitly tracked in Set, use that.
        // If not tracked, fallback to paper default.
        // But interaction requires precise tracking.
        // Let's populate Set initially if expandAll is true, OR handle "not present = default".
        // Strategy: "Not present" = use paper default.
        // User click -> sets explicit value in a separate Map?
        // Let's simpler: On paper load, we don't know IDs easily without traverse.
        // We will read "data-expanded" from DOM or just default true.
        // Actually, let's just assume default is TRUE.
        // If user collapses, we add to `collapsedStates` set.
        return !collapsedStates.has(id);
    }
    
    // We'll track COLLAPSED states because default is expanded.
    // If paper default is collapsed, we track EXPANDED states.
    let collapsedStates = new Set();
    let explicitExpandedStates = new Set(); // Used if default is collapsed

    function isNodeExpanded(id) {
        const defaultExpanded = currentPaper.defaults?.expandedAll !== false;
        if (defaultExpanded) {
            return !collapsedStates.has(id);
        } else {
            return explicitExpandedStates.has(id);
        }
    }

    function toggleNode(id) {
        const defaultExpanded = currentPaper.defaults?.expandedAll !== false;
        if (defaultExpanded) {
            if (collapsedStates.has(id)) collapsedStates.delete(id);
            else collapsedStates.add(id);
        } else {
            if (explicitExpandedStates.has(id)) explicitExpandedStates.delete(id);
            else explicitExpandedStates.add(id);
        }
        
        // Re-render only the toggle button and the region visibility for this node?
        // Full re-render is safer for prototype, but might lose scroll position if not careful.
        // DOM manipulation is better.
        updateNodeDOM(id);
    }

    function updateNodeDOM(id) {
        const expanded = isNodeExpanded(id);
        const region = document.getElementById(`sd-${id}`);
        const btn = document.getElementById(`btn-${id}`);
        const textSpan = btn.querySelector('.btn-text');
        
        if (region) {
            if (expanded) {
                region.classList.add('expanded');
                btn.setAttribute('aria-expanded', 'true');
                textSpan.textContent = 'Hide working';
            } else {
                region.classList.remove('expanded');
                btn.setAttribute('aria-expanded', 'false');
                textSpan.textContent = 'Show working';
            }
        }
    }

    function renderPaperContent() {
        // Reset toggle tracking
        collapsedStates.clear();
        explicitExpandedStates.clear();

        const container = document.getElementById('paper-region');
        container.innerHTML = '';

        if (currentPaper.sections) {
            currentPaper.sections.forEach(sec => {
                if (sec.label && sec.label.trim() !== "") {
                    const headerBlock = document.createElement('div');
                    headerBlock.className = 'section-header-block';
                    headerBlock.innerHTML = `<div class="section-header-text">${sanitize(sec.label)}</div>`;
                    container.appendChild(headerBlock);
                }
                const list = document.createElement('div');
                list.className = 'question-list';
                sec.questions.forEach(q => {
                    list.appendChild(renderQuestionNode(q, 0));
                });
                container.appendChild(list);
            });
        } else if (currentPaper.questions) {
            const list = document.createElement('div');
            list.className = 'question-list';
            currentPaper.questions.forEach(q => {
                list.appendChild(renderQuestionNode(q, 0));
            });
            container.appendChild(list);
        }

        // Render Math
        renderMathInElement(container, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ],
            throwOnError: false
        });
    }

    function renderQuestionNode(node, depth) {
        // Safe ID for DOM
        const safeId = node.id.replace(/[^a-zA-Z0-9-_]/g, '_');
        
        const wrapper = document.createElement('div');
        wrapper.className = 'question-node';
        wrapper.setAttribute('data-depth', depth);
        wrapper.id = `q-node-${safeId}`; // Anchor for nav

        // Question Body
        const body = document.createElement('div');
        body.className = 'question-body';
        body.innerHTML = `
            <div class="question-id">${node.id}</div>
            <div class="question-prompt md-content">${renderMarkdown(node.question)}</div>
        `;
        wrapper.appendChild(body);

        // Solution Block
        if (node.solutionBlock) {
            const sb = node.solutionBlock;
            const blockDiv = document.createElement('div');
            blockDiv.className = 'solution-block';

            // Answer
            if (sb.answer) {
                const ansDiv = document.createElement('div');
                ansDiv.className = 'answer-region';
                ansDiv.innerHTML = `<span class="answer-label">Answer</span> <span class="md-content inline-md">${renderMarkdown(sb.answer)}</span>`;
                blockDiv.appendChild(ansDiv);
            }

            // Solution Details
            if (sb.solutionDetails) {
                const sd = sb.solutionDetails;
                const expanded = isNodeExpanded(safeId);
                
                // Toggle
                const btn = document.createElement('button');
                btn.id = `btn-${safeId}`;
                btn.className = 'disclosure-control';
                btn.setAttribute('aria-expanded', expanded);
                btn.innerHTML = `<span class="btn-text">${expanded ? 'Hide working' : 'Show working'}</span> <span class="disclosure-icon">â–¼</span>`;
                btn.onclick = () => toggleNode(safeId);
                blockDiv.appendChild(btn);

                // Region
                const region = document.createElement('div');
                region.id = `sd-${safeId}`;
                region.className = `solution-details-region ${expanded ? 'expanded' : ''}`;
                
                // Subsections order: Keep in mind, Formulas, Working, Alt Working
                if (sd.keepInMind) {
                    region.innerHTML += `
                        <div class="sd-subsection keep-in-mind-block">
                            <span class="sd-label">Keep in mind</span>
                            <div class="md-content">${renderMarkdown(sd.keepInMind)}</div>
                        </div>`;
                }
                if (sd.formulasUsed) {
                    region.innerHTML += `
                        <div class="sd-subsection">
                            <span class="sd-label">Formulas used</span>
                            <div class="md-content">${renderMarkdown(sd.formulasUsed)}</div>
                        </div>`;
                }
                if (sd.working) {
                    region.innerHTML += `
                        <div class="sd-subsection">
                            <span class="sd-label">Working</span>
                            <div class="md-content">${renderMarkdown(sd.working)}</div>
                        </div>`;
                }
                if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                    sd.alternativeWorking.forEach((alt, idx) => {
                        region.innerHTML += `
                        <div class="sd-subsection">
                            <span class="sd-label">Alternative working</span>
                            <div class="md-content">${renderMarkdown(alt)}</div>
                        </div>`;
                    });
                }
                
                blockDiv.appendChild(region);
            }

            wrapper.appendChild(blockDiv);
        }

        // Children
        if (node.children && node.children.length > 0) {
            const childCont = document.createElement('div');
            childCont.className = 'children-container';
            node.children.forEach(c => {
                childCont.appendChild(renderQuestionNode(c, depth + 1));
            });
            wrapper.appendChild(childCont);
        }

        return wrapper;
    }

    function renderNavigation() {
        const desktopNav = document.getElementById('desktop-nav-content');
        const drawerNav = document.getElementById('drawer-nav-content');
        
        const html = buildNavHTML();
        
        desktopNav.innerHTML = html;
        drawerNav.innerHTML = html;
        
        setupNavInteractions(desktopNav);
        setupNavInteractions(drawerNav);
    }

    function buildNavHTML() {
        let html = '<ul class="nav-list">';
        
        const processList = (list) => {
            list.forEach(q => {
                processNode(q, 0);
            });
        };
        
        const processNode = (node, depth) => {
            const safeId = node.id.replace(/[^a-zA-Z0-9-_]/g, '_');
            html += `<li>
                <a class="nav-item" data-target="q-node-${safeId}" data-depth="${depth}">${node.id}</a>
            </li>`;
            
            if (node.children) {
                node.children.forEach(c => processNode(c, depth + 1));
            }
        };

        if (currentPaper.sections) {
            currentPaper.sections.forEach(sec => {
                if (sec.label && sec.label.trim() !== "") {
                    html += `<li class="nav-section-label">${sanitize(sec.label)}</li>`;
                }
                processList(sec.questions);
            });
        } else if (currentPaper.questions) {
            processList(currentPaper.questions);
        }

        html += '</ul>';
        return html;
    }

    function setupNavInteractions(container) {
        const items = container.querySelectorAll('.nav-item');
        items.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = item.getAttribute('data-target');
                const target = document.getElementById(targetId);
                if (target) {
                    // Offset for sticky controls if needed, though they are usually in sidebar. 
                    // Mobile might need offset.
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    closeDrawer();
                }
            });
        });
    }

    // --- Helpers ---
    function renderMarkdown(text) {
        if (!text) return '';
        if (!md) return text; // Fallback
        return md.render(text);
    }

    function sanitize(str) {
        const temp = document.createElement('div');
        temp.textContent = str;
        return temp.innerHTML;
    }

    // --- Drawer Logic ---
    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('drawer-overlay');
    const jumpBtn = document.getElementById('jump-to-trigger');
    const closeBtn = document.getElementById('drawer-close');

    function openDrawer() {
        drawer.classList.add('open');
        overlay.classList.add('open');
        drawer.setAttribute('aria-hidden', 'false');
    }
    
    function closeDrawer() {
        drawer.classList.remove('open');
        overlay.classList.remove('open');
        drawer.setAttribute('aria-hidden', 'true');
    }

    jumpBtn.addEventListener('click', openDrawer);
    closeBtn.addEventListener('click', closeDrawer);
    overlay.addEventListener('click', closeDrawer);

    // --- Active State (Scroll Spy) ---
    // Simple implementation: find first visible question node
    window.addEventListener('scroll', () => {
        // Debounce or throttle could be good, but simple rAF is fine
        requestAnimationFrame(updateActiveNav);
    });

    function updateActiveNav() {
        // Get all question nodes anchors
        // We can cache this
        const nodes = document.querySelectorAll('.question-node');
        let activeId = null;
        
        for (let i = 0; i < nodes.length; i++) {
            const rect = nodes[i].getBoundingClientRect();
            // If top is within 200px of viewport top
            if (rect.top >= 0 && rect.top < window.innerHeight / 2) {
                activeId = nodes[i].id;
                break;
            }
            // If we passed it but it's still covering most
            if (rect.bottom > 100) {
                activeId = nodes[i].id;
                // keep checking subsequent to find the one starting closest to top
            }
        }
        
        if (activeId) {
            document.querySelectorAll('.nav-item').forEach(el => {
                if (el.getAttribute('data-target') === activeId) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });
        }
    }

    // Start
    init();

</script>
</body>
</html>
