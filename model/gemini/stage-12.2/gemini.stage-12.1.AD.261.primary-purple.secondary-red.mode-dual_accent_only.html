<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AD","indexWithinVariant":"261","totalWithinVariant":"440","hueFamily":"","intensityMode":"","primaryHueFamily":"purple","secondaryHueFamily":"red","dualIntensityMode":"dual_accent_only","timestamp":"2026-01-10T14:16:53.422Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AD&quot;,&quot;indexWithinVariant&quot;:&quot;261&quot;,&quot;totalWithinVariant&quot;:&quot;440&quot;,&quot;hueFamily&quot;:&quot;&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;purple&quot;,&quot;secondaryHueFamily&quot;:&quot;red&quot;,&quot;dualIntensityMode&quot;:&quot;dual_accent_only&quot;,&quot;timestamp&quot;:&quot;2026-01-10T14:16:53.422Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer (Prototype)</title>
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Markdown-it -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
    
    <!-- KaTeX JS -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        /* 
         * COLORLAB D: DUAL-ACCENT PALETTE (QUANTIFIED, LIGHT-ONLY)
         * Mode: dual_accent_only
         * Primary Hue: Blue (~264) - Default
         * Secondary Hue: Amber (~85) - Default
         * 
         * Numeric Constraints:
         * Surfaces C <= 0.015
         * Body Text C <= 0.010
         * Primary Accent C [0.08 .. 0.14]
         * Secondary Accent C [0.06 .. 0.12]
         */
        :root {
            /* Hues */
            --hue-primary: 264;
            --hue-secondary: 85;

            /* Surfaces (Neutral/Low Chroma) */
            --surf-page: oklch(0.985 0.002 var(--hue-primary));
            --surf-frame: oklch(0.985 0.002 var(--hue-primary));
            --surf-paper: oklch(1.0 0 0); /* Pure white or extremely low chroma */
            --surf-wash: oklch(0.97 0.005 var(--hue-primary)); /* Very subtle wash for expanded solutions */
            --surf-nav-hover: oklch(0.96 0.005 var(--hue-primary));

            /* Text (High Legibility, Low Chroma) */
            --text-primary: oklch(0.20 0.005 var(--hue-primary));
            --text-secondary: oklch(0.45 0.01 var(--hue-primary));
            --text-tertiary: oklch(0.60 0.01 var(--hue-primary)); /* Nav mostly */

            /* Accents (Disciplined) */
            --accent-primary: oklch(0.55 0.13 var(--hue-primary)); /* Links, Focus, Disclosure */
            --accent-primary-hover: oklch(0.45 0.13 var(--hue-primary));
            
            --accent-secondary: oklch(0.65 0.11 var(--hue-secondary)); /* Supplementary Role (e.g. Nav Marker) */

            /* Borders / Dividers */
            --border-hairline: oklch(0.92 0.005 var(--hue-primary));
            --border-focus: var(--accent-primary);

            /* Spacing Units */
            --sp-xs: 0.25rem;
            --sp-sm: 0.5rem;
            --sp-md: 1rem;
            --sp-lg: 1.5rem;
            --sp-xl: 2.5rem;
            --sp-xxl: 4rem;

            /* Layout */
            --nav-width: 240px;
            --frame-max-width: 1024px;
        }

        /* Reset & Base */
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--surf-page);
            color: var(--text-primary);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
        }
        button { font-family: inherit; }

        /* Document Shell */
        .doc-shell {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: var(--surf-frame);
        }

        /* Top Controls (Shared Frame Alignment) */
        .top-controls {
            width: 100%;
            max-width: var(--frame-max-width);
            margin: 0 auto;
            padding: var(--sp-md) var(--sp-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* Border not strictly required by grammar, but good for stability */
            border-bottom: 1px solid transparent; 
        }
        
        /* Desktop Layout (Two Columns) */
        .main-frame {
            flex: 1;
            display: flex;
            width: 100%;
            max-width: var(--frame-max-width);
            margin: 0 auto;
            position: relative;
        }

        /* Navigation Rail (Desktop) */
        .nav-rail {
            width: var(--nav-width);
            flex-shrink: 0;
            padding: var(--sp-lg) var(--sp-md) var(--sp-lg) 0;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            /* Hide scrollbar */
            scrollbar-width: none;
            -ms-overflow-style: none;
            display: none; /* Mobile default */
        }
        .nav-rail::-webkit-scrollbar { display: none; }
        
        @media (min-width: 768px) {
            .nav-rail { display: block; }
        }

        /* Mobile Drawer */
        .mobile-drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.2);
            z-index: 40;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .mobile-drawer {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 280px;
            background: var(--surf-frame);
            z-index: 50;
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 12px rgba(0,0,0,0.05);
        }
        .mobile-drawer.open { transform: translateX(0); }
        .mobile-drawer-overlay.open { display: block; opacity: 1; }

        .drawer-header {
            padding: var(--sp-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-hairline);
        }
        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--sp-md);
        }

        /* Navigation List Styling (Flat, Weight Hierarchy) */
        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .nav-section-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            padding: var(--sp-sm) var(--sp-sm);
            margin-top: var(--sp-md);
            pointer-events: none;
        }
        .nav-item {
            display: block;
            padding: var(--sp-xs) var(--sp-sm);
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.875rem;
            border-radius: 4px;
            cursor: pointer;
            transition: color 0.1s, background-color 0.1s;
        }
        .nav-item:hover {
            background-color: var(--surf-nav-hover);
            color: var(--text-primary);
        }
        .nav-item.active {
            color: var(--text-primary);
            font-weight: 600;
            /* Optional accent marker logic for ColorLab D could go here. 
               Using simple weight for baseline safety. */
        }
        /* Hierarchy via Type Scale/Quietness */
        .nav-item[data-depth="0"] { font-size: 0.9rem; }
        .nav-item[data-depth="1"] { font-size: 0.85rem; color: var(--text-tertiary); }
        .nav-item[data-depth="2"] { font-size: 0.8rem; color: var(--text-tertiary); }

        /* Paper Content Region */
        .paper-column {
            flex: 1;
            padding: var(--sp-lg);
            background-color: var(--surf-paper);
            min-height: 100vh;
            /* Ensure containment */
            min-width: 0; 
        }

        /* Questions */
        .question-node {
            margin-bottom: var(--sp-xl); /* Top level spacing */
        }
        .question-node[data-child="true"] {
            margin-bottom: var(--sp-md);
            margin-top: var(--sp-md);
            padding-left: var(--sp-md); /* Indentation for children */
            border-left: 1px solid transparent; /* Placeholder for optional guide */
        }
        
        /* Question Body */
        .q-body {
            margin-bottom: var(--sp-sm);
        }
        .q-identifier {
            font-weight: 600;
            margin-right: var(--sp-sm);
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        .q-prompt {
            display: inline;
            color: var(--text-primary);
            font-weight: 500;
        }
        .q-prompt p { display: inline; } /* Flatten first p */
        
        /* Solution Block */
        .solution-block {
            margin-top: var(--sp-sm);
            padding-left: 0; /* Align with question text visually? No, keep it hierarchical. */
        }
        
        /* Answer */
        .answer-region {
            margin-bottom: var(--sp-sm);
        }
        .answer-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.02em;
            margin-right: var(--sp-sm);
        }
        .answer-content {
            display: inline-block;
        }

        /* Solution Details (Expandable) */
        .solution-details-wrapper {
            /* Container for toggle + content */
        }
        .sd-toggle {
            background: none;
            border: none;
            padding: 0;
            color: var(--accent-primary);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-bottom: var(--sp-sm);
        }
        .sd-toggle:hover {
            color: var(--accent-primary-hover);
            text-decoration: underline;
        }
        .sd-toggle:focus-visible {
            outline: 2px solid var(--border-focus);
            outline-offset: 2px;
            border-radius: 2px;
        }

        .sd-region {
            display: none;
            margin-top: var(--sp-xs);
            padding: var(--sp-md);
            background-color: var(--surf-wash); /* Surface differentiation */
            border-radius: 4px; /* Subtle radius, not card-like */
        }
        .sd-region.expanded {
            display: block;
            animation: reveal 0.2s ease-out;
        }
        @keyframes reveal {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Subsections */
        .sd-subsection {
            margin-bottom: var(--sp-md);
        }
        .sd-subsection:last-child { margin-bottom: 0; }

        .sd-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--sp-xs);
            text-transform: uppercase;
        }
        
        /* Keep in Mind specific */
        .sd-keep-in-mind .sd-body {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        /* Formulas Used */
        .sd-formulas .sd-body {
            font-family: 'Inter', sans-serif;
        }

        /* Working / Alternative Working */
        .sd-working .sd-body, .sd-alt-working .sd-body {
            color: var(--text-secondary); /* Subordinate */
        }
        
        /* Alternative Working Separation */
        .sep-alt-working {
            height: 1px;
            background-color: var(--border-hairline);
            margin: var(--sp-lg) 0;
            border: none;
        }

        /* Markdown & KaTeX Overrides */
        .md-content p { margin-bottom: 0.5em; margin-top: 0; }
        .md-content ul, .md-content ol { margin-top: 0; padding-left: 1.5em; }
        .md-content table {
            border-collapse: collapse;
            width: 100%;
            margin: var(--sp-sm) 0;
            font-size: 0.9em;
        }
        .md-content th, .md-content td {
            border: 1px solid var(--border-hairline);
            padding: var(--sp-xs) var(--sp-sm);
            text-align: left;
        }
        .md-content th { font-weight: 600; }
        
        /* KaTeX Containment Invariant */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0.5em 0;
            max-width: 100%;
            /* Minimal scrollbar */
            scrollbar-width: thin;
            background: transparent; /* Underlay rule: handled by container if needed, inline never */
        }
        .katex-display::-webkit-scrollbar { height: 4px; }
        .katex-display::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }

        /* Typography Utilities */
        .text-sm { font-size: 0.875rem; }
        .font-bold { font-weight: 600; }
        
        /* Controls */
        .paper-select {
            padding: var(--sp-sm);
            border: 1px solid var(--border-hairline);
            border-radius: 4px;
            font-size: 0.9rem;
            background: var(--surf-paper);
            color: var(--text-primary);
        }
        .btn-jump {
            display: block;
            background: none;
            border: 1px solid var(--border-hairline);
            padding: var(--sp-xs) var(--sp-sm);
            border-radius: 4px;
            font-size: 0.875rem;
            cursor: pointer;
            color: var(--accent-primary);
        }
        @media (min-width: 768px) {
            .btn-jump { display: none; }
        }

        /* Error state */
        .error-msg {
            padding: var(--sp-xl);
            text-align: center;
            color: var(--text-secondary);
            font-weight: 600;
        }
    </style>
</head>
<body>

<div id="root">
    <!-- Shell rendered by JS -->
</div>

<script>
    // --- STAGE 0: CONSTANTS ---
    const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
    const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

    // --- Markdown Init ---
    // Rule: html: true, breaks: false, disable escape.
    let md = null;
    if (window.markdownit) {
        md = window.markdownit({
            html: true,
            linkify: true,
            breaks: false
        });
        md.inline.ruler.disable(['escape']);
    }

    // --- State ---
    const state = {
        papers: [],
        currentPaperKey: null,
        expandedMap: new Map(), // questionId -> boolean
        loading: true,
        error: false,
        isMobileDrawerOpen: false
    };

    // --- DOM Elements Ref ---
    const root = document.getElementById('root');

    // --- Initialization ---
    async function init() {
        try {
            const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
            if (!response.ok) throw new Error("Payload missing");
            const data = await response.json();
            
            if (!data.papers || !Array.isArray(data.papers)) throw new Error("Invalid format");
            
            state.papers = data.papers;
            if (state.papers.length > 0) {
                // Load first paper by default
                loadPaper(state.papers[0].key);
            }
            state.loading = false;
            render();
        } catch (e) {
            console.error(e);
            state.loading = false;
            state.error = true;
            render();
        }
    }

    function loadPaper(key) {
        state.currentPaperKey = key;
        const paper = state.papers.find(p => p.key === key);
        if (!paper) return;

        // Reset expanded state based on defaults
        state.expandedMap.clear();
        const defaultExpanded = paper.defaults?.expandedAll !== false;
        
        // Helper to traverse and set default
        const traverse = (nodes) => {
            nodes.forEach(node => {
                if (node.solutionBlock?.solutionDetails) {
                    state.expandedMap.set(node.id, defaultExpanded);
                }
                if (node.children) traverse(node.children);
            });
        };

        if (paper.questions) traverse(paper.questions);
        if (paper.sections) paper.sections.forEach(s => traverse(s.questions));
    }

    function toggleWorking(qId) {
        const current = state.expandedMap.get(qId);
        state.expandedMap.set(qId, !current);
        renderPaperContent(); // Re-render content column only to avoid full layout thrash
    }

    function toggleDrawer() {
        state.isMobileDrawerOpen = !state.isMobileDrawerOpen;
        renderShellComponents();
    }

    function switchPaper(e) {
        loadPaper(e.target.value);
        render();
    }

    function scrollToQuestion(qId) {
        state.isMobileDrawerOpen = false;
        renderShellComponents(); // Close drawer
        const el = document.getElementById(`q-${qId}`);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    // --- Rendering ---

    function render() {
        if (state.error) {
            root.innerHTML = '<div class="error-msg">PAPERS PAYLOAD MISSING</div>';
            return;
        }
        if (state.loading) {
            root.innerHTML = '<div class="top-controls">Loading...</div>';
            return;
        }

        // Only render shell structure once if possible, but for prototype simplicity we rebuild string
        // We will separate shell structure from content injection to maintain scroll if needed, 
        // but simple innerHTML replacement is acceptable for this level.
        
        // Actually, let's create the shell once and update parts.
        if (!document.getElementById('app-shell')) {
            root.innerHTML = `
                <div id="app-shell" class="doc-shell">
                    <div class="top-controls">
                        <select id="paper-select" class="paper-select"></select>
                        <button class="btn-jump" onclick="toggleDrawer()">Jump to</button>
                    </div>
                    <div class="main-frame">
                        <nav id="nav-rail" class="nav-rail"></nav>
                        <div id="mobile-drawer-overlay" class="mobile-drawer-overlay" onclick="toggleDrawer()"></div>
                        <div id="mobile-drawer" class="mobile-drawer">
                            <div class="drawer-header">
                                <span class="font-bold">Jump to</span>
                                <button onclick="toggleDrawer()" style="border:none;background:none;cursor:pointer;font-size:1.2rem;">&times;</button>
                            </div>
                            <div id="drawer-content" class="drawer-content"></div>
                        </div>
                        <main id="paper-column" class="paper-column"></main>
                    </div>
                </div>
            `;
            
            // Bind selector
            document.getElementById('paper-select').addEventListener('change', switchPaper);
            // Global drawer toggle exposed to window for inline onclick
            window.toggleDrawer = toggleDrawer; 
        }

        renderShellComponents();
        renderPaperContent();
    }

    function renderShellComponents() {
        const paper = state.papers.find(p => p.key === state.currentPaperKey);
        
        // Update Selector
        const select = document.getElementById('paper-select');
        select.innerHTML = state.papers.map(p => 
            `<option value="${p.key}" ${p.key === state.currentPaperKey ? 'selected' : ''}>${p.label}</option>`
        ).join('');

        // Build Nav List
        const navHTML = buildNavList(paper);
        document.getElementById('nav-rail').innerHTML = `<ul class="nav-list">${navHTML}</ul>`;
        document.getElementById('drawer-content').innerHTML = `<ul class="nav-list">${navHTML}</ul>`;

        // Drawer State
        const overlay = document.getElementById('mobile-drawer-overlay');
        const drawer = document.getElementById('mobile-drawer');
        if (state.isMobileDrawerOpen) {
            overlay.classList.add('open');
            drawer.classList.add('open');
        } else {
            overlay.classList.remove('open');
            drawer.classList.remove('open');
        }
    }

    function buildNavList(paper) {
        if (!paper) return '';
        let html = '';

        const renderItems = (questions) => {
            let out = '';
            
            const traverse = (nodes, depth) => {
                nodes.forEach(node => {
                    out += `<li>
                        <a class="nav-item" data-depth="${depth}" onclick="scrollToQuestion('${node.id}')">
                            ${node.id}
                        </a>
                    </li>`;
                    if (node.children) traverse(node.children, depth + 1);
                });
            };
            traverse(questions, 0);
            return out;
        };

        if (paper.sections) {
            paper.sections.forEach(sec => {
                if (sec.label && sec.label.trim().length > 0) {
                    html += `<li class="nav-section-label">${sec.label}</li>`;
                }
                html += renderItems(sec.questions);
            });
        } else if (paper.questions) {
            html += renderItems(paper.questions);
        }

        return html;
    }

    function renderPaperContent() {
        const paper = state.papers.find(p => p.key === state.currentPaperKey);
        const container = document.getElementById('paper-column');
        if (!paper) return;

        let html = '';

        const renderNode = (node, depth) => {
            const hasSolutionBlock = !!node.solutionBlock;
            const hasAnswer = hasSolutionBlock && !!node.solutionBlock.answer;
            const hasDetails = hasSolutionBlock && !!node.solutionBlock.solutionDetails;
            const isExpanded = state.expandedMap.get(node.id);

            let nodeHTML = `
                <div class="question-node" id="q-${node.id}" data-child="${depth > 0}">
                    <div class="q-body">
                        <span class="q-identifier">${node.id}</span>
                        <div class="q-prompt md-content">${renderMD(node.question)}</div>
                    </div>
            `;

            if (hasSolutionBlock) {
                nodeHTML += `<div class="solution-block">`;
                
                if (hasAnswer) {
                    nodeHTML += `
                        <div class="answer-region">
                            <span class="answer-label">Answer</span>
                            <div class="answer-content md-content">${renderMD(node.solutionBlock.answer)}</div>
                        </div>
                    `;
                }

                if (hasDetails) {
                    const toggleText = isExpanded ? "Hide working" : "Show working";
                    const chevron = isExpanded ? "▲" : "▼"; 
                    // Using text-first disclosure with simple icon
                    
                    nodeHTML += `
                        <div class="solution-details-wrapper">
                            <button class="sd-toggle" onclick="toggleWorking('${node.id}')">
                                <span>${toggleText}</span>
                                <span style="font-size:0.7em;">${chevron}</span>
                            </button>
                            <div class="sd-region ${isExpanded ? 'expanded' : ''}">
                    `;

                    if (isExpanded) {
                        const sd = node.solutionBlock.solutionDetails;
                        
                        // Keep in mind
                        if (sd.keepInMind) {
                            nodeHTML += `
                                <div class="sd-subsection sd-keep-in-mind">
                                    <div class="sd-label">Keep in mind</div>
                                    <div class="sd-body md-content">${renderMD(sd.keepInMind)}</div>
                                </div>
                            `;
                        }

                        // Formulas used
                        if (sd.formulasUsed) {
                            nodeHTML += `
                                <div class="sd-subsection sd-formulas">
                                    <div class="sd-label">Formulas used</div>
                                    <div class="sd-body md-content">${renderMD(sd.formulasUsed)}</div>
                                </div>
                            `;
                        }

                        // Working
                        if (sd.working) {
                            nodeHTML += `
                                <div class="sd-subsection sd-working">
                                    <div class="sd-label">Working</div>
                                    <div class="sd-body md-content">${renderMD(sd.working)}</div>
                                </div>
                            `;
                        }

                        // Alternative Working
                        if (sd.alternativeWorking) {
                             // Handle array if multiple, or string. Payload v2 implies array likely or string.
                             // Brief says "alternativeWorking: string[] (Markdown; 0+)" in schema section 
                             // but also "string" in other parts. Let's handle array.
                             // Add-on payload schema says: "alternativeWorking: string[] (Markdown; 0+ alternative workings) OPTIONAL"
                             
                             // Checking if it's an array or string just to be safe (JSON can be tricky)
                             const alts = Array.isArray(sd.alternativeWorking) ? sd.alternativeWorking : (sd.alternativeWorking ? [sd.alternativeWorking] : []);
                             
                             alts.forEach(alt => {
                                 nodeHTML += `
                                    <hr class="sep-alt-working"/>
                                    <div class="sd-subsection sd-alt-working">
                                        <div class="sd-label">Alternative working</div>
                                        <div class="sd-body md-content">${renderMD(alt)}</div>
                                    </div>
                                 `;
                             });
                        }
                    }

                    nodeHTML += `</div></div>`; // Close region + wrapper
                }

                nodeHTML += `</div>`; // Close solution-block
            }

            // Recursion for children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    nodeHTML += renderNode(child, depth + 1);
                });
            }

            nodeHTML += `</div>`; // Close question-node
            return nodeHTML;
        };

        if (paper.sections) {
            paper.sections.forEach(sec => {
                if (sec.label && sec.label.trim().length > 0) {
                    html += `<div style="margin-bottom:1rem; font-weight:600; color:var(--text-tertiary); text-transform:uppercase; font-size:0.875rem;">${sec.label}</div>`;
                }
                sec.questions.forEach(q => { html += renderNode(q, 0); });
            });
        } else if (paper.questions) {
            paper.questions.forEach(q => { html += renderNode(q, 0); });
        }

        container.innerHTML = html;

        // Post-render: KaTeX
        renderMathInElement(container, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });
    }

    function renderMD(text) {
        if (!text) return '';
        // If MD failed to load, return raw text
        if (!md) return text;
        return md.render(text);
    }

    // Expose functions globally for HTML event attributes
    window.scrollToQuestion = scrollToQuestion;
    window.toggleWorking = toggleWorking;
    window.switchPaper = switchPaper;

    // Start
    init();

</script>
</body>
</html>
