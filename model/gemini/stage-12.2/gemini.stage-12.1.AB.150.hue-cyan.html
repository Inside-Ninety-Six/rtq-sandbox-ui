<!DOCTYPE html>
<html lang="en" class="light">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"150","totalWithinVariant":"200","hueFamily":"cyan","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T20:01:01.335Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;150&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;cyan&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T20:01:01.335Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Viewer</title>

    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS (CDN) - No integrity as per Stage 6.0.7b -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- KaTeX JS (CDN) - No integrity as per Stage 6.0.7b -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Markdown-it (CDN) - No integrity as per Stage 6.0.7b -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <!-- Lucide Icons (CDN) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* BASELINE RESETS & FONTS */
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8fafc; /* Slate-50 - Page background */
            color: #0f172a; /* Slate-900 - Base text */
            -webkit-font-smoothing: antialiased;
            overflow-y: scroll; /* Force scrollbar to prevent layout shift */
        }

        /* KATEX CONTAINMENT INVARIANT (Stage 6.0.8) */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            -webkit-overflow-scrolling: touch;
            padding-top: 0.25em;
            padding-bottom: 0.25em;
        }
        
        /* INLINE KATEX TRANSPARENCY RULE (Stage 5.8.4) */
        .katex {
            background-color: transparent !important;
        }

        /* HIDE SCROLLBARS FOR NAV (Stage 6.0.9) */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* TYPOGRAPHY HIERARCHY UTILS */
        .prose p { margin-bottom: 0.75em; line-height: 1.6; }
        .prose p:last-child { margin-bottom: 0; }
        
        /* TABLE STYLES (Minimal, structural) */
        table { border-collapse: collapse; width: 100%; margin: 1em 0; font-size: 0.95em; }
        th, td { border: 1px solid #e2e8f0; padding: 0.5em 0.75em; text-align: left; vertical-align: top; }
        th { font-weight: 600; background-color: transparent; }

        /* ACCENT UTILS (ColorLab B - Cyan) */
        .text-accent { color: #0e7490; } /* Cyan-700 */
        .border-accent { border-color: #06b6d4; } /* Cyan-500 */
        .ring-accent:focus-visible { outline: 2px solid #06b6d4; outline-offset: 2px; }

        /* FOCUS VISIBILITY (Stage 5.5.2) */
        :focus-visible { outline: 2px solid #06b6d4; outline-offset: 2px; }

        /* NAV STICKY RAIL */
        .nav-rail {
            position: sticky;
            top: 0;
            max-height: 100vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- TOP CONTROLS REGION -->
    <div class="w-full bg-slate-50 border-b border-slate-200 sticky top-0 z-40" id="top-controls">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-14 flex items-center justify-between">
            <!-- Paper Selector -->
            <div class="flex items-center gap-3">
                <label for="paper-select" class="text-sm font-medium text-slate-500 hidden sm:block">Paper:</label>
                <select id="paper-select" class="bg-white border border-slate-300 text-slate-900 text-sm rounded-md ring-accent focus:ring-accent focus:border-cyan-500 block p-1.5 pr-8 transition-colors">
                    <option>Loading papers...</option>
                </select>
            </div>

            <!-- Mobile "Jump to" Trigger -->
            <button id="mobile-jump-trigger" class="lg:hidden flex items-center gap-2 text-sm font-medium text-slate-600 hover:text-slate-900 ring-accent rounded px-2 py-1 transition-colors">
                <span>Jump to</span>
                <i data-lucide="menu" class="w-4 h-4"></i>
            </button>
        </div>
    </div>

    <!-- DOCUMENT FRAME SHELL -->
    <div class="flex-1 max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8 pt-6 pb-20 relative">
        <div class="lg:grid lg:grid-cols-[200px_1fr] lg:gap-12 xl:gap-16">
            
            <!-- DESKTOP NAV RAIL -->
            <aside class="hidden lg:block nav-rail pr-4 pt-1 pb-10 no-scrollbar" id="desktop-nav">
                <!-- Nav content rendered via JS -->
            </aside>

            <!-- PAPER DOCUMENT COLUMN -->
            <main class="min-w-0" id="paper-content">
                <!-- Paper content rendered via JS -->
                <div class="py-20 text-center text-slate-400">Loading payload...</div>
            </main>

        </div>
    </div>

    <!-- MOBILE DRAWER (Stage 6.0.6) -->
    <div id="drawer-backdrop" class="fixed inset-0 bg-slate-900/20 backdrop-blur-sm z-50 hidden opacity-0 transition-opacity duration-200" aria-hidden="true"></div>
    <div id="drawer-panel" class="fixed inset-y-0 right-0 z-50 w-64 bg-white shadow-xl transform translate-x-full transition-transform duration-300 ease-in-out flex flex-col" aria-hidden="true">
        <div class="flex items-center justify-between p-4 border-b border-slate-100">
            <h2 class="text-base font-semibold text-slate-800">Jump to</h2>
            <button id="drawer-close" class="p-2 text-slate-500 hover:text-slate-700 ring-accent rounded">
                <i data-lucide="x" class="w-5 h-5"></i>
                <span class="sr-only">Close navigation</span>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto p-4 no-scrollbar" id="drawer-nav-content">
            <!-- Mobile nav items rendered via JS -->
        </div>
    </div>

    <script>
        /**
         * STAGE 0: CANONICAL CONSTANTS
         */
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";

        /**
         * STAGE 6: ADD-ONS (ColorLab B - Cyan)
         */
        const RTQ_COLORLAB_FORCE_HUE_FAMILY = "cyan";

        /**
         * RUNTIME STATE
         */
        const state = {
            papers: [],
            currentPaperKey: null,
            expandedNodes: new Set(), // Set of Question IDs
            isDrawerOpen: false,
            activeQuestionId: null // For nav highlighting
        };

        // DOM Elements
        const elPaperSelect = document.getElementById('paper-select');
        const elPaperContent = document.getElementById('paper-content');
        const elDesktopNav = document.getElementById('desktop-nav');
        const elDrawerNav = document.getElementById('drawer-nav-content');
        const elDrawerBackdrop = document.getElementById('drawer-backdrop');
        const elDrawerPanel = document.getElementById('drawer-panel');
        const elMobileJumpTrigger = document.getElementById('mobile-jump-trigger');
        const elDrawerClose = document.getElementById('drawer-close');

        // Markdown-it instance
        let md = null;
        if (window.markdownit) {
            md = window.markdownit({
                html: true,
                linkify: true,
                breaks: false // REQUIRED: prevents <br> in math blocks
            });
            // Disable escape to preserve TeX backslashes (Stage 6 add-on)
            md.inline.ruler.disable(['escape']);
        }

        /**
         * INITIALIZATION
         */
        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Payload missing");
                const data = await response.json();
                
                if (!data.papers || !Array.isArray(data.papers)) throw new Error("Invalid payload");
                
                state.papers = data.papers;
                populatePaperSelector();
                
                // Select first paper by default
                if (state.papers.length > 0) {
                    loadPaper(state.papers[0].key);
                }
            } catch (err) {
                console.error(err);
                renderError();
            }

            setupEventListeners();
        }

        function setupEventListeners() {
            // Paper Switch
            elPaperSelect.addEventListener('change', (e) => {
                loadPaper(e.target.value);
            });

            // Mobile Drawer
            elMobileJumpTrigger.addEventListener('click', openDrawer);
            elDrawerClose.addEventListener('click', closeDrawer);
            elDrawerBackdrop.addEventListener('click', closeDrawer);

            // Intersection Observer for active nav state (Optional polish)
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Just a simple heuristic for active state
                        state.activeQuestionId = entry.target.dataset.qid;
                        updateNavActiveState();
                    }
                });
            }, { rootMargin: '-10% 0px -80% 0px' }); // Trigger near top
            
            // Expose observer to render function
            window.sectionObserver = observer;
        }

        function populatePaperSelector() {
            elPaperSelect.innerHTML = state.papers.map(p => 
                `<option value="${p.key}">${p.label}</option>`
            ).join('');
        }

        function renderError() {
            elPaperContent.innerHTML = `<div class="py-12 text-center text-slate-500 font-medium">PAPERS PAYLOAD MISSING</div>`;
            elPaperSelect.disabled = true;
        }

        /**
         * CORE RENDERING LOGIC
         */
        function loadPaper(paperKey) {
            state.currentPaperKey = paperKey;
            const paper = state.papers.find(p => p.key === paperKey);
            if (!paper) return;

            // Reset state
            state.expandedNodes.clear();
            
            // Handle defaults
            const expandAll = paper.defaults?.expandedAll !== false;

            // Flatten questions for state initialization (recurse)
            const initExpandedState = (nodes) => {
                nodes.forEach(node => {
                    if (node.solutionBlock?.solutionDetails && expandAll) {
                        state.expandedNodes.add(node.id);
                    }
                    if (node.children) initExpandedState(node.children);
                });
            };

            if (paper.sections) {
                paper.sections.forEach(s => initExpandedState(s.questions));
            } else if (paper.questions) {
                initExpandedState(paper.questions);
            }

            // Render
            renderPaperContent(paper);
            renderNavigation(paper);
            
            // Reset scroll
            window.scrollTo(0, 0);
        }

        function renderPaperContent(paper) {
            let html = '';

            // Sectioned vs Flat
            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    // Render Section Header if label exists
                    if (section.label && section.label.trim().length > 0) {
                        html += `
                            <div class="mb-6 mt-10 first:mt-0 border-b border-slate-200 pb-2">
                                <h2 class="text-lg font-semibold text-slate-800">${escapeHtml(section.label)}</h2>
                            </div>
                        `;
                    } else if (idx > 0) {
                         // Structural separator even if no label, if it's a new section block
                         html += `<div class="h-12"></div>`;
                    }
                    
                    html += `<div class="space-y-12">`; // Question List
                    section.questions.forEach(q => {
                        html += renderQuestionNode(q, 0);
                    });
                    html += `</div>`;
                });
            } else if (paper.questions) {
                html += `<div class="space-y-12">`;
                paper.questions.forEach(q => {
                    html += renderQuestionNode(q, 0);
                });
                html += `</div>`;
            }

            elPaperContent.innerHTML = html;

            // Post-render: KaTeX & Icons & Observer
            if (window.renderMathInElement) {
                renderMathInElement(elPaperContent, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true}
                    ],
                    throwOnError: false
                });
            }
            if (window.lucide) lucide.createIcons();
            
            // Re-attach observers
            const questions = document.querySelectorAll('.question-node');
            if (window.sectionObserver) {
                window.sectionObserver.disconnect();
                questions.forEach(q => window.sectionObserver.observe(q));
            }
        }

        // Recursive Question Renderer
        function renderQuestionNode(node, depth) {
            const isTopLevel = depth === 0;
            const hasSolutionBlock = !!node.solutionBlock;
            const hasAnswer = hasSolutionBlock && !!node.solutionBlock.answer;
            const hasSolutionDetails = hasSolutionBlock && !!node.solutionBlock.solutionDetails;
            const isExpanded = state.expandedNodes.has(node.id);

            // Indentation class (Stage 3.E) - Visual subordination via spacing only for children
            // We use padding-left that scales down on mobile to preserve width
            const indentClass = depth > 0 ? 'pl-4 sm:pl-8 border-l-2 border-transparent' : '';
            
            // Separation for children
            const childWrapperClass = depth > 0 ? 'mt-6 space-y-6' : 'mt-8 space-y-8';

            // Question Body (Always visible)
            const questionHtml = renderMarkdown(node.question);

            // Solution Block HTML
            let solutionBlockHtml = '';
            if (hasSolutionBlock) {
                // Answer
                let answerHtml = '';
                if (hasAnswer) {
                    answerHtml = `
                        <div class="mt-4">
                            <span class="text-xs font-bold text-slate-500 uppercase tracking-wide block mb-1">Answer</span>
                            <div class="text-slate-800 prose prose-slate max-w-none">
                                ${renderMarkdown(node.solutionBlock.answer)}
                            </div>
                        </div>
                    `;
                }

                // Solution Details
                let detailsHtml = '';
                if (hasSolutionDetails) {
                    const details = node.solutionBlock.solutionDetails;
                    const expandId = `toggle-${node.id}`;
                    
                    // Disclosure Control
                    const toggleControl = `
                        <button 
                            onclick="toggleSolution('${node.id}')"
                            class="mt-4 flex items-center gap-2 text-sm font-medium text-accent hover:text-cyan-800 transition-colors focus:ring-accent rounded px-1 -ml-1"
                            aria-expanded="${isExpanded}"
                            aria-controls="details-${node.id}"
                        >
                            <span>${isExpanded ? 'Hide working' : 'Show working'}</span>
                            <i data-lucide="chevron-${isExpanded ? 'up' : 'down'}" class="w-4 h-4"></i>
                        </button>
                    `;

                    // Expanded Content
                    let expandedContent = '';
                    if (isExpanded) {
                        // 1. Keep in mind
                        if (details.keepInMind) {
                            expandedContent += `
                                <div class="mb-6">
                                    <div class="flex items-center gap-2 mb-2 text-slate-700">
                                        <i data-lucide="lightbulb" class="w-4 h-4 text-slate-400"></i>
                                        <span class="text-sm font-bold">Keep in mind</span>
                                    </div>
                                    <div class="text-slate-700 text-sm leading-relaxed prose prose-slate prose-sm max-w-none ml-6">
                                        ${renderMarkdown(details.keepInMind)}
                                    </div>
                                </div>
                            `;
                        }

                        // 2. Formulas used
                        if (details.formulasUsed) {
                            expandedContent += `
                                <div class="mb-6">
                                    <h4 class="text-sm font-bold text-slate-500 mb-2">Formulas used</h4>
                                    <div class="text-slate-600 text-sm prose prose-slate prose-sm max-w-none">
                                        ${renderMarkdown(details.formulasUsed)}
                                    </div>
                                </div>
                            `;
                        }

                        // 3. Working (Primary)
                        if (details.working) {
                            expandedContent += `
                                <div class="mb-6">
                                    <h4 class="text-sm font-bold text-slate-500 mb-2">Working</h4>
                                    <div class="text-slate-800 text-base leading-relaxed prose prose-slate max-w-none working-content">
                                        ${renderMarkdown(details.working)}
                                    </div>
                                </div>
                            `;
                        }

                        // 4. Alternative Working
                        if (details.alternativeWorking && Array.isArray(details.alternativeWorking)) {
                            details.alternativeWorking.forEach((alt, idx) => {
                                expandedContent += `
                                    <div class="mt-8 pt-6 border-t border-slate-100">
                                        <h4 class="text-sm font-bold text-slate-500 mb-2">Alternative working</h4>
                                        <div class="text-slate-800 text-base leading-relaxed prose prose-slate max-w-none working-content">
                                            ${renderMarkdown(alt)}
                                        </div>
                                    </div>
                                `;
                            });
                        }

                        // Wrapper for expanded content
                        expandedContent = `
                            <div id="details-${node.id}" class="mt-4 pt-2 animate-in fade-in slide-in-from-top-1 duration-200">
                                ${expandedContent}
                            </div>
                        `;
                    }

                    detailsHtml = toggleControl + expandedContent;
                }

                solutionBlockHtml = `
                    <div class="solution-block pl-0">
                        ${answerHtml}
                        ${detailsHtml}
                    </div>
                `;
            }

            // Recursive Children
            let childrenHtml = '';
            if (node.children && node.children.length > 0) {
                childrenHtml = `
                    <div class="${childWrapperClass}">
                        ${node.children.map(child => renderQuestionNode(child, depth + 1)).join('')}
                    </div>
                `;
            }

            // Top-level styling (Stronger separation) vs Child styling
            const nodeClasses = isTopLevel ? 'question-node scroll-mt-24' : 'question-node scroll-mt-32'; // Scroll margin for sticky header

            return `
                <div id="q-${node.id}" data-qid="${node.id}" class="${nodeClasses} ${indentClass}">
                    <!-- Question Body -->
                    <div class="group">
                        <div class="flex items-baseline gap-3 mb-2">
                            <span class="text-slate-500 font-medium text-sm select-none shrink-0">${node.id}</span>
                            <div class="text-slate-900 font-medium text-lg leading-relaxed prose prose-slate max-w-none flex-1">
                                ${questionHtml}
                            </div>
                        </div>
                    </div>

                    <!-- Supporting Content -->
                    <div class="pl-0 sm:pl-[calc(1rem+0.75rem)]">
                        ${solutionBlockHtml}
                    </div>

                    <!-- Nested Children -->
                    ${childrenHtml}
                </div>
            `;
        }

        function renderNavigation(paper) {
            // Build flat list
            let navHtml = `<nav class="flex flex-col gap-1 pb-10" aria-label="Paper navigation">`;
            
            const renderItem = (node, isSectionLabel = false) => {
                const isActive = state.activeQuestionId === node.id;
                // Hierarchy via quietness/size (Stage 5.4.5)
                // We use nesting level derived from payload, but flat list. 
                // We don't have depth info easily in this flat loop unless we traverse recursively.
                // Let's do a recursive traversal generator.
            };

            const buildNavItems = (nodes, depth = 0) => {
                let html = '';
                nodes.forEach(node => {
                    const isSub = depth > 0;
                    // Styling: Flat left edge. Hierarchy via text size/color.
                    // Top level: Text-slate-600, normal.
                    // Sub: Text-slate-500, small.
                    const baseClasses = "block w-full text-left py-1 px-2 rounded transition-colors duration-150 focus:ring-accent focus:outline-none";
                    const activeClasses = "text-cyan-700 font-bold bg-slate-100/50 border-l-2 border-cyan-500 -ml-[2px]";
                    const inactiveClasses = isSub ? "text-slate-500 text-sm hover:text-slate-800" : "text-slate-600 text-sm hover:text-slate-900";
                    
                    const classes = `${baseClasses} ${state.activeQuestionId === node.id ? activeClasses : inactiveClasses}`;

                    html += `
                        <button 
                            onclick="scrollToQuestion('${node.id}')"
                            class="${classes}"
                            data-nav-qid="${node.id}"
                        >
                            ${node.id}
                        </button>
                    `;
                    
                    if (node.children) {
                        html += buildNavItems(node.children, depth + 1);
                    }
                });
                return html;
            };

            if (paper.sections) {
                paper.sections.forEach(s => {
                    // Section Label (Stage 5.4.6)
                    if (s.label && s.label.trim()) {
                        navHtml += `
                            <div class="mt-4 mb-2 px-2 text-xs font-bold text-slate-400 uppercase tracking-wider select-none">
                                ${escapeHtml(s.label)}
                            </div>
                        `;
                    } else {
                        navHtml += `<div class="mt-2"></div>`;
                    }
                    navHtml += buildNavItems(s.questions);
                });
            } else if (paper.questions) {
                navHtml += buildNavItems(paper.questions);
            }

            navHtml += `</nav>`;

            elDesktopNav.innerHTML = navHtml;
            elDrawerNav.innerHTML = navHtml;
        }

        /**
         * INTERACTIONS
         */
        window.toggleSolution = (questionId) => {
            if (state.expandedNodes.has(questionId)) {
                state.expandedNodes.delete(questionId);
            } else {
                state.expandedNodes.add(questionId);
            }
            
            // Re-render ONLY the specific node to preserve scroll and state of others
            // Ideally we'd patch, but for this prototype, we'll re-render the whole paper 
            // BUT restore scroll position. Wait, re-rendering whole paper is jarring.
            // Let's find the node in the DOM and replace it OR simpler:
            // Just re-render the paper. It's fast enough for a prototype.
            // To prevent jump, we rely on browser scroll anchoring or manually restore.
            
            // BETTER STRATEGY FOR PROTOTYPE:
            // Find the specific DOM element for the solution block and update it.
            // But we have recursive rendering logic.
            // Let's just re-render the whole list.
            const scrollY = window.scrollY;
            renderPaperContent(state.papers.find(p => p.key === state.currentPaperKey));
            renderNavigation(state.papers.find(p => p.key === state.currentPaperKey)); // Re-render nav to sync state if needed
            window.scrollTo(0, scrollY);
        };

        window.scrollToQuestion = (id) => {
            const el = document.getElementById(`q-${id}`);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                state.activeQuestionId = id;
                updateNavActiveState();
                closeDrawer();
            }
        };

        function updateNavActiveState() {
            // Update classes for nav items
            const allNavBtns = document.querySelectorAll('[data-nav-qid]');
            allNavBtns.forEach(btn => {
                const isTarget = btn.dataset.navQid === state.activeQuestionId;
                const baseClasses = "block w-full text-left py-1 px-2 rounded transition-colors duration-150 focus:ring-accent focus:outline-none";
                const activeClasses = "text-cyan-700 font-bold bg-slate-100/50 border-l-2 border-cyan-500 -ml-[2px]";
                // Infer depth from text size check or just reset to generic inactive
                const isSmall = btn.classList.contains('text-sm') && btn.classList.contains('text-slate-500'); 
                // That check is flaky. Let's rely on simple reset.
                // Re-rendering nav is safer to ensure classes are correct.
                // But efficient DOM update:
                
                if (isTarget) {
                    btn.className = `${baseClasses} ${activeClasses}`;
                } else {
                    // Reset to approximate inactive state (simplification)
                    btn.className = `${baseClasses} text-slate-600 text-sm hover:text-slate-900`;
                }
            });
        }

        function openDrawer() {
            state.isDrawerOpen = true;
            elDrawerBackdrop.classList.remove('hidden');
            // Trigger reflow
            void elDrawerBackdrop.offsetWidth;
            elDrawerBackdrop.classList.remove('opacity-0');
            elDrawerPanel.classList.remove('translate-x-full');
            document.body.style.overflow = 'hidden'; // Lock body scroll
        }

        function closeDrawer() {
            state.isDrawerOpen = false;
            elDrawerBackdrop.classList.add('opacity-0');
            elDrawerPanel.classList.add('translate-x-full');
            setTimeout(() => {
                elDrawerBackdrop.classList.add('hidden');
                document.body.style.overflow = '';
            }, 300);
        }

        /**
         * UTILS
         */
        function renderMarkdown(text) {
            if (!text) return '';
            return md ? md.render(text) : text;
        }

        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // START
        init();

    </script>
</body>
</html>
