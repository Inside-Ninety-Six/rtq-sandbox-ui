<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AD","indexWithinVariant":"107","totalWithinVariant":"440","hueFamily":"","intensityMode":"","primaryHueFamily":"teal","secondaryHueFamily":"purple","dualIntensityMode":"dual_high_chroma_surfaces","timestamp":"2026-01-10T06:46:08.093Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AD&quot;,&quot;indexWithinVariant&quot;:&quot;107&quot;,&quot;totalWithinVariant&quot;:&quot;440&quot;,&quot;hueFamily&quot;:&quot;&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;teal&quot;,&quot;secondaryHueFamily&quot;:&quot;purple&quot;,&quot;dualIntensityMode&quot;:&quot;dual_high_chroma_surfaces&quot;,&quot;timestamp&quot;:&quot;2026-01-10T06:46:08.093Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Viewer</title>

    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- TAILWIND -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- MARKDOWN-IT -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>

    <!-- KATEX (No SRI/Integrity) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>

    <style>
        /* --- ColorLab D: Dual-Accent Palette (Mode: dual_high_chroma_surfaces) --- */
        /* Primary Hue: Blue (250), Secondary Hue: Amber (85) */
        :root {
            /* Surfaces: At least two major surfaces C in [0.06..0.12] */
            --c-page: oklch(0.95 0.06 250);
            --c-frame: oklch(0.93 0.07 250);
            /* Remaining surface C in [0.03..0.07] */
            --c-paper: oklch(0.99 0.03 250);
            /* Wash C in [0.05..0.10] */
            --c-wash: oklch(0.94 0.05 250);

            /* Text: Primary C <= 0.015 */
            --c-txt-pri: oklch(0.20 0.01 250);
            --c-txt-sec: oklch(0.45 0.015 250);

            /* Borders */
            --c-hairline: oklch(0.85 0.03 250);

            /* Accents: Primary C [0.12..0.20], Secondary C [0.10..0.18] */
            --c-acc-pri: oklch(0.55 0.18 250); 
            --c-acc-sec: oklch(0.65 0.16 85);

            --font-main: 'Inter', sans-serif;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--c-page);
            color: var(--c-txt-pri);
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden; /* App shell handles scroll */
        }

        /* Utility classes for ColorLab vars */
        .bg-page { background-color: var(--c-page); }
        .bg-frame { background-color: var(--c-frame); }
        .bg-paper { background-color: var(--c-paper); }
        .bg-wash { background-color: var(--c-wash); }
        
        .text-pri { color: var(--c-txt-pri); }
        .text-sec { color: var(--c-txt-sec); }
        .text-acc-pri { color: var(--c-acc-pri); }
        .text-acc-sec { color: var(--c-acc-sec); }

        .border-hairline { border-color: var(--c-hairline); }
        .border-acc-pri { border-color: var(--c-acc-pri); }

        /* Focus Styles */
        :focus-visible {
            outline: 2px solid var(--c-acc-pri);
            outline-offset: 2px;
        }

        /* Scrollbar Hiding for Nav (Stage 3 Add-on) */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* KaTeX Containment (Stage 3 Locked) */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 4px; /* Space for scrollbar if needed */
            margin: 0.5em 0;
            -webkit-overflow-scrolling: touch;
        }
        
        /* Inline math background invariant */
        .katex { background-color: transparent !important; }

        /* Layout Utilities */
        .shell-grid {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100vh;
        }

        /* Markdown Content Styling */
        .md-content p { margin-bottom: 0.75em; line-height: 1.6; }
        .md-content p:last-child { margin-bottom: 0; }
        .md-content ul { list-style-type: disc; padding-left: 1.5em; margin-bottom: 0.75em; }
        .md-content ol { list-style-type: decimal; padding-left: 1.5em; margin-bottom: 0.75em; }
        .md-content table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-bottom: 1em; 
            font-size: 0.95em;
        }
        .md-content th, .md-content td { 
            border: 1px solid var(--c-hairline); 
            padding: 0.5em; 
            text-align: left; 
        }
        .md-content th { font-weight: 600; }
        .md-content img, .md-content svg { max-width: 100%; height: auto; display: block; }

        /* Solution Details Transition */
        .details-enter { opacity: 0; transform: translateY(-5px); }
        .details-enter-active { opacity: 1; transform: translateY(0); transition: opacity 0.2s ease, transform 0.2s ease; }
        
        /* Mobile Drawer */
        .drawer-overlay {
            background-color: rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>

    <!-- APP SHELL -->
    <div id="app" class="shell-grid">
        <!-- TOP CONTROLS AREA -->
        <!-- Aligned to shell gutters via padding logic in render -->
        <header id="top-controls" class="bg-frame border-b border-hairline z-20 flex items-center justify-between px-4 py-3 md:hidden">
            <div id="paper-selector-mobile-mount"></div>
            <button id="mobile-jump-trigger" class="text-acc-pri font-medium text-sm flex items-center gap-1">
                Jump to
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line></svg>
            </button>
        </header>

        <header id="desktop-controls" class="hidden md:flex bg-frame z-20 px-6 py-4 justify-between items-center max-w-7xl mx-auto w-full">
             <div id="paper-selector-desktop-mount" class="w-full"></div>
        </header>

        <!-- DOCUMENT FRAME SHELL -->
        <!-- Desktop: Nav + Paper share 'bg-frame' base surface concept, though layout splits them -->
        <div class="relative w-full max-w-7xl mx-auto md:grid md:grid-cols-[240px_1fr] h-full overflow-hidden bg-frame">
            
            <!-- DESKTOP NAV RAIL -->
            <nav class="hidden md:block h-full overflow-y-auto no-scrollbar py-6 pr-6 pl-4 border-r border-hairline bg-frame sticky top-0">
                <div id="desktop-nav-list"></div>
            </nav>

            <!-- PAPER CONTENT COLUMN -->
            <main id="paper-scroller" class="h-full overflow-y-auto w-full bg-paper relative scroll-smooth">
                <div class="max-w-3xl mx-auto py-8 px-4 md:px-12 min-h-full" id="paper-content">
                    <!-- Dynamic Content -->
                </div>
            </main>

        </div>
    </div>

    <!-- MOBILE DRAWER -->
    <div id="mobile-drawer" class="fixed inset-0 z-50 hidden" aria-hidden="true">
        <div class="drawer-overlay absolute inset-0" id="drawer-backdrop"></div>
        <div class="absolute right-0 top-0 bottom-0 w-64 bg-page shadow-xl flex flex-col transform transition-transform duration-200" id="drawer-panel">
            <div class="flex items-center justify-between p-4 border-b border-hairline bg-frame">
                <h2 class="text-sm font-semibold text-sec uppercase tracking-wide">Jump to</h2>
                <button id="drawer-close" class="text-pri hover:text-acc-pri p-1">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <nav class="flex-1 overflow-y-auto p-4 bg-page no-scrollbar">
                <div id="mobile-nav-list"></div>
            </nav>
        </div>
    </div>

    <!-- JAVASCRIPT -->
    <script>
        // === STAGE 0: CONSTANTS ===
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // === STATE ===
        const state = {
            papers: [],
            currentPaper: null,
            expandedNodes: new Set(), // Set of node IDs
            isDrawerOpen: false
        };

        // === MARKDOWN RENDERER SETUP ===
        // Stage 6: Hardened config
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            breaks: false
        }) : null;

        if (md) {
            md.inline.ruler.disable(['escape']);
        }

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', async () => {
            await loadPayload();
            setupGlobalEvents();
        });

        async function loadPayload() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Payload fetch failed");
                
                const data = await response.json();
                state.papers = data.papers || [];

                if (state.papers.length > 0) {
                    loadPaper(state.papers[0].key);
                } else {
                    renderMissingPayload();
                }
            } catch (err) {
                console.error(err);
                renderMissingPayload();
            }
        }

        function renderMissingPayload() {
            document.getElementById('paper-content').innerHTML = `
                <div class="flex flex-col items-center justify-center h-64 text-sec">
                    <p class="font-medium">PAPERS PAYLOAD MISSING</p>
                </div>
            `;
            document.getElementById('paper-selector-mobile-mount').innerHTML = `<span class="text-sm text-sec">Error</span>`;
            document.getElementById('paper-selector-desktop-mount').innerHTML = `<span class="text-sm text-sec">Error loading payload</span>`;
        }

        function loadPaper(paperKey) {
            const paper = state.papers.find(p => p.key === paperKey);
            if (!paper) return;

            state.currentPaper = paper;
            
            // Set defaults
            state.expandedNodes.clear();
            const startExpanded = paper.defaults?.expandedAll !== false; // Default true unless false
            
            // Helper to recursively set default state if needed
            const initExpanded = (nodes) => {
                nodes.forEach(node => {
                    if (node.solutionBlock?.solutionDetails && startExpanded) {
                        state.expandedNodes.add(node.id);
                    }
                    if (node.children) initExpanded(node.children);
                });
            };

            const allQuestions = paper.sections 
                ? paper.sections.flatMap(s => s.questions) 
                : (paper.questions || []);
            
            initExpanded(allQuestions);

            renderApp();
        }

        function setupGlobalEvents() {
            // Mobile Drawer Logic
            const trigger = document.getElementById('mobile-jump-trigger');
            const drawer = document.getElementById('mobile-drawer');
            const closeBtn = document.getElementById('drawer-close');
            const backdrop = document.getElementById('drawer-backdrop');

            const toggleDrawer = (show) => {
                state.isDrawerOpen = show;
                if (show) {
                    drawer.classList.remove('hidden');
                    // Small delay for transition
                    setTimeout(() => drawer.querySelector('#drawer-panel').classList.remove('translate-x-full'), 10);
                } else {
                    drawer.querySelector('#drawer-panel').classList.add('translate-x-full');
                    setTimeout(() => drawer.classList.add('hidden'), 200);
                }
            };

            trigger.addEventListener('click', () => toggleDrawer(true));
            closeBtn.addEventListener('click', () => toggleDrawer(false));
            backdrop.addEventListener('click', () => toggleDrawer(false));

            // Delegate Nav Clicks
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.nav-item')) {
                    const btn = e.target.closest('.nav-item');
                    const targetId = btn.dataset.target;
                    const el = document.getElementById(`q-${targetId}`);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        if (state.isDrawerOpen) toggleDrawer(false);
                    }
                }
            });
        }

        // === RENDERING ORCHESTRATION ===

        function renderApp() {
            renderSelector();
            renderNavigation();
            renderPaperContent();
            
            // Post-render: Math
            if (window.renderMathInElement) {
                renderMathInElement(document.getElementById('paper-content'), {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        function renderSelector() {
            const options = state.papers.map(p => 
                `<option value="${p.key}" ${p.key === state.currentPaper.key ? 'selected' : ''}>${p.label}</option>`
            ).join('');

            const selectHTML = `
                <div class="relative inline-block w-full max-w-xs">
                    <select id="paper-select-control" class="block w-full pl-3 pr-10 py-2 text-base border-hairline bg-page text-pri focus:outline-none focus:ring-1 focus:ring-acc-pri sm:text-sm rounded shadow-sm appearance-none cursor-pointer transition-colors" onchange="loadPaper(this.value)">
                        ${options}
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-sec">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                </div>
            `;

            document.getElementById('paper-selector-mobile-mount').innerHTML = selectHTML;
            document.getElementById('paper-selector-desktop-mount').innerHTML = selectHTML;
            
            // Re-bind listener since innerHTML replaced elements
            const selects = document.querySelectorAll('#paper-select-control');
            selects.forEach(s => s.addEventListener('change', (e) => loadPaper(e.target.value)));
        }

        function renderNavigation() {
            const paper = state.currentPaper;
            let html = '';

            const renderItem = (q, depth) => {
                // Hierarchy via type scale/weight only (Stage 5.4.5)
                // Depth 0: Normal, Depth 1+: Lighter/Smaller
                const isTop = depth === 0;
                const weightClass = isTop ? 'font-medium text-pri' : 'font-normal text-sec text-sm';
                const opacityClass = isTop ? '' : 'opacity-90';
                
                // Active indication handled via click/scroll observer (optional), 
                // but basic static rendering here.
                return `
                    <button class="nav-item w-full text-left py-1.5 px-0 hover:text-acc-pri focus:outline-none focus:text-acc-pri transition-colors ${weightClass} ${opacityClass}" data-target="${q.id}">
                        ${q.id}
                    </button>
                    ${q.children ? q.children.map(c => renderItem(c, depth + 1)).join('') : ''}
                `;
            };

            if (paper.sections) {
                paper.sections.forEach(sec => {
                    // Section Label (Non-clickable, spacing separator)
                    if (sec.label && sec.label.trim().length > 0) {
                        html += `
                            <div class="mt-4 mb-2 first:mt-0">
                                <span class="text-xs font-semibold text-sec uppercase tracking-wider select-none">${sec.label}</span>
                            </div>
                        `;
                    } else if (html.length > 0) {
                         // Spacing between implicit sections
                         html += `<div class="mt-4"></div>`;
                    }
                    html += sec.questions.map(q => renderItem(q, 0)).join('');
                });
            } else {
                html += (paper.questions || []).map(q => renderItem(q, 0)).join('');
            }

            document.getElementById('desktop-nav-list').innerHTML = html;
            document.getElementById('mobile-nav-list').innerHTML = html;
        }

        function renderPaperContent() {
            const paper = state.currentPaper;
            let html = '';

            if (paper.sections) {
                paper.sections.forEach(sec => {
                    // Section Header
                    if (sec.label && sec.label.trim().length > 0) {
                        html += `
                            <div class="mb-8 pt-4 border-b border-hairline pb-2">
                                <h2 class="text-lg font-semibold text-pri">${sec.label}</h2>
                            </div>
                        `;
                    }
                    html += `<div class="space-y-12">`; // Question list spacing
                    html += sec.questions.map(q => renderQuestionNode(q, 0)).join('');
                    html += `</div>`;
                    // Spacing between sections
                    html += `<div class="h-16"></div>`; 
                });
            } else {
                html += `<div class="space-y-12">`;
                html += (paper.questions || []).map(q => renderQuestionNode(q, 0)).join('');
                html += `</div>`;
            }

            document.getElementById('paper-content').innerHTML = html;
        }

        function renderQuestionNode(node, depth) {
            // Stage 3: Question Node Structure
            // Question Body -> Solution Block -> Children
            // Spacing gets tighter with depth.
            
            const isTopLevel = depth === 0;
            const containerClass = isTopLevel ? 'question-node relative' : 'question-node mt-6 relative pl-0'; 
            // Note: Indentation via padding removed for mobile per requirements, 
            // but Stage 3 allows "SPC__CHILD_INDENTATION (optional; spacing-only)".
            // We'll keep indentation minimal or zero on mobile, slight on desktop?
            // "indentation may adapt by viewport... must not create boxed layouts".
            // Let's us simple left border transparent or margin for visual hierarchy if needed, 
            // but strict text alignment is safer. We'll use a small left margin for children.
            
            const childIndent = depth > 0 ? 'ml-4 md:ml-6 border-l-2 border-transparent hover:border-hairline transition-colors pl-4' : '';

            // ID + Question
            const questionHtml = md ? md.render(node.question || '') : node.question;
            
            // Solution Block
            let solutionBlockHtml = '';
            if (node.solutionBlock) {
                solutionBlockHtml = renderSolutionBlock(node);
            }

            // Children
            let childrenHtml = '';
            if (node.children && node.children.length > 0) {
                childrenHtml = `
                    <div class="children-container mt-4">
                        ${node.children.map(c => renderQuestionNode(c, depth + 1)).join('')}
                    </div>
                `;
            }

            return `
                <div id="q-${node.id}" class="${containerClass} ${childIndent}">
                    <!-- Question Body -->
                    <div class="question-body mb-4">
                        <div class="flex items-baseline gap-3">
                            <span class="text-sec font-semibold text-sm select-none shrink-0" aria-hidden="true">${node.id}</span>
                            <div class="md-content text-pri text-lg leading-relaxed flex-1">
                                ${questionHtml}
                            </div>
                        </div>
                    </div>

                    <!-- Solution Block (Optional) -->
                    ${solutionBlockHtml}

                    <!-- Recursive Children -->
                    ${childrenHtml}
                </div>
            `;
        }

        function renderSolutionBlock(node) {
            const block = node.solutionBlock;
            if (!block) return '';

            const hasAnswer = !!block.answer;
            const hasDetails = !!block.solutionDetails;
            
            // If neither, render nothing
            if (!hasAnswer && !hasDetails) return '';

            let html = `<div class="solution-block mt-3 ml-0 md:ml-8 lg:ml-8 border-l border-hairline pl-4 py-1">`;

            // Answer (Visible by default if present)
            if (hasAnswer) {
                const answerContent = md ? md.render(block.answer) : block.answer;
                html += `
                    <div class="answer-section mb-3">
                        <span class="text-xs font-bold text-sec uppercase tracking-wide block mb-1">Answer</span>
                        <div class="md-content text-pri font-medium">
                            ${answerContent}
                        </div>
                    </div>
                `;
            }

            // Solution Details (Disclosure)
            if (hasDetails) {
                const isExpanded = state.expandedNodes.has(node.id);
                const btnText = isExpanded ? 'Hide working' : 'Show working';
                const chevronRot = isExpanded ? 'rotate-180' : '';
                
                // Disclosure Control
                html += `
                    <button onclick="toggleDetails('${node.id}')" class="group flex items-center gap-2 text-sm font-medium text-acc-pri hover:text-pri transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-acc-pri rounded px-1 -ml-1 py-1">
                        <span>${btnText}</span>
                        <svg class="w-4 h-4 transform transition-transform duration-200 ${chevronRot}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                `;

                if (isExpanded) {
                    html += `
                        <div class="solution-details mt-4 bg-wash rounded-sm p-4 md:p-5 details-enter-active">
                            ${renderSolutionDetailsContent(block.solutionDetails)}
                        </div>
                    `;
                }
            }

            html += `</div>`;
            return html;
        }

        function renderSolutionDetailsContent(details) {
            // Internal Grammar: Keep in mind -> Formulas -> Working -> Alt
            let html = '';

            // Keep in mind
            if (details.keepInMind) {
                html += `
                    <div class="mb-6">
                        <div class="flex items-center gap-2 mb-2 text-sec">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            <span class="text-sm font-bold uppercase tracking-wide">Keep in mind</span>
                        </div>
                        <div class="md-content text-pri text-sm">
                            ${md ? md.render(details.keepInMind) : details.keepInMind}
                        </div>
                    </div>
                `;
            }

            // Formulas used
            if (details.formulasUsed) {
                html += `
                    <div class="mb-6">
                        <span class="text-sm font-bold text-sec uppercase tracking-wide block mb-2">Formulas used</span>
                        <div class="md-content text-pri text-sm opacity-90">
                            ${md ? md.render(details.formulasUsed) : details.formulasUsed}
                        </div>
                    </div>
                `;
            }

            // Working
            if (details.working) {
                html += `
                    <div class="mb-6">
                        <span class="text-sm font-bold text-sec uppercase tracking-wide block mb-2">Working</span>
                        <div class="md-content text-pri">
                            ${md ? md.render(details.working) : details.working}
                        </div>
                    </div>
                `;
            }

            // Alternative Working
            if (details.alternativeWorking && Array.isArray(details.alternativeWorking)) {
                details.alternativeWorking.forEach((alt, idx) => {
                    html += `
                        <div class="mt-8 pt-6 border-t border-hairline">
                            <span class="text-sm font-bold text-acc-sec uppercase tracking-wide block mb-2">Alternative working</span>
                            <div class="md-content text-pri">
                                ${md ? md.render(alt) : alt}
                            </div>
                        </div>
                    `;
                });
            }

            return html;
        }

        // Global function for onclick
        window.toggleDetails = (nodeId) => {
            if (state.expandedNodes.has(nodeId)) {
                state.expandedNodes.delete(nodeId);
            } else {
                state.expandedNodes.add(nodeId);
            }
            
            // Re-render efficiently? For prototype, re-render whole paper is acceptable 
            // but might lose scroll position if logic isn't careful. 
            // Better: Find the container, re-render just that block?
            // Given "Stress Test Harness" scope, full re-render is safest for correctness,
            // but let's try to maintain scroll.
            // Actually, HTML replacement destroys scroll of elements inside if they had internal scroll,
            // but page scroll stays unless height changes drastically above viewport.
            // Since we are expanding/collapsing, height changes.
            // Let's re-render.
            
            const scrollPos = document.getElementById('paper-scroller').scrollTop;
            renderPaperContent();
            
            // Re-run MathJax
            if (window.renderMathInElement) {
                renderMathInElement(document.getElementById('paper-content'), {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        };
        
        // Export loadPaper for global select
        window.loadPaper = loadPaper;

    </script>
</body>
</html>
