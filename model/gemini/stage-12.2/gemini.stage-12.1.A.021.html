<!DOCTYPE html>
<html lang="en" class="antialiased">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"A","indexWithinVariant":"21","totalWithinVariant":"50","hueFamily":"","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T12:07:53.074Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;A&quot;,&quot;indexWithinVariant&quot;:&quot;21&quot;,&quot;totalWithinVariant&quot;:&quot;50&quot;,&quot;hueFamily&quot;:&quot;&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T12:07:53.074Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer</title>

    <!-- 1. Tailwind CSS (Script for prototyping) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        // ColorLab A: Using Slate for neutral calm, Indigo for restrained accent
                        neutral: {
                            50: '#f8fafc',
                            100: '#f1f5f9',
                            200: '#e2e8f0',
                            300: '#cbd5e1',
                            400: '#94a3b8',
                            500: '#64748b',
                            600: '#475569',
                            700: '#334155',
                            800: '#1e293b',
                            900: '#0f172a',
                        },
                        accent: {
                            600: '#4f46e5', // Indigo-600
                            700: '#4338ca', // Indigo-700
                        }
                    }
                }
            }
        }
    </script>

    <!-- 2. KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- 3. Markdown-it -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <style>
        /* CSS Reset & Base */
        body {
            background-color: #ffffff;
            color: #0f172a; /* Slate-900 */
        }

        /* Scrollbar Hiding for Nav */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* KaTeX Containment Invariant */
        /* Prevent page horizontal scroll, allow math block scroll */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 0.5em; /* Space for scrollbar */
            -webkit-overflow-scrolling: touch;
        }
        
        /* KaTeX Inline Background Rule: Transparent */
        .katex {
            background-color: transparent !important;
        }

        /* Table Styling (Minimal / Structural) */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.95em;
        }
        th, td {
            border: 1px solid #e2e8f0; /* Slate-200 */
            padding: 0.5rem 0.75rem;
            text-align: left;
            vertical-align: top;
        }
        th {
            font-weight: 600;
            background-color: transparent; 
        }

        /* Focus Styles */
        :focus-visible {
            outline: 2px solid #4f46e5; /* Accent-600 */
            outline-offset: 2px;
        }

        /* Typography Hierarchy helpers */
        .prose p { margin-bottom: 0.75em; line-height: 1.6; }
        .prose p:last-child { margin-bottom: 0; }
        
        /* Navigation Sticky behavior on Desktop */
        @media (min-width: 1024px) {
            .nav-sticky {
                position: sticky;
                top: 0;
                height: 100vh;
            }
        }

        /* Mobile Drawer Transitions */
        .drawer-overlay {
            transition: opacity 0.2s ease-in-out;
        }
        .drawer-content {
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
    </style>
</head>
<body>

    <!-- Stage 3 Canonical Layout Grammar Shell -->
    <div id="app" class="min-h-screen flex flex-col lg:flex-row max-w-[1400px] mx-auto bg-white relative">
        
        <!-- Mobile Header (Top Controls for small screens) -->
        <header class="lg:hidden sticky top-0 z-40 bg-white border-b border-neutral-200 px-4 py-3 flex items-center justify-between">
            <div id="mobile-paper-selector-mount">
                <!-- Mobile Paper Selector Mount -->
            </div>
            <button id="mobile-jump-to-trigger" class="text-sm font-medium text-accent-600 hover:text-accent-700 flex items-center gap-1">
                Jump to
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
            </button>
        </header>

        <!-- Navigation Rail (Desktop) / Drawer content (Mobile) -->
        <!-- Logic will handle moving/cloning or simply having two views. 
             For simplicity in this harness, we render desktop nav and mobile drawer logic separately. -->

        <!-- Desktop Navigation Column -->
        <aside class="hidden lg:block w-64 flex-shrink-0 nav-sticky border-r border-transparent pr-4 pl-4 pt-8 pb-8 overflow-y-auto no-scrollbar" aria-label="Document navigation">
            <div class="mb-8">
                <!-- Desktop Paper Selector -->
                <div id="desktop-paper-selector-mount"></div>
            </div>
            <nav id="desktop-nav-list" class="space-y-1">
                <!-- Nav Items Injected Here -->
            </nav>
        </aside>

        <!-- Mobile Drawer (Initially Hidden) -->
        <div id="mobile-drawer" class="fixed inset-0 z-50 hidden" aria-modal="true" role="dialog">
            <!-- Scrim -->
            <div id="mobile-drawer-scrim" class="absolute inset-0 bg-neutral-900/50 opacity-0 drawer-overlay"></div>
            <!-- Drawer Content -->
            <div id="mobile-drawer-panel" class="absolute right-0 top-0 bottom-0 w-80 bg-white shadow-xl transform translate-x-full drawer-content flex flex-col">
                <div class="p-4 border-b border-neutral-200 flex justify-between items-center bg-white">
                    <h2 class="text-lg font-semibold text-neutral-900">Jump to</h2>
                    <button id="mobile-drawer-close" class="text-neutral-500 hover:text-neutral-900 p-2">
                        <span class="sr-only">Close navigation</span>
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <nav id="mobile-nav-list" class="flex-1 overflow-y-auto p-4 space-y-1">
                    <!-- Mobile Nav Items Injected Here -->
                </nav>
            </div>
        </div>

        <!-- Paper Document Column -->
        <main class="flex-1 min-w-0 px-4 py-6 lg:py-12 lg:px-12">
            <!-- Failure Message Mount -->
            <div id="error-message" class="hidden text-center py-20">
                <p class="text-lg font-bold text-red-600">PAPERS PAYLOAD MISSING</p>
            </div>

            <!-- Content Mount -->
            <div id="paper-content" class="max-w-3xl mx-auto space-y-16 lg:space-y-24">
                <!-- Questions Injected Here -->
            </div>
        </main>

    </div>

    <!-- Main Application Logic -->
    <script>
        // --- STAGE 0: CONSTANTS ---
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // --- GLOBAL STATE ---
        const state = {
            papers: [],
            currentPaper: null,
            expandedWorkings: {}, // questionId -> boolean
            markdown: null, // markdown-it instance
        };

        // --- MARKDOWN INIT (Stage 6 Add-on) ---
        // Configure markdown-it with html:true, breaks:false, escape disabled
        if (window.markdownit) {
            state.markdown = window.markdownit({
                html: true,       // Enable inline SVG passthrough
                linkify: true,
                breaks: false,    // MUST be false to prevent <br> in math
                typographer: true
            });
            // Disable escape rule to preserve TeX backslashes
            state.markdown.inline.ruler.disable(['escape']);
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            try {
                // Fetch Payload
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Fetch failed");
                const payload = await response.json();
                
                if (!payload || !payload.papers || !Array.isArray(payload.papers)) {
                    throw new Error("Invalid payload schema");
                }

                state.papers = payload.papers;
                
                // Mount Selectors
                renderPaperSelectors();
                
                // Init events
                setupMobileDrawer();

                // Select first paper by default
                if (state.papers.length > 0) {
                    selectPaper(state.papers[0].key);
                }

            } catch (err) {
                console.error("Initialization Error:", err);
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('paper-content').innerHTML = ''; // Clear content
            }
        }

        // --- CORE LOGIC ---

        function selectPaper(paperKey) {
            const paper = state.papers.find(p => p.key === paperKey);
            if (!paper) return;

            state.currentPaper = paper;
            
            // Set defaults
            const defaultExpanded = paper.defaults?.expandedAll !== false; // Default true unless explicitly false
            state.expandedWorkings = {}; // Reset state. 
            // In a real app we might traverse and set all keys, but we can treat 'undefined' as default.

            // Re-render
            updatePaperSelectorsUI();
            renderNavigation(paper);
            renderPaperContent(paper);
            
            // Trigger KaTeX Render
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });

            // Reset Scroll
            window.scrollTo(0, 0);
        }

        function toggleWorking(questionId) {
            const defaults = state.currentPaper.defaults?.expandedAll !== false;
            const currentState = state.expandedWorkings[questionId] !== undefined 
                ? state.expandedWorkings[questionId] 
                : defaults;
            
            state.expandedWorkings[questionId] = !currentState;
            
            // Re-render only the specific question's solution block would be optimized,
            // but for this prototype, re-rendering the whole paper is safer to keep ID linkage correct.
            // A better way for pure vanilla without re-render is DOM manipulation.
            
            const contentEl = document.getElementById(`solution-details-${questionId}`);
            const btnTextEl = document.getElementById(`toggle-text-${questionId}`);
            const btnIconEl = document.getElementById(`toggle-icon-${questionId}`);
            
            const isExpanded = state.expandedWorkings[questionId];

            if (contentEl) {
                if (isExpanded) {
                    contentEl.classList.remove('hidden');
                } else {
                    contentEl.classList.add('hidden');
                }
            }
            
            if (btnTextEl) {
                btnTextEl.textContent = isExpanded ? 'Hide working' : 'Show working';
            }
            
            if (btnIconEl) {
                btnIconEl.style.transform = isExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
            }
        }

        // --- RENDERING: SELECTORS ---

        function renderPaperSelectors() {
            const options = state.papers.map(p => `<option value="${p.key}">${p.label}</option>`).join('');
            const selectHTML = `
                <label for="paper-select" class="sr-only">Select Paper</label>
                <select id="paper-select" class="block w-full rounded-md border-neutral-300 py-2 pl-3 pr-10 text-base focus:border-accent-600 focus:outline-none focus:ring-accent-600 sm:text-sm border bg-white">
                    ${options}
                </select>
            `;

            // Render Desktop
            const desktopMount = document.getElementById('desktop-paper-selector-mount');
            desktopMount.innerHTML = selectHTML;
            const dSelect = desktopMount.querySelector('select');
            dSelect.addEventListener('change', (e) => selectPaper(e.target.value));

            // Render Mobile (Clone)
            const mobileMount = document.getElementById('mobile-paper-selector-mount');
            mobileMount.innerHTML = selectHTML.replace('id="paper-select"', 'id="paper-select-mobile"');
            const mSelect = mobileMount.querySelector('select');
            mSelect.addEventListener('change', (e) => selectPaper(e.target.value));
        }

        function updatePaperSelectorsUI() {
            const val = state.currentPaper.key;
            const dSelect = document.querySelector('#desktop-paper-selector-mount select');
            const mSelect = document.querySelector('#mobile-paper-selector-mount select');
            if (dSelect) dSelect.value = val;
            if (mSelect) mSelect.value = val;
        }

        // --- RENDERING: NAVIGATION ---

        function renderNavigation(paper) {
            // Flatten the structure for navigation
            // If paper has sections, render section headers. If not, just questions.
            // Questions ID only. Visual hierarchy via class.
            
            let html = '';

            if (paper.sections) {
                paper.sections.forEach((section, index) => {
                    const hasLabel = section.label && section.label.trim().length > 0;
                    
                    if (hasLabel) {
                        // Section Separator
                        if (index > 0) html += `<div class="h-4"></div>`; // Spacing between sections
                        html += `
                            <div class="px-2 py-1 text-xs font-semibold text-neutral-400 uppercase tracking-wider select-none">
                                ${section.label}
                            </div>
                        `;
                    }
                    
                    // Questions in section
                    section.questions.forEach(q => {
                        html += buildNavNodesRecursive(q, 0);
                    });
                });
            } else if (paper.questions) {
                // Flat paper
                paper.questions.forEach(q => {
                    html += buildNavNodesRecursive(q, 0);
                });
            }

            document.getElementById('desktop-nav-list').innerHTML = html;
            document.getElementById('mobile-nav-list').innerHTML = html;

            // Setup smooth scroll listeners
            setupNavClicks();
        }

        function buildNavNodesRecursive(question, depth) {
            let html = '';
            
            // Render current node
            // Hierarchy cue: Sub-questions get quieter/smaller, but flat alignment (no indentation)
            // Stage 5.4.5: Flat list. Hierarchy via type scale only.
            
            const isTopLevel = depth === 0;
            const baseClasses = "group flex items-center w-full px-2 py-1.5 text-left rounded-md transition-colors duration-150 focus:outline-none focus-visible:ring-2 focus-visible:ring-accent-600";
            
            // Typographic scale for hierarchy
            const typeClasses = isTopLevel 
                ? "text-sm font-medium text-neutral-600 hover:text-neutral-900 hover:bg-neutral-100" 
                : "text-xs font-normal text-neutral-500 hover:text-neutral-900 hover:bg-neutral-50";

            // Active indicator logic (simplified for prototype: click sets active style temporarily)
            
            html += `
                <button data-target="q-${question.id}" class="${baseClasses} ${typeClasses}">
                    <span class="truncate">${question.id}</span>
                </button>
            `;

            // Children
            if (question.children && question.children.length > 0) {
                question.children.forEach(child => {
                    html += buildNavNodesRecursive(child, depth + 1);
                });
            }

            return html;
        }

        function setupNavClicks() {
            const handleNavClick = (e) => {
                const btn = e.target.closest('button[data-target]');
                if (!btn) return;
                
                const targetId = btn.getAttribute('data-target');
                const targetEl = document.getElementById(targetId);
                
                if (targetEl) {
                    // Smooth scroll
                    targetEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    // Close mobile drawer if open
                    closeMobileDrawer();

                    // Optional: Flash active state on nav item (skip for simplicity)
                }
            };

            document.getElementById('desktop-nav-list').onclick = handleNavClick;
            document.getElementById('mobile-nav-list').onclick = handleNavClick;
        }

        // --- RENDERING: PAPER CONTENT ---

        function renderPaperContent(paper) {
            const container = document.getElementById('paper-content');
            let html = '';

            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    // Section Header (Stage 3 structure)
                    if (section.label && section.label.trim().length > 0) {
                        html += `
                            <div class="mb-8 pt-4 border-b border-neutral-200 pb-2">
                                <h2 class="text-xl font-bold text-neutral-900">${section.label}</h2>
                            </div>
                        `;
                    } else if (idx > 0) {
                        // Spacing if no label but distinct section block
                        html += `<div class="h-12"></div>`;
                    }
                    
                    html += `<div class="space-y-16 lg:space-y-24">`;
                    section.questions.forEach(q => {
                        html += renderQuestionNode(q, 0, paper.defaults);
                    });
                    html += `</div>`;
                });
            } else if (paper.questions) {
                html += `<div class="space-y-16 lg:space-y-24">`;
                paper.questions.forEach(q => {
                    html += renderQuestionNode(q, 0, paper.defaults);
                });
                html += `</div>`;
            }

            container.innerHTML = html;
            
            // Bind Toggle Events
            container.querySelectorAll('.toggle-working-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = e.currentTarget.getAttribute('data-id');
                    toggleWorking(id);
                });
            });
        }

        function renderQuestionNode(node, depth, defaults) {
            // Stage 3 & 5 Semantics
            
            // Parse Markdown content
            const questionHtml = state.markdown ? state.markdown.render(node.question || '') : (node.question || '');
            
            // --- 1. Question Body ---
            // ID + Prompt.
            // Spacing gets tighter for children.
            
            const isTopLevel = depth === 0;
            const nodeMargin = isTopLevel ? "mb-0" : "mt-8"; // Top margin for children
            const indentClass = depth > 0 ? "pl-4 lg:pl-8 border-l border-neutral-100" : "";
            
            let html = `
                <div id="q-${node.id}" class="question-node ${nodeMargin} ${indentClass} group scroll-mt-24">
            `;

            // Question Prompt Row
            // Flex row: ID on left (or inline), Prompt next.
            // Stage 4.2 Hierarchy: Question Text > Identifier.
            // We'll place Identifier above or beside. Design brief says "Question body: question identifier + question prompt".
            
            html += `
                <div class="flex flex-col sm:flex-row gap-2 sm:gap-4 mb-4">
                    <div class="flex-shrink-0 w-12 sm:w-16">
                        <span class="text-neutral-500 font-semibold text-lg sm:text-xl select-none">${node.id}</span>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="prose text-neutral-900 text-lg leading-relaxed max-w-none">
                            ${questionHtml}
                        </div>
                    </div>
                </div>
            `;

            // --- 2. Solution Block (Optional) ---
            if (node.solutionBlock) {
                const sb = node.solutionBlock;
                const hasAnswer = sb.answer && sb.answer.trim().length > 0;
                const hasDetails = sb.solutionDetails && (
                    sb.solutionDetails.working || 
                    sb.solutionDetails.alternativeWorking ||
                    sb.solutionDetails.keepInMind ||
                    sb.solutionDetails.formulasUsed
                );

                if (hasAnswer || hasDetails) {
                    html += `<div class="ml-0 sm:ml-16 mt-4 space-y-4">`; // Indent to align with prompt text

                    // A. Answer
                    if (hasAnswer) {
                        const answerHtml = state.markdown ? state.markdown.render(sb.answer) : sb.answer;
                        html += `
                            <div class="flex flex-col sm:flex-row gap-2 sm:gap-4 items-baseline">
                                <span class="text-sm font-bold text-neutral-500 uppercase tracking-wide flex-shrink-0 w-20">Answer</span>
                                <div class="prose text-neutral-900 font-medium">
                                    ${answerHtml}
                                </div>
                            </div>
                        `;
                    }

                    // B. Solution Details Disclosure
                    if (hasDetails) {
                        const isExpandedDefault = defaults?.expandedAll !== false;
                        // State check logic handled in toggle function, but initial render needs correct state
                        // We use the state object or default.
                        const isExpanded = state.expandedWorkings[node.id] !== undefined 
                            ? state.expandedWorkings[node.id] 
                            : isExpandedDefault;

                        const btnText = isExpanded ? "Hide working" : "Show working";
                        const iconRot = isExpanded ? "rotate(180deg)" : "rotate(0deg)";
                        const contentHidden = isExpanded ? "" : "hidden";

                        // Disclosure Control
                        html += `
                            <div class="pt-2">
                                <button type="button" class="toggle-working-btn inline-flex items-center gap-2 text-accent-600 hover:text-accent-700 font-medium text-sm transition-colors focus:outline-none focus-visible:underline" data-id="${node.id}">
                                    <span id="toggle-text-${node.id}">${btnText}</span>
                                    <svg id="toggle-icon-${node.id}" class="w-4 h-4 transition-transform duration-200" style="transform: ${iconRot}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                </button>
                            </div>
                        `;

                        // Solution Details Region
                        // Stage 5.9: Subsections ordering: Keep in Mind -> Formulas -> Working -> Alt
                        // Stage 5.3: Surface differentiation allowed but quiet. We use a very subtle wash.
                        
                        html += `
                            <div id="solution-details-${node.id}" class="${contentHidden} mt-4 relative">
                                <div class="bg-neutral-50 rounded-lg p-4 sm:p-6 border border-neutral-100 text-base">
                        `;

                        const sd = sb.solutionDetails;

                        // 1. Keep in mind
                        if (sd.keepInMind) {
                            const kimHtml = state.markdown ? state.markdown.render(sd.keepInMind) : sd.keepInMind;
                            html += `
                                <div class="mb-6">
                                    <h4 class="text-xs font-bold text-neutral-500 uppercase tracking-wider mb-2 flex items-center gap-2">
                                        <svg class="w-4 h-4 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                        Keep in mind
                                    </h4>
                                    <div class="prose text-neutral-700 text-sm">
                                        ${kimHtml}
                                    </div>
                                </div>
                            `;
                        }

                        // 2. Formulas used
                        if (sd.formulasUsed) {
                            const formHtml = state.markdown ? state.markdown.render(sd.formulasUsed) : sd.formulasUsed;
                            html += `
                                <div class="mb-6">
                                    <h4 class="text-xs font-bold text-neutral-500 uppercase tracking-wider mb-2">Formulas used</h4>
                                    <div class="prose text-neutral-600 text-sm">
                                        ${formHtml}
                                    </div>
                                </div>
                            `;
                        }

                        // 3. Working (Primary)
                        if (sd.working) {
                            const workHtml = state.markdown ? state.markdown.render(sd.working) : sd.working;
                            // Add separator if previous sections existed? Spacing handles it.
                            html += `
                                <div class="mb-6 last:mb-0">
                                    <h4 class="text-xs font-bold text-neutral-500 uppercase tracking-wider mb-3">Working</h4>
                                    <div class="prose text-neutral-800 working-content">
                                        ${workHtml}
                                    </div>
                                </div>
                            `;
                        }

                        // 4. Alternative Working
                        if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                            sd.alternativeWorking.forEach((alt, i) => {
                                const altHtml = state.markdown ? state.markdown.render(alt) : alt;
                                // Stage 5.8.7: Clearly demarcated.
                                html += `
                                    <div class="mt-8 pt-6 border-t border-neutral-200">
                                        <h4 class="text-xs font-bold text-neutral-500 uppercase tracking-wider mb-3">Alternative Working ${sd.alternativeWorking.length > 1 ? i+1 : ''}</h4>
                                        <div class="prose text-neutral-800 working-content">
                                            ${altHtml}
                                        </div>
                                    </div>
                                `;
                            });
                        }

                        html += `
                                </div>
                            </div>
                        `;
                    } // end details
                    
                    html += `</div>`; // end solution block wrapper
                }
            }

            // --- 3. Children ---
            if (node.children && node.children.length > 0) {
                html += `<div class="mt-2">`; // Container for children
                node.children.forEach(child => {
                    html += renderQuestionNode(child, depth + 1, defaults);
                });
                html += `</div>`;
            }

            html += `</div>`; // Close Node
            return html;
        }


        // --- MOBILE DRAWER UTILS ---

        function setupMobileDrawer() {
            const trigger = document.getElementById('mobile-jump-to-trigger');
            const drawer = document.getElementById('mobile-drawer');
            const closeBtn = document.getElementById('mobile-drawer-close');
            const scrim = document.getElementById('mobile-drawer-scrim');
            const panel = document.getElementById('mobile-drawer-panel');

            function open() {
                drawer.classList.remove('hidden');
                // Force reflow for transition
                void drawer.offsetWidth;
                scrim.classList.remove('opacity-0');
                panel.classList.remove('translate-x-full');
                document.body.style.overflow = 'hidden'; // Lock scroll
            }

            function close() {
                scrim.classList.add('opacity-0');
                panel.classList.add('translate-x-full');
                setTimeout(() => {
                    drawer.classList.add('hidden');
                    document.body.style.overflow = '';
                }, 300); // Match transition duration
            }

            trigger.addEventListener('click', open);
            closeBtn.addEventListener('click', close);
            scrim.addEventListener('click', close);

            // Expose close globally for nav clicks
            window.closeMobileDrawer = close;
        }

    </script>
</body>
</html>
