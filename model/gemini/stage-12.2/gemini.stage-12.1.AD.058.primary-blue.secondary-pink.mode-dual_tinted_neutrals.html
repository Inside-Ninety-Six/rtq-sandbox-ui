<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AD","indexWithinVariant":"58","totalWithinVariant":"440","hueFamily":"","intensityMode":"","primaryHueFamily":"blue","secondaryHueFamily":"pink","dualIntensityMode":"dual_tinted_neutrals","timestamp":"2026-01-10T04:40:09.858Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AD&quot;,&quot;indexWithinVariant&quot;:&quot;58&quot;,&quot;totalWithinVariant&quot;:&quot;440&quot;,&quot;hueFamily&quot;:&quot;&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;blue&quot;,&quot;secondaryHueFamily&quot;:&quot;pink&quot;,&quot;dualIntensityMode&quot;:&quot;dual_tinted_neutrals&quot;,&quot;timestamp&quot;:&quot;2026-01-10T04:40:09.858Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer</title>

    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS (CDN - No Integrity) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Markdown-it (CDN - No Integrity) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
    
    <!-- KaTeX JS (CDN - No Integrity) -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- ColorLab D Configuration (Mode 2: dual_tinted_neutrals | Blue/Amber) -->
    <style>
        :root {
            /* 
               ColorLab D - Mode 2: dual_tinted_neutrals 
               Primary Hue: Blue (260)
               Secondary Hue: Amber (85)
            */
            
            /* Surfaces (C 0.015 - 0.035) */
            --c-page-bg: oklch(0.97 0.02 260);
            --c-frame-bg: oklch(0.99 0.015 260);
            --c-wash: oklch(0.96 0.03 260); /* Solution details wash */
            
            /* Text (Near neutral, C <= 0.012) */
            --c-text-primary: oklch(0.20 0.01 260);
            --c-text-secondary: oklch(0.45 0.012 260);
            --c-text-tertiary: oklch(0.60 0.01 260);

            /* Dividers/Lines */
            --c-hairline: oklch(0.90 0.02 260);

            /* Accents */
            /* Primary (Link/Focus/Active) - Mode 2 requires C [0.10 .. 0.16] */
            --c-accent-primary: oklch(0.55 0.14 260); 
            
            /* Secondary (Supplementary role) - Mode 2 requires C [0.08 .. 0.14] */
            --c-accent-secondary: oklch(0.65 0.12 85);

            /* Focus Ring */
            --c-focus-ring: var(--c-accent-primary);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--c-page-bg);
            color: var(--c-text-primary);
            line-height: 1.6;
        }

        /* Scrollbar hiding utilities */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* KaTeX Containment Invariant */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 4px; /* Space for scrollbar if needed */
        }
        
        /* Markdown Content Styling */
        .md-content p {
            margin-bottom: 0.75em;
        }
        .md-content p:last-child {
            margin-bottom: 0;
        }
        .md-content ul {
            list-style-type: disc;
            padding-left: 1.5em;
            margin-bottom: 0.75em;
        }
        .md-content ol {
            list-style-type: decimal;
            padding-left: 1.5em;
            margin-bottom: 0.75em;
        }
        .md-content table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
            font-size: 0.95em;
        }
        .md-content th, .md-content td {
            border: 1px solid var(--c-hairline);
            padding: 0.5em;
            text-align: left;
        }
        .md-content th {
            font-weight: 600;
        }
        
        /* Focus Styles */
        *:focus-visible {
            outline: 2px solid var(--c-focus-ring);
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* Utility */
        .interactive-text:hover {
            text-decoration: underline;
            text-decoration-color: var(--c-accent-primary);
        }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col items-center">

    <!-- Top Controls Region -->
    <div id="top-controls-region" class="w-full max-w-6xl px-4 md:px-8 py-4 flex items-center justify-between shrink-0 z-20">
        <!-- Paper Selector placeholder -->
        <div id="paper-selector-container" class="flex-1">
            <!-- Injected by JS -->
        </div>
        
        <!-- Mobile Jump To Trigger -->
        <div class="md:hidden ml-4">
            <button id="mobile-nav-trigger" class="text-sm font-medium px-3 py-1.5 rounded hover:bg-black/5 transition-colors" style="color: var(--c-accent-primary)">
                Jump to
            </button>
        </div>
    </div>

    <!-- Document Frame Shell -->
    <div id="document-frame" class="w-full max-w-6xl flex-1 flex flex-col md:flex-row relative">
        
        <!-- Desktop Navigation Rail (Sticky) -->
        <aside id="desktop-nav" class="hidden md:block w-48 shrink-0 relative mr-8">
            <div class="sticky top-4 max-h-[calc(100vh-2rem)] overflow-y-auto no-scrollbar py-2">
                <nav id="nav-list-desktop" class="space-y-1">
                    <!-- Injected by JS -->
                </nav>
            </div>
        </aside>

        <!-- Paper Document Column -->
        <main id="paper-content" class="flex-1 pb-32 min-w-0" style="background-color: var(--c-frame-bg);">
            <!-- Content Injected by JS -->
            <div id="content-loading" class="p-8 text-center text-sm" style="color: var(--c-text-secondary)">Loading paper...</div>
        </main>

    </div>

    <!-- Mobile Navigation Drawer -->
    <div id="mobile-drawer-backdrop" class="fixed inset-0 bg-black/20 z-40 hidden transition-opacity opacity-0" aria-hidden="true"></div>
    <div id="mobile-drawer" class="fixed inset-y-0 right-0 w-64 bg-[var(--c-frame-bg)] z-50 transform translate-x-full transition-transform duration-200 shadow-xl flex flex-col" aria-hidden="true">
        <div class="p-4 border-b border-[var(--c-hairline)] flex justify-between items-center">
            <h2 class="font-semibold text-sm">Jump to</h2>
            <button id="mobile-drawer-close" class="p-2 hover:bg-black/5 rounded">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
        <nav id="nav-list-mobile" class="flex-1 overflow-y-auto p-4 space-y-1">
            <!-- Injected by JS -->
        </nav>
    </div>

    <!-- Logic -->
    <script>
        // --- STAGE 0: CONSTANTS ---
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // --- STATE ---
        let appState = {
            papers: [],
            currentPaperKey: null,
            expandedNodes: new Set(), // Set of Question IDs
            isMobileDrawerOpen: false,
            payload: null,
            activeObserver: null
        };

        // --- MARKDOWN SETUP (Stage 6 Config) ---
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            breaks: false // Critical: prevents <br> in math blocks
        }) : null;

        if (md) {
            md.inline.ruler.disable(['escape']);
        }

        // --- DOM ELEMENTS ---
        const els = {
            paperSelectorContainer: document.getElementById('paper-selector-container'),
            navListDesktop: document.getElementById('nav-list-desktop'),
            navListMobile: document.getElementById('nav-list-mobile'),
            paperContent: document.getElementById('paper-content'),
            mobileNavTrigger: document.getElementById('mobile-nav-trigger'),
            mobileDrawerBackdrop: document.getElementById('mobile-drawer-backdrop'),
            mobileDrawer: document.getElementById('mobile-drawer'),
            mobileDrawerClose: document.getElementById('mobile-drawer-close'),
        };

        // --- INIT ---
        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Payload not found");
                const data = await response.json();
                appState.payload = data;
                appState.papers = data.papers || [];
                
                if (appState.papers.length === 0) {
                    renderError("No papers found in payload.");
                    return;
                }

                renderPaperSelector();
                loadPaper(appState.papers[0].key);
                setupMobileNav();
                setupScrollObserver();

            } catch (e) {
                console.error(e);
                renderError("PAPERS PAYLOAD MISSING");
            }
        }

        function renderError(msg) {
            els.paperContent.innerHTML = `<div class="p-12 text-center font-medium" style="color: var(--c-text-secondary)">${msg}</div>`;
            els.paperSelectorContainer.innerHTML = '';
        }

        // --- PAPER LOADING ---
        function loadPaper(key) {
            const paper = appState.papers.find(p => p.key === key);
            if (!paper) return;

            appState.currentPaperKey = key;
            appState.expandedNodes.clear();

            // Handle defaults
            const expandAll = paper.defaults?.expandedAll !== false; // Default true unless explicitly false

            // Flatten questions to set initial state if needed, but logic handles default in render
            // Re-render
            renderPaperContent(paper, expandAll);
            renderNavigation(paper);
            
            // Update selector UI
            const selector = document.getElementById('paper-select');
            if (selector) selector.value = key;

            // Scroll to top
            window.scrollTo(0, 0);
        }

        // --- RENDERING CORE ---
        function renderPaperSelector() {
            if (appState.papers.length === 0) return;
            
            const select = document.createElement('select');
            select.id = 'paper-select';
            select.className = "text-sm font-medium bg-transparent border-none focus:ring-0 cursor-pointer pr-8 py-1.5 outline-none";
            select.style.color = "var(--c-text-primary)";
            
            appState.papers.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.key;
                opt.textContent = p.label;
                select.appendChild(opt);
            });

            select.addEventListener('change', (e) => loadPaper(e.target.value));
            
            els.paperSelectorContainer.innerHTML = '';
            // Wrap in a label for semantics
            const label = document.createElement('label');
            label.className = "flex items-center gap-2";
            const prefix = document.createElement('span');
            prefix.textContent = "Paper:";
            prefix.className = "text-sm";
            prefix.style.color = "var(--c-text-secondary)";
            
            label.appendChild(prefix);
            label.appendChild(select);
            els.paperSelectorContainer.appendChild(label);
        }

        function renderPaperContent(paper, defaultExpanded) {
            els.paperContent.innerHTML = ''; // Clear

            const container = document.createElement('div');
            container.className = "w-full max-w-3xl px-0 md:px-0 space-y-12"; // Top level spacing

            // Sections or Flat Questions?
            if (paper.sections && paper.sections.length > 0) {
                paper.sections.forEach((section, idx) => {
                    const sectionBlock = document.createElement('div');
                    
                    // Render section header only if label exists
                    if (section.label && section.label.trim().length > 0) {
                        const header = document.createElement('div');
                        header.className = "mb-8 pt-4 pb-2 border-b";
                        header.style.borderColor = "var(--c-hairline)";
                        header.style.color = "var(--c-text-primary)";
                        header.innerHTML = `<span class="font-semibold text-lg">${escapeHtml(section.label)}</span>`;
                        sectionBlock.appendChild(header);
                    }

                    // Question List
                    const qList = document.createElement('div');
                    qList.className = "space-y-12"; // SPC__TOP_LEVEL_INTER_QUESTION_SPACING
                    section.questions.forEach(q => {
                        qList.appendChild(createQuestionNode(q, 0, defaultExpanded));
                    });
                    sectionBlock.appendChild(qList);
                    
                    container.appendChild(sectionBlock);
                    
                    // Spacer between sections
                    if (idx < paper.sections.length - 1) {
                        const spacer = document.createElement('div');
                        spacer.className = "h-8";
                        container.appendChild(spacer);
                    }
                });
            } else if (paper.questions) {
                const qList = document.createElement('div');
                qList.className = "space-y-12";
                paper.questions.forEach(q => {
                    qList.appendChild(createQuestionNode(q, 0, defaultExpanded));
                });
                container.appendChild(qList);
            }

            els.paperContent.appendChild(container);
            
            // Post-process math
            renderMathInElement(els.paperContent, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false
            });
        }

        function createQuestionNode(node, depth, defaultExpanded) {
            const wrapper = document.createElement('div');
            wrapper.className = "group question-node scroll-mt-24"; // Scroll margin for sticky header
            wrapper.id = `q-${cleanId(node.id)}`;
            
            // Check if solution block exists
            const hasSolutionBlock = !!node.solutionBlock;
            const hasAnswer = hasSolutionBlock && !!node.solutionBlock.answer;
            const hasDetails = hasSolutionBlock && !!node.solutionBlock.solutionDetails;

            // Determine expanded state
            // If explicit state set in appState, use it. Else use default.
            const nodeId = node.id; // Unique ID assumption
            if (!appState.expandedNodes.has(nodeId) && defaultExpanded && hasDetails) {
                appState.expandedNodes.add(nodeId);
            }
            const isExpanded = appState.expandedNodes.has(nodeId);

            // --- 1. Question Body ---
            const body = document.createElement('div');
            body.className = "mb-4";
            
            // Layout: Identifier (left) + Prompt (right) logic? 
            // Design brief says Question Body = Id + Prompt. 
            // We'll stack them or inline them naturally.
            // Let's use a simple flex row for ID + Content to keep ID distinct.
            
            const headerRow = document.createElement('div');
            headerRow.className = "flex gap-3 items-baseline";
            
            const idEl = document.createElement('div');
            idEl.className = "shrink-0 font-semibold select-none";
            idEl.style.color = "var(--c-text-tertiary)";
            idEl.textContent = node.id;
            
            const promptEl = document.createElement('div');
            promptEl.className = "flex-1 md-content text-lg";
            promptEl.style.color = "var(--c-text-primary)";
            promptEl.innerHTML = renderMarkdown(node.question);

            headerRow.appendChild(idEl);
            headerRow.appendChild(promptEl);
            body.appendChild(headerRow);
            wrapper.appendChild(body);

            // --- 2. Solution Block (Optional) ---
            if (hasSolutionBlock) {
                const solutionBlock = document.createElement('div');
                solutionBlock.className = "ml-0 md:ml-8 pl-0 md:pl-4 border-l-2 border-transparent transition-colors duration-200";
                // Only show boundary/spacing if we have content
                
                // --- Answer ---
                if (hasAnswer) {
                    const answerContainer = document.createElement('div');
                    answerContainer.className = "mb-3 flex flex-col sm:flex-row sm:items-baseline gap-2";
                    
                    const label = document.createElement('span');
                    label.className = "text-sm font-bold uppercase tracking-wide shrink-0";
                    label.style.color = "var(--c-text-secondary)";
                    label.textContent = "Answer";
                    
                    const val = document.createElement('div');
                    val.className = "md-content font-medium";
                    val.style.color = "var(--c-text-primary)";
                    val.innerHTML = renderMarkdown(node.solutionBlock.answer);
                    
                    answerContainer.appendChild(label);
                    answerContainer.appendChild(val);
                    solutionBlock.appendChild(answerContainer);
                }

                // --- Solution Details ---
                if (hasDetails) {
                    const detailsWrapper = document.createElement('div');
                    
                    // Disclosure Control
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = "text-sm font-medium flex items-center gap-1 focus:outline-none interactive-text my-2";
                    toggleBtn.style.color = "var(--c-accent-primary)";
                    toggleBtn.setAttribute('aria-expanded', isExpanded);
                    
                    const btnText = document.createElement('span');
                    btnText.textContent = isExpanded ? "Hide working" : "Show working";
                    
                    const icon = document.createElement('span');
                    icon.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="transform transition-transform ${isExpanded ? 'rotate-180' : ''}"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
                    
                    toggleBtn.appendChild(btnText);
                    toggleBtn.appendChild(icon);
                    
                    toggleBtn.onclick = () => {
                        const nextState = !appState.expandedNodes.has(nodeId);
                        if (nextState) appState.expandedNodes.add(nodeId);
                        else appState.expandedNodes.delete(nodeId);
                        
                        // Re-render just this node? Easier to replace children or re-render whole paper. 
                        // For prototype simplicity, let's re-render the paper or implement granular DOM update.
                        // Granular is better for scroll stability.
                        
                        // Toggle logic inline
                        const contentRegion = detailsWrapper.querySelector('.details-content');
                        if (nextState) {
                            contentRegion.classList.remove('hidden');
                            btnText.textContent = "Hide working";
                            icon.firstElementChild.classList.add('rotate-180');
                            solutionBlock.style.borderColor = "var(--c-hairline)"; // Demarcation hint
                        } else {
                            contentRegion.classList.add('hidden');
                            btnText.textContent = "Show working";
                            icon.firstElementChild.classList.remove('rotate-180');
                            solutionBlock.style.borderColor = "transparent";
                        }
                        toggleBtn.setAttribute('aria-expanded', nextState);
                    };
                    
                    detailsWrapper.appendChild(toggleBtn);

                    // Content Region
                    const contentRegion = document.createElement('div');
                    contentRegion.className = `details-content mt-2 p-4 rounded-sm ${isExpanded ? '' : 'hidden'}`;
                    contentRegion.style.backgroundColor = "var(--c-wash)";
                    
                    const d = node.solutionBlock.solutionDetails;
                    
                    // Helper to render section
                    const renderSection = (label, mdText, isList = false, isAlt = false) => {
                        if (!mdText) return null;
                        const block = document.createElement('div');
                        block.className = isAlt ? "mt-6 pt-4 border-t border-[var(--c-hairline)]" : "mb-4 last:mb-0";
                        
                        const lbl = document.createElement('div');
                        lbl.className = "text-xs font-bold uppercase tracking-wider mb-1 opacity-70";
                        lbl.style.color = "var(--c-text-secondary)";
                        lbl.textContent = label;
                        
                        const txt = document.createElement('div');
                        txt.className = "md-content text-sm";
                        txt.style.color = "var(--c-text-primary)";
                        txt.innerHTML = renderMarkdown(mdText);
                        
                        block.appendChild(lbl);
                        block.appendChild(txt);
                        return block;
                    };

                    // Order: Keep in mind -> Formulas -> Working -> Alternative
                    if (d.keepInMind) contentRegion.appendChild(renderSection("Keep in mind", d.keepInMind));
                    if (d.formulasUsed) contentRegion.appendChild(renderSection("Formulas used", d.formulasUsed));
                    if (d.working) contentRegion.appendChild(renderSection("Working", d.working));
                    
                    if (d.alternativeWorking && Array.isArray(d.alternativeWorking)) {
                        d.alternativeWorking.forEach(alt => {
                            contentRegion.appendChild(renderSection("Alternative working", alt, false, true));
                        });
                    }

                    detailsWrapper.appendChild(contentRegion);
                    solutionBlock.appendChild(detailsWrapper);
                    
                    // Initial demarcation state
                    if (isExpanded) {
                        solutionBlock.style.borderColor = "var(--c-hairline)";
                    }
                }
                
                wrapper.appendChild(solutionBlock);
            }

            // --- 3. Children ---
            if (node.children && node.children.length > 0) {
                const childrenContainer = document.createElement('div');
                // Indentation logic via padding/margin
                childrenContainer.className = "mt-4 space-y-4 pl-0 md:pl-8"; // Indent on Desktop
                
                node.children.forEach(child => {
                    childrenContainer.appendChild(createQuestionNode(child, depth + 1, defaultExpanded));
                });
                wrapper.appendChild(childrenContainer);
            }

            return wrapper;
        }

        // --- NAVIGATION ---
        function renderNavigation(paper) {
            // Build flat list of IDs
            // Desktop
            els.navListDesktop.innerHTML = '';
            els.navListDesktop.appendChild(buildNavList(paper));

            // Mobile
            els.navListMobile.innerHTML = '';
            els.navListMobile.appendChild(buildNavList(paper));
        }

        function buildNavList(paper) {
            const frag = document.createDocumentFragment();
            
            const createItem = (id, targetId, isSectionLabel = false) => {
                const item = document.createElement('a');
                item.className = "block px-2 py-1 text-sm rounded transition-colors duration-150 select-none cursor-pointer nav-item";
                item.style.color = isSectionLabel ? "var(--c-text-secondary)" : "var(--c-text-secondary)";
                
                if (isSectionLabel) {
                    item.textContent = id;
                    item.style.fontWeight = "600";
                    item.style.cursor = "default";
                    item.classList.add('mt-4', 'mb-1');
                } else {
                    item.textContent = id;
                    item.href = `#q-${cleanId(targetId)}`;
                    item.dataset.target = `q-${cleanId(targetId)}`;
                    
                    // Click handler for smooth scroll
                    item.onclick = (e) => {
                        e.preventDefault();
                        const target = document.getElementById(item.dataset.target);
                        if (target) {
                            // Close mobile drawer if open
                            closeMobileDrawer();
                            
                            const offset = 80; // Top controls height approx
                            const bodyRect = document.body.getBoundingClientRect().top;
                            const elementRect = target.getBoundingClientRect().top;
                            const elementPosition = elementRect - bodyRect;
                            const offsetPosition = elementPosition - offset;

                            window.scrollTo({
                                top: offsetPosition,
                                behavior: "smooth"
                            });
                        }
                    };
                }
                return item;
            };

            if (paper.sections) {
                paper.sections.forEach(sec => {
                    if (sec.label) {
                        frag.appendChild(createItem(sec.label, null, true));
                    }
                    sec.questions.forEach(q => traverseNav(q, frag, createItem));
                });
            } else if (paper.questions) {
                paper.questions.forEach(q => traverseNav(q, frag, createItem));
            }
            return frag;
        }

        function traverseNav(node, container, factory) {
            container.appendChild(factory(node.id, node.id));
            if (node.children) {
                node.children.forEach(child => traverseNav(child, container, factory));
            }
        }

        // --- MOBILE DRAWER LOGIC ---
        function setupMobileNav() {
            els.mobileNavTrigger.onclick = () => {
                els.mobileDrawer.classList.remove('translate-x-full');
                els.mobileDrawerBackdrop.classList.remove('hidden');
                // slight delay for opacity transition
                setTimeout(() => els.mobileDrawerBackdrop.classList.remove('opacity-0'), 10);
                appState.isMobileDrawerOpen = true;
                document.body.style.overflow = 'hidden';
            };

            const close = () => {
                els.mobileDrawer.classList.add('translate-x-full');
                els.mobileDrawerBackdrop.classList.add('opacity-0');
                setTimeout(() => els.mobileDrawerBackdrop.classList.add('hidden'), 200);
                appState.isMobileDrawerOpen = false;
                document.body.style.overflow = '';
            };

            els.mobileDrawerClose.onclick = close;
            els.mobileDrawerBackdrop.onclick = close;
            window.closeMobileDrawer = close; // Global exposure for nav click
        }

        // --- SCROLL SPY ---
        function setupScrollObserver() {
            const observerOptions = {
                root: null,
                rootMargin: '-100px 0px -80% 0px', // Active when near top
                threshold: 0
            };

            appState.activeObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        updateActiveNav(entry.target.id);
                    }
                });
            }, observerOptions);

            // Re-observe on render
            const observeAll = () => {
                if (!appState.activeObserver) return;
                appState.activeObserver.disconnect();
                document.querySelectorAll('.question-node').forEach(el => {
                    appState.activeObserver.observe(el);
                });
            };
            
            // Hook into render pipeline by monkey-patching or manual call. 
            // We'll call observeAll() inside render functions, but since they are async logic (markdown), 
            // we'll use a MutationObserver on the content div to re-trigger.
            
            const mo = new MutationObserver(() => observeAll());
            mo.observe(els.paperContent, { childList: true, subtree: true });
        }

        function updateActiveNav(targetId) {
            // Reset
            document.querySelectorAll('.nav-item').forEach(el => {
                el.style.fontWeight = '400';
                el.style.color = "var(--c-text-secondary)";
                // Remove accent marker
                el.style.borderLeft = 'none';
                el.classList.remove('pl-3');
                el.classList.add('px-2');
            });

            // Activate (both desktop and mobile lists)
            const activeLinks = document.querySelectorAll(`.nav-item[data-target="${targetId}"]`);
            activeLinks.forEach(link => {
                link.style.fontWeight = '600';
                link.style.color = "var(--c-text-primary)";
                // Active Marker
                link.classList.remove('px-2');
                link.classList.add('pl-3');
                link.style.borderLeft = "3px solid var(--c-accent-primary)";
            });
        }

        // --- HELPERS ---
        function renderMarkdown(text) {
            if (!md) return text || '';
            // Don't render if empty
            if (!text) return '';
            return md.render(text);
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function cleanId(id) {
            return id.replace(/[^a-zA-Z0-9-_]/g, '_');
        }

        // --- RUN ---
        init();

    </script>
</body>
</html>
