<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"107","totalWithinVariant":"200","hueFamily":"purple","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T18:12:59.824Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;107&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;purple&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T18:12:59.824Z&quot;}'>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RTQ Maths Paper Solution Viewer</title>
<!-- KaTeX CSS (SRI disabled per Stage 6 instructions) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<style>
    /* 
     * STAGE 6 - COLORLAB B: PURPLE (FORCED HUE)
     * LIGHT MODE ONLY 
     */
    :root {
        /* Palette: Purple Hue Family (270) */
        --c-white: #ffffff;
        --c-slate-50: #f8fafc;
        --c-slate-100: #f1f5f9;
        --c-slate-200: #e2e8f0;
        --c-slate-300: #cbd5e1;
        --c-slate-500: #64748b;
        --c-slate-700: #334155;
        --c-slate-900: #0f172a;

        --c-purple-50: #faf5ff;
        --c-purple-100: #f3e8ff;
        --c-purple-200: #e9d5ff;
        --c-purple-500: #a855f7;
        --c-purple-600: #9333ea;
        --c-purple-700: #7e22ce;

        /* Semantics */
        --bg-page: var(--c-white);
        --bg-surface: var(--c-white);
        --bg-subtle: var(--c-slate-50);

        --text-primary: var(--c-slate-900);
        --text-secondary: var(--c-slate-700);
        --text-tertiary: var(--c-slate-500);

        --border-subtle: var(--c-slate-200);
        --border-hairline: var(--c-slate-100);

        /* Accent (Restrained use per Stage 6 override) */
        --accent-ui: var(--c-purple-600);
        --accent-ui-hover: var(--c-purple-700);
        --accent-focus: var(--c-purple-500);
        --nav-marker: var(--c-purple-600);

        /* Spacing */
        --sp-xs: 0.25rem;
        --sp-sm: 0.5rem;
        --sp-md: 1rem;
        --sp-lg: 1.5rem;
        --sp-xl: 2.5rem;
        --sp-2xl: 4rem;

        /* Layout */
        --w-max: 1024px;
        --nav-width: 200px;
        --header-height: 60px;
    }

    * {
        box-sizing: border-box;
    }

    body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg-page);
        color: var(--text-primary);
        line-height: 1.6;
        -webkit-font-smoothing: antialiased;
    }

    /* Accessibility Focus */
    :focus-visible {
        outline: 2px solid var(--accent-focus);
        outline-offset: 2px;
    }

    /* Typography Hierarchy */
    h1, h2, h3, h4, h5, h6 {
        margin: 0;
        font-weight: 600;
        line-height: 1.3;
    }

    .text-sm { font-size: 0.875rem; }
    .text-xs { font-size: 0.75rem; }
    .font-medium { font-weight: 500; }
    .text-tertiary { color: var(--text-tertiary); }
    .text-secondary { color: var(--text-secondary); }

    /* --- Layout Shell --- */
    .doc-shell {
        max-width: var(--w-max);
        margin: 0 auto;
        display: grid;
        grid-template-rows: auto 1fr;
        min-height: 100vh;
    }

    .top-controls {
        height: var(--header-height);
        display: flex;
        align-items: center;
        padding: 0 var(--sp-md);
        background: var(--bg-surface);
        position: sticky;
        top: 0;
        z-index: 20;
        border-bottom: 1px solid transparent; /* Optical anchor */
    }

    /* Desktop Grid: Nav | Paper */
    .main-content {
        display: grid;
        grid-template-columns: var(--nav-width) 1fr;
        gap: var(--sp-xl);
        position: relative;
    }

    /* --- Navigation Rail (Desktop) --- */
    .nav-rail {
        position: sticky;
        top: var(--header-height);
        height: calc(100vh - var(--header-height));
        overflow-y: auto;
        padding: var(--sp-md) 0;
        /* Hide scrollbars visually but keep functional */
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    .nav-rail::-webkit-scrollbar {
        display: none;
    }

    .nav-list {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .nav-section-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-tertiary);
        padding: var(--sp-sm) var(--sp-sm) 0 var(--sp-sm);
        margin-top: var(--sp-md);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        pointer-events: none;
    }

    .nav-item {
        display: block;
        padding: 4px var(--sp-sm);
        text-decoration: none;
        color: var(--text-secondary);
        font-size: 0.9rem;
        border-left: 2px solid transparent;
        transition: color 0.15s ease, font-weight 0.15s ease;
        cursor: pointer;
    }
    
    .nav-item:hover {
        color: var(--text-primary);
        background-color: var(--c-purple-50); /* Subtle hover feedback */
    }

    .nav-item.is-active {
        color: var(--accent-ui);
        font-weight: 600;
        border-left-color: var(--nav-marker);
    }
    
    /* Flat hierarchy via type scale only */
    .nav-item[data-depth="1"] { font-size: 0.85rem; color: var(--text-tertiary); }
    .nav-item[data-depth="2"] { font-size: 0.8rem; color: var(--text-tertiary); }
    .nav-item[data-depth="1"]:hover, .nav-item[data-depth="2"]:hover { color: var(--text-primary); }

    /* --- Paper Content --- */
    .paper-column {
        padding: var(--sp-md) 0 var(--sp-2xl) 0;
        min-width: 0; /* Prevent grid blowout */
    }

    .section-header-block {
        margin-bottom: var(--sp-lg);
        padding-bottom: var(--sp-sm);
        border-bottom: 1px solid var(--border-subtle);
    }
    .section-header-text {
        font-size: 1.25rem;
        color: var(--text-secondary);
    }

    /* Question Node */
    .question-node {
        margin-bottom: var(--sp-2xl); /* Top level spacing */
    }
    
    /* Sub-questions: Weaker separation */
    .children-container {
        margin-top: var(--sp-md);
        /* Adaptive indentation */
        padding-left: var(--sp-md); 
        border-left: 1px solid transparent; /* Alignment guide */
    }
    @media (min-width: 768px) {
        .children-container { padding-left: var(--sp-lg); }
    }
    .children-container .question-node {
        margin-bottom: var(--sp-lg); /* Tighter than top level */
    }

    /* Question Body */
    .question-body {
        color: var(--text-primary);
        font-size: 1.125rem;
    }
    .q-id {
        font-weight: 700;
        margin-right: 0.5em;
        color: var(--text-secondary);
    }

    /* Solution Block */
    .solution-block {
        margin-top: var(--sp-md);
    }

    /* Answer */
    .answer-region {
        margin-bottom: var(--sp-md);
    }
    .answer-label {
        font-size: 0.85rem;
        font-weight: 700;
        color: var(--text-secondary);
        display: block;
        margin-bottom: 2px;
    }
    .answer-content {
        font-size: 1rem;
        color: var(--text-primary);
    }

    /* Disclosure Control */
    .disclosure-control {
        background: none;
        border: none;
        padding: 0;
        font-size: 0.9rem;
        color: var(--accent-ui);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: var(--sp-md);
    }
    .disclosure-control:hover {
        text-decoration: underline;
        color: var(--accent-ui-hover);
    }
    .chevron {
        transition: transform 0.2s ease;
        fill: currentColor;
    }
    .expanded .chevron {
        transform: rotate(90deg);
    }

    /* Solution Details Region */
    .solution-details {
        display: none;
        /* Stage 3: Optional non-semantic wash permitted per density rules. 
           Using very subtle wash for boundary clarity. */
        background-color: var(--c-purple-50); 
        padding: var(--sp-md);
        border-radius: 4px; /* Slight softening, not card */
    }
    .solution-details.expanded {
        display: block;
        animation: reveal 0.2s ease-out;
    }

    @keyframes reveal {
        from { opacity: 0; transform: translateY(-4px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .sd-subsection {
        margin-bottom: var(--sp-lg);
    }
    .sd-subsection:last-child {
        margin-bottom: 0;
    }

    .sd-label {
        font-size: 0.85rem;
        font-weight: 700;
        color: var(--text-secondary);
        margin-bottom: var(--sp-sm);
        display: block;
    }

    /* Keep In Mind */
    .kim-block { }
    .kim-content ul { padding-left: 1.25rem; margin: 0; }
    .kim-content li { margin-bottom: 0.25rem; font-size: 0.95rem; }

    /* Formulas */
    .formulas-content {
        font-family: serif; /* Math feel */
        color: var(--text-secondary);
    }

    /* Working */
    .working-content {
        color: var(--text-secondary); /* Subordinate but readable */
        font-size: 1rem;
    }
    
    /* Internal separators: Spacing only preferred. Optional hairline. */
    .sd-separator {
        height: 1px;
        background: var(--border-hairline);
        margin: var(--sp-lg) 0;
    }

    /* --- Math & Tables --- */
    /* KaTeX Containment Invariant */
    .katex-display {
        overflow-x: auto;
        overflow-y: hidden;
        max-width: 100%;
        padding: 0.5em 0;
        -webkit-overflow-scrolling: touch;
    }
    /* Inline math transparent */
    .katex { font-size: 1.1em; } 

    /* Tables */
    table {
        border-collapse: collapse;
        width: 100%;
        margin: var(--sp-md) 0;
        font-size: 0.95rem;
    }
    th, td {
        border: 1px solid var(--border-subtle);
        padding: var(--sp-sm);
        text-align: left;
    }
    th {
        font-weight: 600;
        color: var(--text-primary);
    }
    .table-wrapper {
        overflow-x: auto;
        margin-bottom: var(--sp-md);
    }

    /* --- Mobile & Responsive --- */
    .mobile-jump-trigger {
        display: none;
        margin-left: auto;
        background: none;
        border: 1px solid var(--border-subtle);
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 0.9rem;
        color: var(--text-secondary);
        cursor: pointer;
    }

    .mobile-drawer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 100;
        display: none;
    }
    .mobile-drawer.open { display: block; }
    
    .drawer-content {
        background: var(--bg-surface);
        width: 85%;
        max-width: 300px;
        height: 100%;
        padding: var(--sp-md);
        overflow-y: auto;
        box-shadow: 2px 0 12px rgba(0,0,0,0.1);
    }
    .drawer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--sp-md);
        border-bottom: 1px solid var(--border-subtle);
        padding-bottom: var(--sp-sm);
    }

    @media (max-width: 768px) {
        .main-content { display: block; } /* Single column */
        .nav-rail { display: none; } /* Use drawer */
        .mobile-jump-trigger { display: block; }
        .doc-shell { padding: 0 var(--sp-sm); }
        .top-controls { padding: 0; margin-bottom: var(--sp-md); }
        /* Reduce font sizes slightly */
        .question-body { font-size: 1.05rem; }
    }

    /* Selector */
    .paper-selector {
        padding: 6px 12px;
        font-size: 0.9rem;
        border: 1px solid var(--border-subtle);
        border-radius: 4px;
        color: var(--text-primary);
        background: var(--bg-surface);
        max-width: 100%;
    }

    /* Error State */
    .error-screen {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 50vh;
        font-weight: 700;
        color: var(--text-secondary);
        font-size: 1.2rem;
    }

    /* Markdown Element Spacing */
    .md-content p { margin-top: 0; margin-bottom: 0.75em; }
    .md-content p:last-child { margin-bottom: 0; }

</style>
</head>
<body>

<div id="app" class="doc-shell">
    <!-- Shell rendered by JS -->
</div>

<!-- Dependencies -->
<script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
<!-- KaTeX JS (SRI disabled) -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<script>
    // --- STAGE 0: CONSTANTS (AUTHORITATIVE) ---
    const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
    const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

    // --- Markdown Renderer Config (Authoritative) ---
    const md = window.markdownit ? window.markdownit({
        html: true,
        linkify: true,
        breaks: false // Critical constraint
    }) : null;

    if (md) {
        md.inline.ruler.disable(['escape']); // Preserve TeX backslashes
    }

    // --- State ---
    let appState = {
        papers: [],
        currentPaperKey: null,
        expandedMap: {} // { questionId: boolean }
    };

    // --- Initialization ---
    async function init() {
        try {
            const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
            if (!response.ok) throw new Error("Payload missing");
            const data = await response.json();
            
            if (!data.papers || data.papers.length === 0) throw new Error("No papers");
            
            appState.papers = data.papers;
            // Default to first paper
            selectPaper(appState.papers[0].key);
        } catch (e) {
            console.error(e);
            renderError();
        }
    }

    function renderError() {
        const app = document.getElementById('app');
        app.innerHTML = `
            <div class="top-controls"></div>
            <div class="error-screen">PAPERS PAYLOAD MISSING</div>
        `;
    }

    function selectPaper(key) {
        const paper = appState.papers.find(p => p.key === key);
        if (!paper) return;

        appState.currentPaperKey = key;
        
        // Reset Expanded State based on defaults
        const defaultExpanded = paper.defaults?.expandedAll !== false;
        
        // Helper to recurse and set defaults
        const setDefaults = (nodes) => {
            nodes.forEach(node => {
                if (node.solutionBlock?.solutionDetails) {
                    appState.expandedMap[node.id] = defaultExpanded;
                }
                if (node.children) setDefaults(node.children);
            });
        };

        if (paper.sections) {
            paper.sections.forEach(s => setDefaults(s.questions));
        } else if (paper.questions) {
            setDefaults(paper.questions);
        }

        renderApp();
    }

    function toggleWorking(qId) {
        appState.expandedMap[qId] = !appState.expandedMap[qId];
        renderApp(); // Full re-render simple approach for strict state sync
        
        // Restore focus/scroll if needed? 
        // Prototype requirement allows simple re-render as long as scroll preserved.
        // We will just update DOM in place or re-render. 
        // For robustness in this stress test, re-rendering contents is safest.
        // But to keep scroll, we should ideally manipulate DOM.
        // Let's rely on standard browser scroll preservation during re-render unless drastic change.
    }

    function renderApp() {
        const app = document.getElementById('app');
        const paper = appState.papers.find(p => p.key === appState.currentPaperKey);

        // Header
        const headerHTML = `
            <div class="top-controls">
                <select id="paperSelector" class="paper-selector" onchange="selectPaper(this.value)">
                    ${appState.papers.map(p => 
                        `<option value="${p.key}" ${p.key === appState.currentPaperKey ? 'selected' : ''}>${p.label}</option>`
                    ).join('')}
                </select>
                <button class="mobile-jump-trigger" onclick="openDrawer()">Jump to...</button>
            </div>
        `;

        // Nav
        const navHTML = renderNav(paper);
        const mobileDrawerHTML = renderMobileDrawer(paper);

        // Paper Content
        const contentHTML = renderPaperContent(paper);

        app.innerHTML = `
            ${headerHTML}
            <div class="main-content">
                <nav class="nav-rail" aria-label="Document navigation">
                    ${navHTML}
                </nav>
                <main class="paper-column">
                    ${contentHTML}
                </main>
            </div>
            ${mobileDrawerHTML}
        `;

        // Post-render: Math
        renderMath();
    }

    // --- Content Rendering ---

    function renderNav(paper) {
        let html = '<div class="nav-list">';
        
        const renderItem = (node, depth) => {
            const activeClass = ''; // Could track scroll position for active state in V2
            return `<a href="#${node.id}" class="nav-item ${activeClass}" data-depth="${depth}" onclick="closeDrawer()">
                ${node.id}
            </a>`;
        };

        const recurseNodes = (nodes, depth) => {
            return nodes.map(node => {
                let out = renderItem(node, depth);
                if (node.children) {
                    out += recurseNodes(node.children, depth + 1);
                }
                return out;
            }).join('');
        };

        if (paper.sections) {
            paper.sections.forEach(sec => {
                if (sec.label && sec.label.trim().length > 0) {
                    html += `<div class="nav-section-label">${sec.label}</div>`;
                }
                html += recurseNodes(sec.questions, 0);
            });
        } else {
            html += recurseNodes(paper.questions, 0);
        }
        
        html += '</div>';
        return html;
    }

    function renderMobileDrawer(paper) {
        return `
        <div id="mobileDrawer" class="mobile-drawer" onclick="if(event.target===this) closeDrawer()">
            <div class="drawer-content">
                <div class="drawer-header">
                    <span class="font-medium">Jump to</span>
                    <button onclick="closeDrawer()" style="background:none;border:none;font-size:1.2rem;cursor:pointer;">&times;</button>
                </div>
                ${renderNav(paper)}
            </div>
        </div>`;
    }

    function renderPaperContent(paper) {
        let html = '<div class="paper-surface">';
        
        if (paper.sections) {
            paper.sections.forEach(sec => {
                html += '<div class="section-block">';
                if (sec.label && sec.label.trim().length > 0) {
                    html += `
                        <div class="section-header-block">
                            <div class="section-header-text">${sec.label}</div>
                        </div>`;
                }
                html += renderQuestionList(sec.questions, 0);
                html += '</div>';
            });
        } else {
            html += renderQuestionList(paper.questions, 0);
        }
        
        html += '</div>';
        return html;
    }

    function renderQuestionList(nodes, depth) {
        return nodes.map(node => renderQuestionNode(node, depth)).join('');
    }

    function renderQuestionNode(node, depth) {
        const qHtml = md ? md.render(node.question) : node.question;
        const hasSolBlock = !!node.solutionBlock;
        const hasAnswer = hasSolBlock && node.solutionBlock.answer;
        const hasDetails = hasSolBlock && node.solutionBlock.solutionDetails;
        const isExpanded = appState.expandedMap[node.id];

        let solutionBlockHTML = '';
        
        if (hasSolBlock) {
            let answerHTML = '';
            if (hasAnswer) {
                const ansContent = md ? md.render(node.solutionBlock.answer) : node.solutionBlock.answer;
                answerHTML = `
                    <div class="answer-region">
                        <span class="answer-label">Answer</span>
                        <div class="answer-content md-content">${ansContent}</div>
                    </div>
                `;
            }

            let detailsControlHTML = '';
            let detailsRegionHTML = '';

            if (hasDetails) {
                detailsControlHTML = `
                    <button class="disclosure-control ${isExpanded ? 'expanded' : ''}" 
                            onclick="toggleWorking('${node.id}')"
                            aria-expanded="${isExpanded}">
                        <span>${isExpanded ? 'Hide working' : 'Show working'}</span>
                        <svg class="chevron" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                `;

                if (isExpanded) {
                    const sd = node.solutionBlock.solutionDetails;
                    
                    // Keep In Mind
                    let kimHTML = '';
                    if (sd.keepInMind) {
                        const kimContent = md ? md.render(sd.keepInMind) : sd.keepInMind;
                        kimHTML = `
                            <div class="sd-subsection kim-block">
                                <span class="sd-label">Keep in mind</span>
                                <div class="kim-content md-content">${kimContent}</div>
                            </div>
                            <div class="sd-separator"></div>
                        `;
                    }

                    // Formulas
                    let formHTML = '';
                    if (sd.formulasUsed) {
                        const formContent = md ? md.render(sd.formulasUsed) : sd.formulasUsed;
                        formHTML = `
                            <div class="sd-subsection formulas-block">
                                <span class="sd-label">Formulas used</span>
                                <div class="formulas-content md-content">${formContent}</div>
                            </div>
                            <div class="sd-separator"></div>
                        `;
                    }

                    // Working
                    let workHTML = '';
                    if (sd.working) {
                        const workContent = md ? md.render(sd.working) : sd.working;
                        workHTML = `
                            <div class="sd-subsection working-block">
                                <span class="sd-label">Working</span>
                                <div class="working-content md-content">${workContent}</div>
                            </div>
                        `;
                    }

                    // Alternative Working
                    let altHTML = '';
                    if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                        sd.alternativeWorking.forEach(alt => {
                            const altContent = md ? md.render(alt) : alt;
                            altHTML += `
                                <div class="sd-separator"></div>
                                <div class="sd-subsection alt-working-block">
                                    <span class="sd-label">Alternative working</span>
                                    <div class="working-content md-content">${altContent}</div>
                                </div>
                            `;
                        });
                    }

                    detailsRegionHTML = `
                        <div class="solution-details expanded">
                            ${kimHTML}
                            ${formHTML}
                            ${workHTML}
                            ${altHTML}
                        </div>
                    `;
                }
            }

            if (hasAnswer || hasDetails) {
                solutionBlockHTML = `
                    <div class="solution-block">
                        ${answerHTML}
                        ${detailsControlHTML}
                        ${detailsRegionHTML}
                    </div>
                `;
            }
        }

        let childrenHTML = '';
        if (node.children && node.children.length > 0) {
            childrenHTML = `
                <div class="children-container">
                    ${renderQuestionList(node.children, depth + 1)}
                </div>
            `;
        }

        return `
            <div class="question-node" id="${node.id}">
                <div class="question-body md-content">
                    <span class="q-id">${node.id}</span>
                    ${qHtml}
                </div>
                ${solutionBlockHTML}
                ${childrenHTML}
            </div>
        `;
    }

    // --- Math Rendering ---
    function renderMath() {
        if (!window.renderMathInElement) return;
        renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            throwOnError: false
        });
    }

    // --- Mobile Interactions ---
    window.openDrawer = function() {
        document.getElementById('mobileDrawer').classList.add('open');
    }
    window.closeDrawer = function() {
        document.getElementById('mobileDrawer').classList.remove('open');
    }
    window.selectPaper = selectPaper;
    window.toggleWorking = toggleWorking;

    // Boot
    init();

</script>
</body>
</html>
