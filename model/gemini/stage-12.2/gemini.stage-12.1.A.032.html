<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"A","indexWithinVariant":"32","totalWithinVariant":"50","hueFamily":"","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T12:36:54.399Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;A&quot;,&quot;indexWithinVariant&quot;:&quot;32&quot;,&quot;totalWithinVariant&quot;:&quot;50&quot;,&quot;hueFamily&quot;:&quot;&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T12:36:54.399Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Viewer</title>

    <!-- Markdown-it (No Integrity, per instructions) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>

    <!-- KaTeX (No Integrity, per instructions) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/contrib/auto-render.min.js"></script>

    <style>
        /* 
         * COLORLAB A: PALETTE + THEME FREEDOM (LIGHT-ONLY)
         * Aesthetic: Clean, Modern Academic, "Fresh Paper"
         */
        :root {
            /* Semantic Palette */
            --bg-app: #F8FAFC;          /* Slate 50 - Soft distinct background */
            --bg-paper: #FFFFFF;        /* Pure white paper surface */
            --bg-nav-drawer: #FFFFFF;
            --bg-wash: #F1F5F9;         /* Slate 100 - Very subtle wash for regions if needed */
            
            --text-primary: #0F172A;    /* Slate 900 - High contrast anchor (Question) */
            --text-secondary: #475569;  /* Slate 600 - Supporting text */
            --text-tertiary: #94A3B8;   /* Slate 400 - Quietest (Nav non-active) */
            
            --accent-color: #2563EB;    /* Blue 600 - Interaction / Active focus */
            --accent-subtle: #EFF6FF;   /* Blue 50 - Hover surfaces */

            --line-hairline: #E2E8F0;   /* Slate 200 - Structural dividers */
            --line-focus: #2563EB;      /* Blue 600 - Focus ring */

            /* Spacing Units */
            --sp-xs: 4px;
            --sp-sm: 8px;
            --sp-md: 16px;
            --sp-lg: 24px;
            --sp-xl: 32px;
            --sp-xxl: 64px; /* Top level separation */

            /* Layout */
            --nav-width: 200px;
            --content-max-width: 800px;
        }

        /* Reset & Base */
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-app);
            color: var(--text-primary);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }
        
        button { font-family: inherit; }

        /* Typography Hierarchy */
        h1, h2, h3, h4 { margin: 0; font-weight: 600; }
        p { margin: 0 0 1em 0; }
        p:last-child { margin-bottom: 0; }

        /* 
         * STAGE 3: CANONICAL LAYOUT 
         * DocumentFrameShell 
         */
        .app-shell {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Top Controls Region */
        .top-controls {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: var(--bg-app); /* Match app bg for seamlessness */
            padding: var(--sp-md) var(--sp-lg);
            border-bottom: 1px solid transparent; /* Optical anchor */
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 64px;
        }

        .paper-selector {
            padding: var(--sp-sm) var(--sp-md);
            font-size: 0.95rem;
            border: 1px solid var(--line-hairline);
            border-radius: 6px;
            background: var(--bg-paper);
            color: var(--text-primary);
            cursor: pointer;
        }
        .paper-selector:focus {
            outline: 2px solid var(--line-focus);
            outline-offset: 2px;
        }

        .mobile-jump-trigger {
            display: none; /* Desktop default */
            background: none;
            border: 1px solid var(--line-hairline);
            border-radius: 6px;
            padding: var(--sp-sm) var(--sp-md);
            color: var(--accent-color);
            font-weight: 500;
            cursor: pointer;
        }

        /* Main Document Frame */
        .document-frame {
            flex: 1;
            display: grid;
            grid-template-columns: var(--nav-width) 1fr;
            gap: var(--sp-xxl);
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--sp-lg);
            width: 100%;
        }

        /* Navigation Rail (Desktop) */
        .nav-rail {
            /* Sticky per Stage 6 Add-on */
            position: sticky;
            top: 80px; /* Below top controls */
            height: calc(100vh - 80px);
            overflow-y: auto;
            padding-right: var(--sp-md);
            /* Scrollbar hiding */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .nav-rail::-webkit-scrollbar { display: none; }

        /* Navigation Content */
        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: var(--sp-xs);
        }

        .nav-section-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            font-weight: 600;
            margin-top: var(--sp-md);
            margin-bottom: var(--sp-xs);
            padding-left: var(--sp-xs);
            /* Non-clickable */
            pointer-events: none; 
        }

        .nav-item {
            display: block;
            text-decoration: none;
            color: var(--text-secondary);
            padding: var(--sp-xs) var(--sp-sm);
            border-radius: 4px;
            cursor: pointer;
            transition: color 0.1s ease, background 0.1s ease;
            /* Hierarchy via type scale only - Flat visual list */
            font-size: 0.95rem; 
        }
        .nav-item.level-child {
            font-size: 0.85rem; /* Quieter */
            color: var(--text-secondary);
        }
        .nav-item:hover {
            background-color: var(--accent-subtle);
            color: var(--accent-color);
        }
        .nav-item:focus-visible {
            outline: 2px solid var(--line-focus);
        }
        /* Active State: Weight only, accent color allowed in non-content UI per Override */
        .nav-item.active {
            font-weight: 700;
            color: var(--accent-color);
        }

        /* Paper Column */
        .paper-column {
            min-width: 0; /* Prevent grid blowout */
            padding-bottom: 100px;
        }

        .paper-surface {
            /* Clean surface */
            background: transparent;
        }

        /* Section Header in Paper */
        .paper-section-header {
            font-size: 1.5rem;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--line-hairline);
            margin-top: var(--sp-xl);
            margin-bottom: var(--sp-xl);
            padding-bottom: var(--sp-sm);
        }

        /* Question Node Structure */
        .question-node-wrapper {
            margin-bottom: var(--sp-xxl); /* Largest spacing unit */
            scroll-margin-top: 100px; /* For anchor jumping */
        }
        
        .question-node-wrapper.child-node {
            margin-bottom: var(--sp-lg);
            margin-top: var(--sp-lg);
        }

        /* Indentation for children (Spacing only) */
        .children-container {
            margin-left: var(--sp-lg); 
            border-left: 1px solid transparent; /* Placeholder for alignment */
        }

        /* Question Body */
        .question-body {
            display: flex;
            gap: var(--sp-md);
            align-items: baseline;
        }
        
        .question-id {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 1.1rem;
            flex-shrink: 0;
            width: 3em; /* Fixed width feel */
        }
        
        .question-prompt {
            color: var(--text-primary);
            font-size: 1.1rem;
            width: 100%;
        }

        /* Solution Block */
        .solution-block {
            margin-top: var(--sp-lg);
            margin-left: calc(3em + var(--sp-md)); /* Align with prompt */
            display: flex;
            flex-direction: column;
            gap: var(--sp-md);
        }

        /* Divider: Question -> Solution (Optional per grammar, using spacing primarily) */
        /* .solution-block { border-top: 1px solid var(--line-hairline); padding-top: var(--sp-md); } */

        /* Answer */
        .answer-region {
            /* Answer visible by default */
        }
        .answer-label {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: var(--sp-xs);
            display: block;
        }
        .answer-content {
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        /* Solution Details Region */
        .solution-details-wrapper {
            /* Demarcation: Spacing + optional hairline */
            border-top: 1px solid var(--line-hairline);
            padding-top: var(--sp-md);
        }
        
        .disclosure-control {
            background: none;
            border: none;
            padding: 0;
            font-size: 0.95rem;
            color: var(--accent-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--sp-xs);
            font-weight: 500;
        }
        .disclosure-control:hover {
            text-decoration: underline;
        }
        .disclosure-control:focus-visible {
            outline: 2px solid var(--line-focus);
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* Expanded Details Content */
        .details-content {
            margin-top: var(--sp-md);
            /* Stage 3: Optional Wash for boundary clarity under density */
            /* background-color: var(--bg-wash); */ /* Keeping it clean whitespace for now per ColorLab A "fresh paper" preference */
            /* border-radius: 4px; */
            /* padding: var(--sp-md); */ /* If wash used */
            display: none; /* Hidden by default state, toggled via JS */
            flex-direction: column;
            gap: var(--sp-lg);
        }
        .details-content.expanded {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Subsections (Keep in mind, Formulas, etc) */
        .details-subsection {
            display: flex;
            flex-direction: column;
            gap: var(--sp-sm);
        }
        
        .subsection-label {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: var(--sp-xs);
        }

        .keep-in-mind-body, .formulas-body, .working-body {
            font-size: 1rem;
            color: var(--text-secondary); /* Subordinate contrast */
        }
        
        /* Keep in Mind specific */
        .keep-in-mind-body ul {
            padding-left: 1.2em;
            margin: 0;
        }

        /* Working / Alternative Working */
        .working-block {
            /* Mixed prose + math rhythm */
        }
        
        .alternative-working {
            margin-top: var(--sp-lg);
            border-top: 1px dashed var(--line-hairline); /* Quiet demarcation */
            padding-top: var(--sp-md);
        }

        /* 
         * Markdown & KaTeX Overrides 
         * Containment Invariant 
         */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding: 0.5em 0;
            /* No background for inline math */
        }
        /* Block math background (optional, permitted by Stage 3/6) */
        .katex-display > .katex {
            /* background: var(--bg-wash); */ /* Optional, staying clean */
            /* border-radius: 4px; */
            /* padding: 4px; */
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid var(--line-hairline);
            padding: var(--sp-sm);
            text-align: left;
        }
        th {
            font-weight: 600;
            background-color: var(--bg-app); /* Subtle header differentiation */
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .document-frame {
                display: block; /* Stack */
                padding: var(--sp-md);
            }
            .nav-rail {
                display: none; /* Hidden, use drawer */
            }
            .mobile-jump-trigger {
                display: block;
            }
            .question-body {
                flex-direction: column;
                gap: var(--sp-sm);
            }
            .solution-block {
                margin-left: 0;
                border-left: 2px solid var(--line-hairline); /* Guide line on mobile since indentation is lost */
                padding-left: var(--sp-md);
            }
            .children-container {
                margin-left: var(--sp-md);
            }
        }

        /* Mobile Drawer */
        .drawer-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.2);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .drawer-overlay.open {
            opacity: 1;
            pointer-events: auto;
        }
        .drawer {
            position: absolute;
            top: 0; left: 0; bottom: 0;
            width: 85%;
            max-width: 300px;
            background: var(--bg-nav-drawer);
            transform: translateX(-100%);
            transition: transform 0.2s ease-out;
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 24px rgba(0,0,0,0.1);
        }
        .drawer.open {
            transform: translateX(0);
        }
        .drawer-header {
            padding: var(--sp-md);
            border-bottom: 1px solid var(--line-hairline);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .drawer-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
        }
        .drawer-content {
            overflow-y: auto;
            padding: var(--sp-md);
        }

        /* Utilities */
        .error-message {
            padding: var(--sp-lg);
            color: #EF4444;
            font-weight: 600;
            text-align: center;
            border: 1px dashed #EF4444;
            background: #FEF2F2;
            margin: var(--sp-xl) 0;
        }

    </style>
</head>
<body>

    <!-- App Root -->
    <div id="app" class="app-shell">
        
        <!-- Top Controls -->
        <header class="top-controls">
            <!-- Paper Selector populated by JS -->
            <select id="paperSelector" class="paper-selector" aria-label="Select Paper"></select>
            
            <!-- Mobile Jump To -->
            <button id="mobileJumpBtn" class="mobile-jump-trigger">Jump to...</button>
        </header>

        <!-- Document Frame -->
        <main class="document-frame">
            
            <!-- Desktop Nav Rail -->
            <nav class="nav-rail" aria-label="Document Navigation">
                <div id="desktopNavList" class="nav-list"></div>
            </nav>

            <!-- Paper Content Column -->
            <section id="paperContent" class="paper-column" aria-label="Paper Content">
                <!-- Content injected here -->
                <div style="padding: 40px; text-align: center; color: var(--text-tertiary);">Loading paper...</div>
            </section>

        </main>
    </div>

    <!-- Mobile Drawer -->
    <div id="drawerOverlay" class="drawer-overlay">
        <div class="drawer" role="dialog" aria-modal="true" aria-label="Navigation">
            <div class="drawer-header">
                <h3>Jump to</h3>
                <button id="drawerClose" class="drawer-close" aria-label="Close navigation">&times;</button>
            </div>
            <div id="drawerNavList" class="drawer-content nav-list"></div>
        </div>
    </div>

    <script>
        // =========================================================
        // STAGE 0: CONSTANTS
        // =========================================================
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // =========================================================
        // STATE
        // =========================================================
        let appState = {
            papers: [],
            currentPaperId: null,
            payloadLoaded: false
        };

        // =========================================================
        // MARKDOWN & KATEX SETUP
        // =========================================================
        const md = window.markdownit ? window.markdownit({
            html: true,     // Allow inline SVG
            linkify: true,
            breaks: false   // Critical: Prevents <br> in math blocks
        }) : null;

        if (md) {
            // Disable escape rule to preserve TeX backslashes
            md.inline.ruler.disable(['escape']);
        }

        // Render Markdown safely
        function renderMarkdown(content) {
            if (!content) return '';
            if (!md) return content; // Fallback
            return md.render(content);
        }

        // Apply KaTeX auto-render to a container
        function applyKatex(container) {
            if (window.renderMathInElement) {
                renderMathInElement(container, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true}
                    ],
                    throwOnError: false
                });
            }
        }

        // =========================================================
        // DATA FETCHING
        // =========================================================
        async function initApp() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Fetch failed");
                const data = await response.json();
                
                appState.papers = data.papers || [];
                appState.payloadLoaded = true;

                if (appState.papers.length > 0) {
                    appState.currentPaperId = appState.papers[0].key;
                    renderPaperSelector();
                    renderCurrentPaper();
                } else {
                    renderError("No papers found in payload.");
                }

            } catch (e) {
                console.error(e);
                renderError("PAPERS PAYLOAD MISSING");
            }
        }

        // =========================================================
        // RENDERING LOGIC
        // =========================================================

        function renderError(msg) {
            document.getElementById('paperContent').innerHTML = `<div class="error-message">${msg}</div>`;
            document.getElementById('paperSelector').disabled = true;
        }

        function renderPaperSelector() {
            const selector = document.getElementById('paperSelector');
            selector.innerHTML = '';
            appState.papers.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.key;
                opt.textContent = p.label;
                selector.appendChild(opt);
            });
            selector.value = appState.currentPaperId;
            selector.onchange = (e) => {
                appState.currentPaperId = e.target.value;
                renderCurrentPaper();
                // Scroll to top
                window.scrollTo(0,0);
            };
        }

        function renderCurrentPaper() {
            const paper = appState.papers.find(p => p.key === appState.currentPaperId);
            if (!paper) return;

            const container = document.getElementById('paperContent');
            container.innerHTML = ''; // Clear

            // Handle Sectioned vs Flat
            let questionNodes = [];
            
            if (paper.sections && paper.sections.length > 0) {
                // Render Sections
                paper.sections.forEach(section => {
                    const sectionWrapper = document.createElement('div');
                    
                    // Render Section Header if label exists
                    if (section.label && section.label.trim() !== '') {
                        const header = document.createElement('h2');
                        header.className = 'paper-section-header';
                        header.textContent = `Section ${section.label}`;
                        sectionWrapper.appendChild(header);
                    }

                    const list = document.createElement('div');
                    list.className = 'section-question-list';
                    section.questions.forEach(q => {
                        list.appendChild(createQuestionNode(q, paper.defaults));
                        questionNodes.push({ id: q.id, elId: `q-${q.id}`, depth: 0, isSection: false });
                        collectNavNodes(q.children, questionNodes, 1);
                    });
                    sectionWrapper.appendChild(list);
                    container.appendChild(sectionWrapper);
                });
            } else if (paper.questions) {
                // Flat List
                paper.questions.forEach(q => {
                    container.appendChild(createQuestionNode(q, paper.defaults));
                    questionNodes.push({ id: q.id, elId: `q-${q.id}`, depth: 0 });
                    collectNavNodes(q.children, questionNodes, 1);
                });
            }

            // Post-render KaTeX
            applyKatex(container);

            // Rebuild Navigation
            renderNavigation(paper, questionNodes);
        }

        function collectNavNodes(children, list, depth) {
            if (!children) return;
            children.forEach(c => {
                list.push({ id: c.id, elId: `q-${c.id}`, depth: depth });
                collectNavNodes(c.children, list, depth + 1);
            });
        }

        // =========================================================
        // QUESTION NODE CREATION
        // =========================================================
        function createQuestionNode(q, defaults, depth = 0) {
            const wrapper = document.createElement('div');
            wrapper.className = 'question-node-wrapper';
            if (depth > 0) wrapper.classList.add('child-node');
            wrapper.id = `q-${q.id}`;

            // 1. Question Body
            const body = document.createElement('div');
            body.className = 'question-body';
            
            const idEl = document.createElement('div');
            idEl.className = 'question-id';
            idEl.textContent = q.id;
            
            const promptEl = document.createElement('div');
            promptEl.className = 'question-prompt';
            promptEl.innerHTML = renderMarkdown(q.question);

            body.appendChild(idEl);
            body.appendChild(promptEl);
            wrapper.appendChild(body);

            // 2. Solution Block (Optional)
            if (q.solutionBlock) {
                const sb = q.solutionBlock;
                const blockWrapper = document.createElement('div');
                blockWrapper.className = 'solution-block';

                // Answer (Optional, Visible Default)
                if (sb.answer) {
                    const ansRegion = document.createElement('div');
                    ansRegion.className = 'answer-region';
                    
                    const label = document.createElement('span');
                    label.className = 'answer-label';
                    label.textContent = 'Answer';
                    
                    const content = document.createElement('div');
                    content.className = 'answer-content';
                    content.innerHTML = renderMarkdown(sb.answer);

                    ansRegion.appendChild(label);
                    ansRegion.appendChild(content);
                    blockWrapper.appendChild(ansRegion);
                }

                // Solution Details (Optional, Collapsible)
                if (sb.solutionDetails) {
                    const sd = sb.solutionDetails;
                    const sdWrapper = document.createElement('div');
                    sdWrapper.className = 'solution-details-wrapper';

                    // Determine default state
                    const expandDefault = defaults && defaults.expandedAll === false ? false : true;

                    // Control
                    const toggle = document.createElement('button');
                    toggle.className = 'disclosure-control';
                    toggle.innerHTML = expandDefault 
                        ? `Hide working <span aria-hidden="true">▼</span>` 
                        : `Show working <span aria-hidden="true">▶</span>`;
                    
                    // Content Container
                    const detailsContent = document.createElement('div');
                    detailsContent.className = 'details-content';
                    if (expandDefault) detailsContent.classList.add('expanded');

                    // Interaction
                    toggle.onclick = () => {
                        const isExpanded = detailsContent.classList.contains('expanded');
                        if (isExpanded) {
                            detailsContent.classList.remove('expanded');
                            toggle.innerHTML = `Show working <span aria-hidden="true">▶</span>`;
                        } else {
                            detailsContent.classList.add('expanded');
                            toggle.innerHTML = `Hide working <span aria-hidden="true">▼</span>`;
                        }
                    };

                    sdWrapper.appendChild(toggle);

                    // Subsections
                    // A. Keep in Mind
                    if (sd.keepInMind) {
                        detailsContent.appendChild(createSubsection('Keep in mind', sd.keepInMind, 'keep-in-mind-body'));
                    }
                    // B. Formulas Used
                    if (sd.formulasUsed) {
                        detailsContent.appendChild(createSubsection('Formulas used', sd.formulasUsed, 'formulas-body'));
                    }
                    // C. Working
                    if (sd.working) {
                        detailsContent.appendChild(createSubsection('Working', sd.working, 'working-body'));
                    }
                    // D. Alternative Working (Array)
                    if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                        sd.alternativeWorking.forEach(alt => {
                            const altBlock = createSubsection('Alternative working', alt, 'working-body');
                            altBlock.classList.add('alternative-working');
                            detailsContent.appendChild(altBlock);
                        });
                    }

                    sdWrapper.appendChild(detailsContent);
                    blockWrapper.appendChild(sdWrapper);
                }

                wrapper.appendChild(blockWrapper);
            }

            // 3. Children (Recursive)
            if (q.children && q.children.length > 0) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                q.children.forEach(child => {
                    childrenContainer.appendChild(createQuestionNode(child, defaults, depth + 1));
                });
                wrapper.appendChild(childrenContainer);
            }

            return wrapper;
        }

        function createSubsection(labelTxt, mdContent, bodyClass) {
            const wrapper = document.createElement('div');
            wrapper.className = 'details-subsection';
            
            const label = document.createElement('div');
            label.className = 'subsection-label';
            label.textContent = labelTxt;

            const body = document.createElement('div');
            body.className = bodyClass;
            body.innerHTML = renderMarkdown(mdContent);

            wrapper.appendChild(label);
            wrapper.appendChild(body);
            return wrapper;
        }

        // =========================================================
        // NAVIGATION LOGIC
        // =========================================================
        function renderNavigation(paper, nodes) {
            const desktopList = document.getElementById('desktopNavList');
            const drawerList = document.getElementById('drawerNavList');
            desktopList.innerHTML = '';
            drawerList.innerHTML = '';

            // If sectioned, rebuild internal list structure roughly based on nodes array
            // Since nodes array is flat list of IDs, we just iterate it.
            // Stage 3 says "Section labels... as non-clickable separators".
            
            let currentSection = null;
            // Helper to render items
            const renderList = (targetContainer) => {
                // If sectioned paper, we need to insert labels based on payload structure, 
                // but nodes array is flat. Let's iterate payload logic for headers.
                
                if (paper.sections) {
                    paper.sections.forEach(section => {
                        if (section.label) {
                            const label = document.createElement('li');
                            label.className = 'nav-section-label';
                            label.textContent = section.label;
                            targetContainer.appendChild(label);
                        }
                        // Render questions for this section
                        // We need to flatten this section's tree to get correct nav items
                        let sectionNodes = [];
                        section.questions.forEach(q => {
                            sectionNodes.push({id: q.id, depth: 0});
                            collectNavNodes(q.children, sectionNodes, 1);
                        });

                        sectionNodes.forEach(node => {
                            targetContainer.appendChild(createNavItem(node));
                        });
                    });
                } else {
                    // Flat paper
                    nodes.forEach(node => {
                        targetContainer.appendChild(createNavItem(node));
                    });
                }
            };

            renderList(desktopList);
            renderList(drawerList);

            setupScrollObserver(nodes);
        }

        function createNavItem(node) {
            const item = document.createElement('li');
            item.className = 'nav-item';
            item.textContent = node.id;
            item.dataset.target = `q-${node.id}`;
            if (node.depth > 0) item.classList.add('level-child');
            
            item.onclick = (e) => {
                e.preventDefault();
                const target = document.getElementById(`q-${node.id}`);
                if (target) {
                    const offset = 80; // Top controls + padding
                    const bodyRect = document.body.getBoundingClientRect().top;
                    const elRect = target.getBoundingClientRect().top;
                    const elPosition = elRect - bodyRect;
                    const offsetPosition = elPosition - offset;

                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });
                    
                    // Close drawer if mobile
                    closeDrawer();
                }
            };
            return item;
        }

        // Active State Observer
        function setupScrollObserver(nodes) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.id.replace('q-', '');
                        updateActiveNav(id);
                    }
                });
            }, {
                rootMargin: '-20% 0px -60% 0px',
                threshold: 0
            });

            nodes.forEach(n => {
                const el = document.getElementById(n.elId);
                if (el) observer.observe(el);
            });
        }

        function updateActiveNav(activeId) {
            document.querySelectorAll('.nav-item').forEach(el => {
                el.classList.remove('active');
                if (el.textContent === activeId) el.classList.add('active');
            });
        }

        // =========================================================
        // MOBILE DRAWER
        // =========================================================
        const drawerOverlay = document.getElementById('drawerOverlay');
        const drawer = document.querySelector('.drawer');
        const jumpBtn = document.getElementById('mobileJumpBtn');
        const closeBtn = document.getElementById('drawerClose');

        function openDrawer() {
            drawerOverlay.classList.add('open');
            drawer.classList.add('open');
            // Trap focus roughly
            closeBtn.focus();
        }

        function closeDrawer() {
            drawerOverlay.classList.remove('open');
            drawer.classList.remove('open');
        }

        jumpBtn.onclick = openDrawer;
        closeBtn.onclick = closeDrawer;
        drawerOverlay.onclick = (e) => {
            if (e.target === drawerOverlay) closeDrawer();
        };

        // =========================================================
        // INITIALIZATION
        // =========================================================
        initApp();

    </script>
</body>
</html>
