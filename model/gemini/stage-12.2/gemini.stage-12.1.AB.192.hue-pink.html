<!DOCTYPE html>
<html lang="en" class="antialiased">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"192","totalWithinVariant":"200","hueFamily":"pink","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-09T09:37:46.172Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;192&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;pink&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-09T09:37:46.172Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Solution Viewer</title>

    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- TAILWIND CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KATEX (No SRI as per Stage 6 instructions) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- MARKDOWN-IT -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <!-- LUCIDE ICONS -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- COLORLAB CONFIGURATION -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        // Forced Hue Family: PINK (ColorLab B)
                        brand: {
                            50: '#fdf2f8',
                            100: '#fce7f3',
                            200: '#fbcfe8',
                            300: '#f9a8d4',
                            400: '#f472b6',
                            500: '#ec4899',
                            600: '#db2777',
                            700: '#be185d',
                            800: '#9d174d',
                            900: '#831843',
                            950: '#500724',
                        }
                    }
                }
            }
        }
    </script>

    <style>
        /* BASE & SCROLLBAR UTILITIES */
        html, body {
            height: 100%;
            overflow-y: auto; /* Standard document scroll */
        }
        
        body {
            background-color: #fcfcfc; /* Soft warm-neutral base (Stage 5.3.1 override by ColorLab A permits freedom, but keeping it clean) */
            color: #171717;
        }

        /* Hide scrollbar for Navigation but keep functional */
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        /* KATEX CONTAINMENT INVARIANT (Stage 3/6) */
        /* Prevent page-level horizontal scroll */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding: 0.5rem 0;
            margin: 1em 0;
            /* Scrollbar styling for math blocks */
            scrollbar-width: thin;
            scrollbar-color: #e5e7eb transparent;
        }
        .katex-display::-webkit-scrollbar {
            height: 4px;
        }
        .katex-display::-webkit-scrollbar-track {
            background: transparent;
        }
        .katex-display::-webkit-scrollbar-thumb {
            background-color: #e5e7eb;
            border-radius: 2px;
        }

        /* Inline KaTeX background rule: Transparent only */
        .katex {
            background-color: transparent !important;
        }

        /* Markdown Table Styling (Stage 5.8.5) */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.95em;
        }
        th, td {
            border: 1px solid #e5e7eb; /* Light gridlines */
            padding: 0.5rem;
            text-align: left;
            vertical-align: top;
        }
        th {
            font-weight: 600;
            background-color: transparent; /* No header fill */
        }

        /* SVG Passthrough Sizing */
        svg {
            max-width: 100%;
            height: auto;
        }

        /* Smooth scrolling for anchor jumps */
        html {
            scroll-behavior: smooth;
        }

        /* FOCUS STATES (Stage 5.5.2) */
        *:focus-visible {
            outline: 2px solid #db2777; /* Pink-600 */
            outline-offset: 2px;
        }
    </style>
</head>
<body>

    <!-- APP ROOT -->
    <div id="app" class="min-h-screen flex flex-col">
        <!-- SHELL: Top Controls -->
        <header class="sticky top-0 z-20 bg-[#fcfcfc]/95 backdrop-blur-sm border-b border-gray-100">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-14 flex items-center justify-between">
                <!-- Paper Selector -->
                <div class="flex items-center gap-3">
                    <label for="paper-select" class="text-sm font-medium text-gray-500 hidden sm:block">Paper</label>
                    <div class="relative">
                        <select id="paper-select" class="appearance-none bg-white border border-gray-200 text-gray-900 text-sm rounded-md focus:ring-brand-500 focus:border-brand-500 block w-full pl-3 pr-8 py-1.5 cursor-pointer hover:border-gray-300 transition-colors">
                            <option value="" disabled selected>Loading papers...</option>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                        </div>
                    </div>
                </div>

                <!-- Mobile Jump To Trigger -->
                <button id="mobile-jump-trigger" class="lg:hidden flex items-center gap-2 text-sm font-medium text-brand-600 hover:text-brand-700 px-3 py-1.5 rounded-md hover:bg-brand-50 transition-colors">
                    <i data-lucide="list" class="w-4 h-4"></i>
                    <span>Jump to</span>
                </button>
            </div>
        </header>

        <!-- SHELL: Document Frame -->
        <div class="flex-1 max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8 flex flex-col lg:flex-row relative">
            
            <!-- COLUMN: Navigation Rail (Desktop) -->
            <nav id="desktop-nav" class="hidden lg:block w-64 flex-shrink-0 sticky top-14 self-start max-h-[calc(100vh-3.5rem)] py-8 pr-6 overflow-y-auto no-scrollbar">
                <!-- Content injected via JS -->
            </nav>

            <!-- COLUMN: Paper Content -->
            <main id="paper-content" class="flex-1 min-w-0 py-8 lg:pl-12">
                <!-- Content injected via JS -->
                <div id="loading-state" class="text-center text-gray-400 py-12">Initializing...</div>
            </main>

        </div>

        <!-- DRAWER: Mobile Navigation -->
        <div id="mobile-drawer-backdrop" class="fixed inset-0 bg-black/20 z-40 hidden transition-opacity opacity-0" aria-hidden="true"></div>
        <div id="mobile-drawer" class="fixed inset-y-0 right-0 z-50 w-72 bg-white shadow-xl transform translate-x-full transition-transform duration-300 flex flex-col" aria-hidden="true">
            <div class="flex items-center justify-between p-4 border-b border-gray-100">
                <h2 class="text-lg font-medium text-gray-900">Jump to</h2>
                <button id="mobile-drawer-close" class="text-gray-400 hover:text-gray-600 p-1 rounded-md hover:bg-gray-100">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <nav id="mobile-nav-content" class="flex-1 overflow-y-auto p-4">
                <!-- Content injected via JS -->
            </nav>
        </div>
    </div>

    <!-- RUNTIME LOGIC -->
    <script>
        // --- STAGE 0: CONSTANTS ---
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // --- STATE ---
        const state = {
            papers: [],
            activePaperKey: null,
            expandedWorkings: new Set(), // Set of Question IDs
            isDrawerOpen: false,
            // Stage 6 Baseline: Observational - we store what we find
            sections: [], // { label: string, questions: [] } or just questions []
        };

        // --- MARKDOWN INIT (Stage 6 Add-on) ---
        // html: true (SVG passthrough), breaks: false (KaTeX safety), disable escape
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            breaks: false
        }) : null;

        if (md) {
            md.inline.ruler.disable(['escape']);
        }

        // --- DOM ELEMENTS ---
        const els = {
            paperSelect: document.getElementById('paper-select'),
            desktopNav: document.getElementById('desktop-nav'),
            mobileNavContent: document.getElementById('mobile-nav-content'),
            paperContent: document.getElementById('paper-content'),
            loadingState: document.getElementById('loading-state'),
            mobileTrigger: document.getElementById('mobile-jump-trigger'),
            mobileDrawer: document.getElementById('mobile-drawer'),
            mobileBackdrop: document.getElementById('mobile-drawer-backdrop'),
            closeDrawerBtn: document.getElementById('mobile-drawer-close')
        };

        // --- INITIALIZATION ---
        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Payload not found");
                const payload = await response.json();
                
                if (!payload.papers || !Array.isArray(payload.papers)) {
                    throw new Error("Invalid payload format");
                }

                state.papers = payload.papers;
                renderPaperSelector();
                
                // Select first paper by default
                if (state.papers.length > 0) {
                    loadPaper(state.papers[0].key);
                }
            } catch (err) {
                renderError();
                console.error(err);
            }
        }

        function renderError() {
            els.paperContent.innerHTML = `
                <div class="flex flex-col items-center justify-center py-20 text-gray-500">
                    <i data-lucide="file-warning" class="w-10 h-10 mb-4 text-gray-300"></i>
                    <h2 class="text-xl font-semibold text-gray-700">PAPERS PAYLOAD MISSING</h2>
                    <p class="mt-2 text-sm">Unable to load content from canonical path.</p>
                </div>
            `;
            lucide.createIcons();
            els.paperSelect.innerHTML = '<option disabled>Error loading papers</option>';
        }

        function renderPaperSelector() {
            els.paperSelect.innerHTML = state.papers.map(p => 
                `<option value="${p.key}">${p.label}</option>`
            ).join('');
            
            els.paperSelect.addEventListener('change', (e) => {
                loadPaper(e.target.value);
            });
        }

        function loadPaper(paperKey) {
            const paper = state.papers.find(p => p.key === paperKey);
            if (!paper) return;

            state.activePaperKey = paperKey;
            
            // Handle defaults
            const expandAll = paper.defaults?.expandedAll !== false; // Default true unless explicitly false
            state.expandedWorkings.clear();
            if (expandAll) {
                // We need to traverse to find all IDs that have working to pre-expand
                // This is done during render or we can do a quick pre-scan. 
                // For simplicity, we'll mark as expanded upon render check or just use a specialized check.
                // Strategy: We'll implement an "isExpanded" check that defaults to true unless user toggled.
                // Actually, let's just clear the specific "collapsed" set logic.
                // Simpler: state.expandedWorkings stores explicit state.
                // If defaults.expandedAll is true, we treat missing keys as expanded.
                // If defaults.expandedAll is false, we treat missing keys as collapsed.
            }
            state.paperDefaults = paper.defaults || { expandedAll: true };

            // Flatten structure for Navigation
            state.flatNavItems = [];
            
            // Normalize content structure (Sections vs Flat)
            if (paper.sections) {
                // If section label is empty, treat as grouping but no header
                state.structure = paper.sections.map(s => ({
                    type: 'section',
                    label: s.label,
                    questions: s.questions
                }));
            } else if (paper.questions) {
                state.structure = [{
                    type: 'section', // Anonymous section
                    label: null,
                    questions: paper.questions
                }];
            }

            renderNav();
            renderContent();
            
            // Refresh Icons & Math
            lucide.createIcons();
            renderMath();
            
            // Scroll top
            window.scrollTo({ top: 0, behavior: 'instant' });
        }

        // --- NAVIGATION RENDERING ---
        function renderNav() {
            const generateNavHTML = (isMobile) => {
                let html = '<div class="space-y-6">';
                
                state.structure.forEach(section => {
                    html += '<div class="flex flex-col gap-1">';
                    
                    // Section Header (only if label exists)
                    if (section.label && section.label.trim().length > 0) {
                        html += `<div class="px-2 py-1 text-xs font-semibold text-gray-400 uppercase tracking-wider select-none">${section.label}</div>`;
                    }

                    // Questions
                    const traverse = (nodes) => {
                        nodes.forEach(node => {
                            // Flat list visual, hierarchy via type scale logic if needed, but strict flat requirement says identifiers only.
                            // Stage 6 says "weight-only" for active.
                            // We construct a flat list of clickable items.
                            const activeClass = ''; // Logic handled via JS or CSS class toggling later
                            
                            // Visual hierarchy via opacity/size nuances if nested?
                            // Instructions: "Navigation is visually flat... no nested visual indentation"
                            // "Hierarchy expressed only via restrained type scale/quietness"
                            
                            // We simply render the ID.
                            html += `
                                <a href="#q-${node.id}" 
                                   class="nav-item block px-2 py-1 text-sm text-gray-500 hover:text-gray-900 transition-colors border-l-2 border-transparent hover:border-gray-200"
                                   data-id="${node.id}"
                                >
                                    ${node.id}
                                </a>
                            `;

                            if (node.children) traverse(node.children);
                        });
                    };
                    traverse(section.questions);
                    
                    html += '</div>';
                });

                html += '</div>';
                return html;
            };

            const navHTML = generateNavHTML();
            els.desktopNav.innerHTML = navHTML;
            els.mobileNavContent.innerHTML = navHTML;

            // Attach listeners for smooth scroll & active state
            const links = document.querySelectorAll('.nav-item');
            links.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetEl = document.getElementById(targetId);
                    if (targetEl) {
                        // Offset for sticky header
                        const offset = 80;
                        const bodyRect = document.body.getBoundingClientRect().top;
                        const elementRect = targetEl.getBoundingClientRect().top;
                        const elementPosition = elementRect - bodyRect;
                        const offsetPosition = elementPosition - offset;

                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });

                        if (state.isDrawerOpen) toggleDrawer(false);
                        updateActiveNav(link.getAttribute('data-id'));
                    }
                });
            });
        }

        function updateActiveNav(activeId) {
            document.querySelectorAll('.nav-item').forEach(el => {
                const isActive = el.getAttribute('data-id') === activeId;
                if (isActive) {
                    el.classList.add('font-bold', 'text-brand-600', 'border-brand-600');
                    el.classList.remove('text-gray-500', 'border-transparent');
                } else {
                    el.classList.remove('font-bold', 'text-brand-600', 'border-brand-600');
                    el.classList.add('text-gray-500', 'border-transparent');
                }
            });
        }

        // --- CONTENT RENDERING ---
        function renderContent() {
            let html = '<div class="space-y-16 pb-32">'; // Large bottom padding for comfort

            state.structure.forEach((section, sIdx) => {
                if (section.label && section.label.trim().length > 0) {
                    html += `
                        <div class="border-b border-gray-100 pb-2 mb-8 mt-12 first:mt-0">
                            <span class="text-lg font-semibold text-gray-900">${section.label}</span>
                        </div>
                    `;
                }

                section.questions.forEach(q => {
                    html += renderQuestionNode(q, 0);
                });
            });

            html += '</div>';
            els.paperContent.innerHTML = html;
        }

        function renderQuestionNode(node, depth) {
            const hasChildren = node.children && node.children.length > 0;
            const sb = node.solutionBlock;
            const hasAnswer = sb && sb.answer;
            const hasDetails = sb && sb.solutionDetails;
            
            // Determine expansion state
            const defaultsExpanded = state.paperDefaults?.expandedAll !== false;
            // If explicit state exists, use it. Else default.
            const isExpanded = state.expandedWorkings.has(node.id) 
                ? state.expandedWorkings.get(node.id) 
                : defaultsExpanded;
            // Store initial state so toggling works logic-wise
            state.expandedWorkings.set(node.id, isExpanded);

            const renderedQuestion = md ? md.render(node.question) : node.question;
            
            // Vertical rhythm: Top-level separation handled by container. 
            // Child separation handled via margin-top.
            const nodeMargin = depth === 0 ? 'mb-12' : 'mt-8';
            
            let html = `
                <div id="q-${node.id}" class="group relative ${nodeMargin} scroll-mt-24">
                    <!-- QUESTION BODY -->
                    <div class="flex gap-4">
                        <div class="flex-shrink-0 w-12 pt-0.5 text-right">
                            <span class="text-base font-medium text-gray-500 select-none">${node.id}</span>
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="prose prose-gray max-w-none text-gray-900 text-lg leading-relaxed font-medium">
                                ${renderedQuestion}
                            </div>
                        </div>
                    </div>
            `;

            // SOLUTION BLOCK
            if (sb) {
                html += `<div class="ml-16 mt-5 space-y-5">`;
                
                // ANSWER
                if (hasAnswer) {
                    const renderedAnswer = md ? md.render(sb.answer) : sb.answer;
                    html += `
                        <div class="group/answer">
                            <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-1">Answer</div>
                            <div class="text-gray-900 font-medium">
                                ${renderedAnswer}
                            </div>
                        </div>
                    `;
                }

                // SOLUTION DETAILS
                if (hasDetails) {
                    const sd = sb.solutionDetails;
                    const toggleLabel = isExpanded ? 'Hide working' : 'Show working';
                    const iconRot = isExpanded ? 'rotate-180' : '';
                    const displayStyle = isExpanded ? 'block' : 'hidden';

                    html += `
                        <div class="pt-1">
                            <!-- Toggle Control -->
                            <button onclick="toggleWorking('${node.id}')" 
                                class="flex items-center gap-1.5 text-sm font-medium text-brand-600 hover:text-brand-700 transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-brand-500 rounded px-1 -ml-1">
                                <span>${toggleLabel}</span>
                                <i data-lucide="chevron-down" class="w-4 h-4 transition-transform duration-200 ${iconRot}"></i>
                            </button>

                            <!-- Expanded Region -->
                            <div id="sd-${node.id}" class="${displayStyle} mt-4 space-y-6 animate-in fade-in slide-in-from-top-1 duration-200">
                                ${renderSolutionDetailsContent(sd)}
                            </div>
                        </div>
                    `;
                }
                
                html += `</div>`; // End Solution Block Content
            }

            // CHILDREN
            if (hasChildren) {
                // Indentation logic via margin-left
                html += `<div class="ml-0 sm:ml-8 lg:ml-12 border-l border-gray-100/50 pl-4 sm:pl-0 border-none">`;
                node.children.forEach(child => {
                    html += renderQuestionNode(child, depth + 1);
                });
                html += `</div>`;
            }

            html += `</div>`; // End Node
            return html;
        }

        function renderSolutionDetailsContent(sd) {
            let html = '';
            
            // Keep in mind
            if (sd.keepInMind) {
                const content = md ? md.render(sd.keepInMind) : sd.keepInMind;
                html += `
                    <div class="bg-gray-50/50 -mx-2 px-3 py-3 rounded border border-gray-100/50">
                        <div class="flex gap-2 text-gray-600 text-sm">
                            <i data-lucide="lightbulb" class="w-4 h-4 mt-0.5 flex-shrink-0 text-gray-400"></i>
                            <div class="flex-1 space-y-1">
                                <span class="block text-xs font-bold text-gray-500 uppercase tracking-wide mb-1">Keep in mind</span>
                                <div class="prose prose-sm prose-gray max-w-none text-gray-700">
                                    ${content}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Formulas Used
            if (sd.formulasUsed) {
                const content = md ? md.render(sd.formulasUsed) : sd.formulasUsed;
                html += `
                    <div>
                        <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-1">Formulas used</div>
                        <div class="prose prose-sm prose-gray max-w-none text-gray-600 italic">
                            ${content}
                        </div>
                    </div>
                `;
            }

            // Working (Primary)
            if (sd.working) {
                const content = md ? md.render(sd.working) : sd.working;
                html += `
                    <div>
                        <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">Working</div>
                        <div class="prose prose-gray max-w-none text-gray-800 leading-relaxed solution-body">
                            ${content}
                        </div>
                    </div>
                `;
            }

            // Alternative Working
            if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                sd.alternativeWorking.forEach((alt, idx) => {
                    const content = md ? md.render(alt) : alt;
                    html += `
                        <div class="pt-4 border-t border-gray-100 border-dashed">
                            <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">Alternative working ${sd.alternativeWorking.length > 1 ? idx + 1 : ''}</div>
                            <div class="prose prose-gray max-w-none text-gray-800 leading-relaxed solution-body">
                                ${content}
                            </div>
                        </div>
                    `;
                });
            }

            return html;
        }

        // --- INTERACTIONS ---

        window.toggleWorking = (id) => {
            const current = state.expandedWorkings.get(id);
            const next = !current;
            state.expandedWorkings.set(id, next);

            // Re-render specific node components or easier: update DOM directly for speed
            // Since we need to update icon rotation and text, let's manipulate DOM
            const container = document.getElementById(`sd-${id}`);
            const btn = document.querySelector(`button[onclick="toggleWorking('${id}')"]`);
            
            if (container && btn) {
                const icon = btn.querySelector('i');
                const span = btn.querySelector('span');
                
                if (next) {
                    container.classList.remove('hidden');
                    container.classList.add('block');
                    span.textContent = 'Hide working';
                    icon.classList.add('rotate-180');
                    // Render math if just revealed and not processed? KaTeX is fast enough to rerun or auto-render handled it.
                    // But newly visible content usually fine.
                } else {
                    container.classList.add('hidden');
                    container.classList.remove('block');
                    span.textContent = 'Show working';
                    icon.classList.remove('rotate-180');
                }
            }
        };

        function toggleDrawer(force) {
            const isOpen = typeof force === 'boolean' ? force : !state.isDrawerOpen;
            state.isDrawerOpen = isOpen;

            const drawer = els.mobileDrawer;
            const backdrop = els.mobileBackdrop;

            if (isOpen) {
                backdrop.classList.remove('hidden');
                // double RAF for transition
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        backdrop.classList.remove('opacity-0');
                        drawer.classList.remove('translate-x-full');
                    });
                });
            } else {
                backdrop.classList.add('opacity-0');
                drawer.classList.add('translate-x-full');
                setTimeout(() => {
                    backdrop.classList.add('hidden');
                }, 300);
            }
        }

        // --- MATH RENDERING ---
        function renderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false,
                output: 'html' // faster, sufficient
            });
        }

        // --- EVENTS ---
        els.mobileTrigger.addEventListener('click', () => toggleDrawer(true));
        els.closeDrawerBtn.addEventListener('click', () => toggleDrawer(false));
        els.mobileBackdrop.addEventListener('click', () => toggleDrawer(false));

        // Intersection Observer for Active Nav
        const observerOptions = {
            root: null,
            rootMargin: '-20% 0px -75% 0px', // Active when element is near top
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id.replace('q-', '');
                    updateActiveNav(id);
                }
            });
        }, observerOptions);

        // Hook up observer after render
        const originalRenderContent = renderContent;
        renderContent = function() {
            originalRenderContent();
            document.querySelectorAll('[id^="q-"]').forEach(el => observer.observe(el));
        };

        // --- BOOTSTRAP ---
        init();

    </script>
</body>
</html>
