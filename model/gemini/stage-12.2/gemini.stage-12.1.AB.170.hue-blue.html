<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"170","totalWithinVariant":"200","hueFamily":"blue","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T20:53:02.334Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;170&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;blue&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T20:53:02.334Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Viewer</title>
    
    <!-- KaTeX CSS (No integrity, no crossorigin) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- Tailwind CSS (via CDN for prototype) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Tailwind Configuration for ColorLab (Blue Family, Light Mode) -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        // Semantic mapping to Blue Hue Family (ColorLab B)
                        brand: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb', // Primary Accent
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        },
                        paper: {
                            bg: '#ffffff',
                            surface: '#ffffff',
                            text: '#0f172a', // Slate 900
                            muted: '#475569', // Slate 600
                            border: '#e2e8f0', // Slate 200
                        }
                    }
                }
            }
        }
    </script>

    <!-- Markdown-it -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <!-- KaTeX JS (No integrity) -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        /* Base Reset & Typography */
        body {
            background-color: #f8fafc; /* Very subtle cool grey/white mix */
            color: #0f172a;
            -webkit-font-smoothing: antialiased;
        }

        /* Scrollbar Hiding for Navigation */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* KaTeX Containment Invariant */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 4px; /* Space for scrollbar if needed */
            -webkit-overflow-scrolling: touch;
        }
        
        /* Markdown Content Styling */
        .markdown-body p {
            margin-bottom: 0.75em;
            line-height: 1.6;
        }
        .markdown-body p:last-child {
            margin-bottom: 0;
        }
        .markdown-body ul {
            list-style-type: disc;
            padding-left: 1.25em;
            margin-bottom: 0.75em;
        }
        .markdown-body ol {
            list-style-type: decimal;
            padding-left: 1.25em;
            margin-bottom: 0.75em;
        }
        /* Minimal Structural Tables */
        .markdown-body table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1em;
            font-size: 0.95em;
        }
        .markdown-body th {
            text-align: left;
            font-weight: 600;
            border-bottom: 1px solid #e2e8f0;
            padding: 0.5em;
        }
        .markdown-body td {
            border-bottom: 1px solid #f1f5f9;
            padding: 0.5em;
        }
        
        /* Focus Visibility */
        :focus-visible {
            outline: 2px solid #2563eb; /* brand-600 */
            outline-offset: 2px;
        }

        /* Navigation Sticky & Scrolling */
        .nav-sticky-container {
            position: sticky;
            top: 0;
            max-height: 100vh;
            overflow-y: auto;
        }

        /* Layout Utilities */
        .frame-shell {
            max-width: 80rem; /* max-w-7xl */
            margin-left: auto;
            margin-right: auto;
            padding-left: 1rem;
            padding-right: 1rem;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Top Controls Region -->
    <div class="bg-white border-b border-paper-border sticky top-0 z-20">
        <div class="frame-shell h-16 flex items-center justify-between">
            <div class="flex items-center gap-4">
                <span class="text-sm font-medium text-paper-muted">Paper</span>
                <select id="paper-selector" class="form-select text-sm border-paper-border rounded-md py-1.5 pl-3 pr-8 text-paper-text focus:border-brand-500 focus:ring-brand-500 bg-white">
                    <option disabled selected>Loading papers...</option>
                </select>
            </div>
            
            <!-- Mobile Jump To Trigger -->
            <button id="mobile-jump-trigger" class="md:hidden text-sm font-medium text-brand-600 hover:text-brand-700">
                Jump to
            </button>
        </div>
    </div>

    <!-- Main Document Shell -->
    <div class="frame-shell flex-1 flex flex-col md:flex-row gap-8 py-8 relative">
        
        <!-- Desktop Navigation Rail -->
        <nav id="desktop-nav" class="hidden md:block w-48 shrink-0 relative">
            <div class="nav-sticky-container pt-1 pb-10 no-scrollbar">
                <!-- Nav Content Generated Here -->
                <div id="nav-list-container" class="space-y-1"></div>
            </div>
        </nav>

        <!-- Paper Content Region -->
        <main id="paper-content" class="flex-1 min-w-0 pb-32">
            <!-- Content Generated Here -->
            <div id="paper-body" class="space-y-12">
                <div class="text-center text-paper-muted mt-20">Initializing...</div>
            </div>
        </main>

    </div>

    <!-- Mobile Navigation Drawer -->
    <div id="mobile-drawer-backdrop" class="fixed inset-0 bg-black/20 z-40 hidden" aria-hidden="true"></div>
    <div id="mobile-drawer" class="fixed inset-y-0 right-0 w-64 bg-white shadow-xl z-50 transform translate-x-full transition-transform duration-200 ease-out flex flex-col" aria-hidden="true">
        <div class="p-4 border-b border-paper-border flex justify-between items-center">
            <h2 class="font-semibold text-paper-text">Jump to</h2>
            <button id="mobile-drawer-close" class="text-paper-muted hover:text-paper-text p-1">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto p-4">
            <div id="mobile-nav-list-container" class="space-y-1"></div>
        </div>
    </div>

    <script>
        // --- STAGE 0: CONSTANTS ---
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // --- STAGE 6.0 & ADD-ON LOGIC ---
        // ColorLab B: Forced Hue "blue" implemented via Tailwind config above.
        // Markdown Config: breaks: false, html: true, linkify: true.

        // Global State
        let appState = {
            papers: [],
            currentPaper: null,
            expandedNodes: new Set(), // Set of question IDs
            defaultExpanded: true
        };

        // --- MARKDOWN SETUP ---
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            breaks: false 
        }) : null;

        if (md) {
            // Disable escape rule to preserve TeX backslashes
            md.inline.ruler.disable(['escape']);
        }

        // --- INITIALIZATION ---
        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Fetch failed");
                const payload = await response.json();
                
                appState.papers = payload.papers || [];
                
                if (appState.papers.length === 0) {
                    throw new Error("No papers in payload");
                }

                populatePaperSelector();
                
                // Load first paper by default
                loadPaper(appState.papers[0].key);

            } catch (error) {
                console.error(error);
                renderErrorState();
            }
        }

        function renderErrorState() {
            const container = document.getElementById('paper-body');
            container.innerHTML = `<div class="text-center text-red-600 font-medium mt-20">PAPERS PAYLOAD MISSING</div>`;
            document.getElementById('paper-selector').innerHTML = `<option>Error loading payload</option>`;
        }

        function populatePaperSelector() {
            const selector = document.getElementById('paper-selector');
            selector.innerHTML = '';
            appState.papers.forEach(paper => {
                const option = document.createElement('option');
                option.value = paper.key;
                option.textContent = paper.label || paper.key;
                selector.appendChild(option);
            });

            selector.addEventListener('change', (e) => {
                loadPaper(e.target.value);
            });
        }

        function loadPaper(paperKey) {
            const paper = appState.papers.find(p => p.key === paperKey);
            if (!paper) return;

            appState.currentPaper = paper;
            appState.defaultExpanded = paper.defaults?.expandedAll !== false; // Default true unless explicitly false
            appState.expandedNodes.clear(); // Reset manual toggles on switch

            // Render Navigation
            renderNavigation(paper);

            // Render Content
            const contentContainer = document.getElementById('paper-body');
            contentContainer.innerHTML = '';

            // Handle Sections vs Flat
            let nodesHtml = '';
            if (paper.sections && paper.sections.length > 0) {
                paper.sections.forEach(section => {
                    // Section Header (if label exists)
                    if (section.label && section.label.trim().length > 0) {
                        nodesHtml += `
                            <div class="mb-8 pt-4 border-b border-paper-border pb-2">
                                <h2 class="text-xl font-semibold text-paper-text">${escapeHtml(section.label)}</h2>
                            </div>
                        `;
                    }
                    // Section Questions
                    if (section.questions) {
                        section.questions.forEach((q, idx) => {
                            const isLast = idx === section.questions.length - 1;
                            nodesHtml += renderQuestionNode(q, 0, true, isLast);
                        });
                        // Spacing between sections
                         nodesHtml += `<div class="h-12"></div>`;
                    }
                });
            } else if (paper.questions) {
                paper.questions.forEach((q, idx) => {
                    const isLast = idx === paper.questions.length - 1;
                    nodesHtml += renderQuestionNode(q, 0, true, isLast);
                });
            }

            contentContainer.innerHTML = nodesHtml;

            // Post-Render: KaTeX
            renderMathInElement(contentContainer, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });

            // Post-Render: Re-attach event listeners for toggles
            attachToggleListeners();
        }

        // --- RENDERING CORE ---

        function renderQuestionNode(node, depth, isTopLevel, isLastInList) {
            // Determine Expand State
            // If user has not interacted, use default. Else use set.
            // Logic: we track *changes* or just current state? 
            // Simpler: Initialize expanded state based on default logic if not in set
            // Ideally we check if node has solution details first.
            
            const hasSolutionBlock = !!node.solutionBlock;
            const hasSolutionDetails = hasSolutionBlock && !!node.solutionBlock.solutionDetails;
            const hasAnswer = hasSolutionBlock && !!node.solutionBlock.answer;
            
            // Determine if expanded
            let isExpanded = appState.defaultExpanded;
            if (appState.expandedNodes.has(node.id)) {
                // If tracked, it means it's explicitly toggled OPEN. 
                // Wait, we need to track toggle state properly.
                // Let's store "closed" IDs if default is Open, and "open" IDs if default is Closed.
                // For prototype simplicity: "expandedNodes" will store IDs of explicitly OPEN nodes if default=false,
                // or we use a "collapsedNodes" set if default=true.
                // Let's use a simpler approach: 
                // We'll embed the state in the DOM re-render? No, re-render wipes DOM.
                // Let's store "collapsed" IDs since default is usually TRUE.
                // Actually, let's just use a unique Set for the current paper state logic based on default.
            }
            
            // Re-eval expansion logic:
            // Key: `state-${node.id}`
            // For this prototype, I will read the DOM state on click, but for initial render:
            // I'll stick to: default is expanded.
            // If I want to support persistence across re-renders (which happen on paper switch only), 
            // I don't need complex persistence because paper switch resets state.
            // So, default render is always based on `paper.defaults.expandedAll`.
            
            // HOWEVER, the recursive render function is static string generation.
            // We need to inject `data-expanded="true/false"` and the class `hidden` or not.
            
            const showDetails = hasSolutionDetails && isExpanded;

            // Indentation for children
            const indentClass = depth > 0 ? 'pl-4 md:pl-8 border-l border-transparent' : '';
            
            // Spacing
            const topMargin = isTopLevel ? (isLastInList ? 'mb-0' : 'mb-16') : 'mt-8';
            
            // Question Body
            const qHtml = md ? md.render(node.question || '') : (node.question || '');
            
            // Solution Block
            let solutionBlockHtml = '';
            if (hasSolutionBlock) {
                // Answer
                let answerHtml = '';
                if (hasAnswer) {
                    const ansContent = md ? md.render(node.solutionBlock.answer || '') : node.solutionBlock.answer;
                    answerHtml = `
                        <div class="mb-4">
                            <span class="text-sm font-bold text-brand-600 uppercase tracking-wide block mb-1">Answer</span>
                            <div class="text-paper-text markdown-body">${ansContent}</div>
                        </div>
                    `;
                }

                // Solution Details
                let detailsHtml = '';
                let toggleHtml = '';
                
                if (hasSolutionDetails) {
                    const sd = node.solutionBlock.solutionDetails;
                    
                    // Toggle Control
                    const toggleLabel = showDetails ? "Hide working" : "Show working";
                    // Only show control if details exist
                    toggleHtml = `
                        <button class="toggle-btn text-brand-600 hover:text-brand-700 font-medium text-sm flex items-center gap-1 focus:outline-none focus-visible:ring-2 focus-visible:ring-brand-500 rounded px-1 -ml-1 py-1 transition-colors" data-id="${node.id}">
                            <span>${toggleLabel}</span>
                            <svg class="w-4 h-4 transition-transform duration-200 ${showDetails ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    `;

                    // Details Content
                    // Order: Keep in mind, Formulas, Working, Alt Working
                    let innerContent = '';

                    if (sd.keepInMind) {
                        innerContent += `
                            <div class="mb-6">
                                <h4 class="text-sm font-bold text-paper-text mb-2">Keep in mind</h4>
                                <div class="text-paper-text markdown-body text-sm">${md.render(sd.keepInMind)}</div>
                            </div>
                        `;
                    }
                    if (sd.formulasUsed) {
                        innerContent += `
                            <div class="mb-6">
                                <h4 class="text-sm font-bold text-paper-text mb-2">Formulas used</h4>
                                <div class="text-paper-muted markdown-body text-sm">${md.render(sd.formulasUsed)}</div>
                            </div>
                        `;
                    }
                    if (sd.working) {
                        innerContent += `
                            <div class="mb-6">
                                <h4 class="text-sm font-bold text-paper-text mb-2">Working</h4>
                                <div class="text-paper-text markdown-body">${md.render(sd.working)}</div>
                            </div>
                        `;
                    }
                    if (sd.alternativeWorking && Array.isArray(sd.alternativeWorking)) {
                        sd.alternativeWorking.forEach(alt => {
                            innerContent += `
                                <div class="mt-8 pt-4 border-t border-paper-border">
                                    <h4 class="text-sm font-bold text-paper-text mb-2">Alternative working</h4>
                                    <div class="text-paper-text markdown-body">${md.render(alt)}</div>
                                </div>
                            `;
                        });
                    }

                    detailsHtml = `
                        <div id="details-${node.id}" class="${showDetails ? '' : 'hidden'} mt-4 pl-0">
                            <!-- Surface Wash/Demarcation -->
                            <div class="relative">
                                <!-- Optional Side Line -->
                                <div class="absolute left-0 top-0 bottom-0 w-px bg-brand-200"></div>
                                <div class="pl-4 md:pl-6 py-1">
                                    ${innerContent}
                                </div>
                            </div>
                        </div>
                    `;
                }

                solutionBlockHtml = `
                    <div class="mt-6">
                        ${answerHtml}
                        ${toggleHtml}
                        ${detailsHtml}
                    </div>
                `;
            }

            // Recursion
            let childrenHtml = '';
            if (node.children && node.children.length > 0) {
                childrenHtml = `<div class="mt-6">${node.children.map(child => renderQuestionNode(child, depth + 1, false, false)).join('')}</div>`;
            }

            return `
                <div id="q-${node.id}" class="question-node scroll-mt-24 ${topMargin} ${indentClass}">
                    <div class="flex flex-col">
                        <!-- ID & Question Body -->
                        <div class="flex gap-3 md:gap-4">
                            <span class="flex-none font-semibold text-paper-muted select-none w-8 md:w-10 text-right text-sm md:text-base pt-0.5">${node.id}</span>
                            <div class="flex-1 min-w-0">
                                <div class="markdown-body text-base md:text-lg text-paper-text leading-relaxed">
                                    ${qHtml}
                                </div>
                                ${solutionBlockHtml}
                                ${childrenHtml}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // --- NAVIGATION RENDERING ---

        function renderNavigation(paper) {
            // Flatten the tree for navigation
            const items = [];
            
            function traverse(nodes, sectionLabel = null) {
                nodes.forEach(node => {
                    items.push({ id: node.id, isSection: false });
                    if (node.children) traverse(node.children);
                });
            }

            if (paper.sections) {
                paper.sections.forEach(section => {
                    if (section.label) {
                        items.push({ id: section.label, isSection: true });
                    }
                    if (section.questions) traverse(section.questions);
                });
            } else if (paper.questions) {
                traverse(paper.questions);
            }

            const navHtml = items.map(item => {
                if (item.isSection) {
                    return `
                        <div class="pt-4 pb-1 pl-3 text-xs font-bold text-paper-muted uppercase tracking-wider select-none">
                            ${item.id}
                        </div>
                    `;
                }
                // Check nesting depth roughly by length of ID or just flat. 
                // Spec says: "Hierarchy via type scale only... same left edge".
                // We'll just render them flat but maybe slightly smaller text for longer IDs?
                // Actually, Spec says "sub-questions quieter". We don't have depth in this flat list easily without map.
                // Let's keep it simple: flat list, consistent style.
                return `
                    <a href="#q-${item.id}" class="nav-item block px-3 py-1 text-sm text-paper-muted hover:text-brand-600 transition-colors border-l-2 border-transparent hover:border-brand-200" data-target="q-${item.id}">
                        ${item.id}
                    </a>
                `;
            }).join('');

            document.getElementById('nav-list-container').innerHTML = navHtml;
            document.getElementById('mobile-nav-list-container').innerHTML = navHtml;

            setupNavInteractions();
        }

        function setupNavInteractions() {
            // Smooth Scroll & Active State Logic
            const links = document.querySelectorAll('.nav-item');
            
            links.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('data-target');
                    const targetEl = document.getElementById(targetId);
                    if (targetEl) {
                        targetEl.scrollIntoView({ behavior: 'smooth' });
                        // Close mobile drawer if open
                        closeDrawer();
                    }
                });
            });
            
            // Intersection Observer for ScrollSpy
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Activate nav link
                        const id = entry.target.id.replace('q-', '');
                        updateActiveNav(id);
                    }
                });
            }, { rootMargin: '-10% 0px -80% 0px' }); // Trigger near top

            document.querySelectorAll('.question-node').forEach(node => {
                observer.observe(node);
            });
        }

        function updateActiveNav(activeId) {
            // Remove active classes
            document.querySelectorAll('.nav-item').forEach(el => {
                el.classList.remove('font-bold', 'text-brand-600', 'border-brand-500');
                el.classList.add('text-paper-muted', 'border-transparent');
            });
            
            // Add active classes (match exactly)
            // Note: This matches the first instance.
            const activeLinks = document.querySelectorAll(`.nav-item[data-target="q-${activeId}"]`);
            activeLinks.forEach(el => {
                el.classList.remove('text-paper-muted', 'border-transparent');
                el.classList.add('font-bold', 'text-brand-600', 'border-brand-600'); // Stronger active state (ColorLab)
            });
        }

        // --- INTERACTION HANDLERS ---

        function attachToggleListeners() {
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = btn.getAttribute('data-id');
                    const details = document.getElementById(`details-${id}`);
                    const icon = btn.querySelector('svg');
                    const label = btn.querySelector('span');

                    if (details.classList.contains('hidden')) {
                        // Open
                        details.classList.remove('hidden');
                        icon.classList.add('rotate-180');
                        label.textContent = "Hide working";
                        appState.expandedNodes.add(id); // Track manual interaction? Or just UI state.
                    } else {
                        // Close
                        details.classList.add('hidden');
                        icon.classList.remove('rotate-180');
                        label.textContent = "Show working";
                        appState.expandedNodes.delete(id);
                    }
                });
            });
        }

        // --- MOBILE DRAWER LOGIC ---
        const drawer = document.getElementById('mobile-drawer');
        const backdrop = document.getElementById('mobile-drawer-backdrop');
        const trigger = document.getElementById('mobile-jump-trigger');
        const closeBtn = document.getElementById('mobile-drawer-close');

        function openDrawer() {
            drawer.classList.remove('translate-x-full');
            backdrop.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent bg scroll
        }

        function closeDrawer() {
            drawer.classList.add('translate-x-full');
            backdrop.classList.add('hidden');
            document.body.style.overflow = ''; 
        }

        trigger.addEventListener('click', openDrawer);
        closeBtn.addEventListener('click', closeDrawer);
        backdrop.addEventListener('click', closeDrawer);

        // --- UTIL ---
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        // Start
        init();

    </script>
</body>
</html>
