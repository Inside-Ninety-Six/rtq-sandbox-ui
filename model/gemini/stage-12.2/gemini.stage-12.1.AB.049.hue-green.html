<!DOCTYPE html>
<html lang="en" class="antialiased">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"49","totalWithinVariant":"200","hueFamily":"green","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T15:37:41.233Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;49&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;green&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T15:37:41.233Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Paper Viewer</title>

    <!-- Tailwind CSS (via CDN for prototyping) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- KaTeX JS -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Markdown-it -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* Base Setup */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FAFAFA; /* Zinc-50 equivalent for warm/neutral paper base */
            color: #18181B; /* Zinc-900 */
        }

        /* Hide scrollbar for Nav but allow scroll */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Focus Styles (Green Accent) */
        :focus-visible {
            outline: 2px solid #16A34A; /* Green-600 */
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* KaTeX Overflow Handling - Containment Invariant */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding: 0.5em 0;
            -webkit-overflow-scrolling: touch;
            /* Scrollbar styling for math blocks */
            scrollbar-width: thin;
            scrollbar-color: #D4D4D8 transparent;
        }
        .katex-display::-webkit-scrollbar {
            height: 4px;
        }
        .katex-display::-webkit-scrollbar-track {
            background: transparent;
        }
        .katex-display::-webkit-scrollbar-thumb {
            background-color: #D4D4D8;
            border-radius: 2px;
        }

        /* Typography & Rhythm */
        .prose-content p {
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }
        .prose-content ul {
            list-style-type: disc;
            padding-left: 1.25rem;
            margin-bottom: 0.75rem;
        }
        .prose-content ol {
            list-style-type: decimal;
            padding-left: 1.25rem;
            margin-bottom: 0.75rem;
        }
        /* Minimal tables */
        .prose-content table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
            font-size: 0.95em;
        }
        .prose-content th, .prose-content td {
            border: 1px solid #E4E4E7; /* Zinc-200 */
            padding: 0.5rem;
            text-align: left;
        }
        .prose-content th {
            font-weight: 600;
        }

        /* Solution Details Subsections */
        .sd-subsection {
            margin-top: 1rem;
        }
        .sd-subsection-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #52525B; /* Zinc-600 */
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body>

    <!-- STAGE 0: CONSTANTS (Runtime Definition) -->
    <script>
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";
    </script>

    <!-- Shell -->
    <div id="app-shell" class="min-h-screen flex flex-col">
        
        <!-- Top Controls (Aligned to Frame) -->
        <div class="w-full bg-white border-b border-zinc-200 sticky top-0 z-30">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-14 flex items-center justify-between">
                <!-- Paper Selector -->
                <div class="flex items-center gap-4">
                    <label for="paper-select" class="text-sm font-medium text-zinc-500 sr-only">Select Paper</label>
                    <select id="paper-select" class="bg-white border border-zinc-300 text-zinc-900 text-sm rounded-md focus:ring-green-600 focus:border-green-600 block w-64 p-2">
                        <option>Loading papers...</option>
                    </select>
                </div>

                <!-- Mobile Jump To Trigger -->
                <button id="mobile-jump-trigger" class="lg:hidden text-sm font-medium text-green-700 hover:text-green-800">
                    Jump to
                </button>
            </div>
        </div>

        <!-- DocumentFrameShell -->
        <div class="flex-1 max-w-7xl mx-auto w-full lg:grid lg:grid-cols-[240px_1fr] relative">
            
            <!-- Navigation Rail (Desktop) -->
            <nav class="hidden lg:block border-r border-zinc-200/50 h-[calc(100vh-3.5rem)] sticky top-14 overflow-y-auto no-scrollbar py-8 pr-6">
                <div id="desktop-nav-list" class="flex flex-col space-y-1">
                    <!-- Nav items rendered here -->
                </div>
            </nav>

            <!-- Paper Content Column -->
            <main class="py-8 px-4 sm:px-6 lg:px-12 w-full min-h-screen bg-white lg:bg-transparent">
                <div id="paper-content" class="max-w-3xl mx-auto space-y-12 pb-32">
                    <!-- Content rendered here -->
                    <div class="text-zinc-400 text-center mt-20">Loading payload...</div>
                </div>
            </main>

        </div>
    </div>

    <!-- Mobile Drawer -->
    <div id="mobile-drawer" class="fixed inset-0 z-50 hidden" role="dialog" aria-modal="true">
        <!-- Backdrop -->
        <div id="mobile-drawer-backdrop" class="fixed inset-0 bg-zinc-900/20 backdrop-blur-sm transition-opacity opacity-0"></div>
        
        <!-- Drawer Panel -->
        <div id="mobile-drawer-panel" class="fixed inset-y-0 right-0 w-64 bg-white shadow-xl transform translate-x-full transition-transform duration-300 flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-zinc-100">
                <h2 class="text-sm font-semibold text-zinc-900">Jump to</h2>
                <button id="mobile-drawer-close" class="text-zinc-500 hover:text-zinc-800 p-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="mobile-nav-list" class="flex-1 overflow-y-auto p-4 space-y-1">
                <!-- Mobile Nav Items -->
            </div>
        </div>
    </div>

    <!-- JS Logic -->
    <script>
        /**
         * RTQ Implementation
         * Stage 6 Baseline
         * ColorLab B: Force Hue = Green
         */

        // State
        const state = {
            papers: [],
            activePaperKey: null,
            expandedNodes: new Set(), // Set of Question Node IDs
            activeQuestionId: null
        };

        // DOM Elements
        const elPaperSelect = document.getElementById('paper-select');
        const elPaperContent = document.getElementById('paper-content');
        const elDesktopNav = document.getElementById('desktop-nav-list');
        const elMobileNav = document.getElementById('mobile-nav-list');
        const elMobileTrigger = document.getElementById('mobile-jump-trigger');
        const elMobileDrawer = document.getElementById('mobile-drawer');
        const elMobileDrawerPanel = document.getElementById('mobile-drawer-panel');
        const elMobileDrawerBackdrop = document.getElementById('mobile-drawer-backdrop');
        const elMobileClose = document.getElementById('mobile-drawer-close');

        // Markdown-it Setup (Strict Config)
        const md = window.markdownit ? window.markdownit({
            html: true, // Allow SVG passthrough
            linkify: true,
            breaks: false // CRITICAL: Do not inject <br>
        }) : null;

        if (md) {
            md.inline.ruler.disable(['escape']); // Preserve TeX backslashes
        }

        // --- Initialization ---

        async function init() {
            try {
                // Determine Payload Path (Canonical)
                // In a real environment, this might fetch relative to the HTML location.
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Payload not found");
                
                const payload = await response.json();
                state.papers = payload.papers || [];

                if (state.papers.length === 0) {
                    renderError("No papers found in payload.");
                    return;
                }

                renderPaperSelector();
                
                // Select first paper by default
                switchPaper(state.papers[0].key);

            } catch (error) {
                console.error(error);
                renderError("PAPERS PAYLOAD MISSING");
            }
        }

        // --- Rendering Logic ---

        function renderError(msg) {
            elPaperContent.innerHTML = `<div class="text-zinc-500 font-medium text-center mt-20">${msg}</div>`;
            elPaperSelect.innerHTML = `<option disabled>Error</option>`;
        }

        function renderPaperSelector() {
            elPaperSelect.innerHTML = state.papers.map(p => 
                `<option value="${p.key}">${p.label}</option>`
            ).join('');

            elPaperSelect.addEventListener('change', (e) => {
                switchPaper(e.target.value);
            });
        }

        function switchPaper(key) {
            const paper = state.papers.find(p => p.key === key);
            if (!paper) return;

            state.activePaperKey = key;
            state.expandedNodes.clear(); // Reset expansions on switch
            
            // Handle defaults
            const expandAll = paper.defaults?.expandedAll !== false; // Default true unless false
            
            // Helper to recursively set default state
            function setDefaults(nodes) {
                nodes.forEach(node => {
                    // Only nodes with solutionDetails have toggle state
                    if (node.solutionBlock?.solutionDetails) {
                        if (expandAll) state.expandedNodes.add(node.id);
                    }
                    if (node.children) setDefaults(node.children);
                });
            }

            // Flatten questions for defaults processing
            let allQuestions = [];
            if (paper.sections) {
                paper.sections.forEach(s => allQuestions.push(...s.questions));
            } else if (paper.questions) {
                allQuestions = paper.questions;
            }
            setDefaults(allQuestions);

            renderContent(paper);
            renderNavigation(paper);
            
            // Render Math
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'auto' });
        }

        function renderNavigation(paper) {
            // Logic: Flat identifiers. Hierarchy via scale/weight.
            // Sections: Label if non-empty, otherwise just items.
            
            const createNavItem = (id, depth = 0) => {
                // Depth cue: Typography scale only. 
                // Level 0: text-base. Level 1: text-sm. Level 2+: text-xs/sm quiet.
                // ColorLab B: Current Active -> text-green-800 font-bold.
                
                const sizeClass = depth === 0 ? 'text-sm' : 'text-sm'; // Flat list preference per brief
                const weightClass = depth === 0 ? 'font-medium' : 'font-normal';
                const opacityClass = depth > 0 ? 'text-zinc-500' : 'text-zinc-600';
                
                return `
                    <button onclick="scrollToQuestion('${id}')" 
                            class="w-full text-left px-2 py-1.5 ${sizeClass} ${weightClass} ${opacityClass} hover:text-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-600 rounded"
                            data-nav-id="${id}">
                        ${id}
                    </button>
                `;
            };

            const processNodes = (nodes, depth = 0) => {
                let html = '';
                nodes.forEach(node => {
                    html += createNavItem(node.id, depth);
                    if (node.children && node.children.length > 0) {
                        html += processNodes(node.children, depth + 1);
                    }
                });
                return html;
            };

            let navHtml = '';

            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    // Section Label (Non-clickable)
                    if (section.label && section.label.trim() !== '') {
                        const mt = idx > 0 ? 'mt-6' : '';
                        navHtml += `<div class="${mt} px-2 py-1 text-xs font-bold text-zinc-400 uppercase tracking-wider select-none mb-1">${section.label}</div>`;
                    } else if (idx > 0) {
                         // Spacing if explicit section label is empty but it's a new section block
                         navHtml += `<div class="mt-4"></div>`;
                    }
                    navHtml += processNodes(section.questions);
                });
            } else {
                navHtml += processNodes(paper.questions || []);
            }

            elDesktopNav.innerHTML = navHtml;
            elMobileNav.innerHTML = navHtml;
        }

        function renderContent(paper) {
            let html = '';

            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    const mt = idx > 0 ? 'mt-12' : '';
                    if (section.label && section.label.trim() !== '') {
                        html += `
                            <div class="${mt} border-b border-zinc-200 pb-2 mb-8">
                                <h2 class="text-lg font-bold text-zinc-800">${section.label}</h2>
                            </div>
                        `;
                    } else if (idx > 0) {
                        // Spacing only
                        html += `<div class="h-12"></div>`;
                    }
                    section.questions.forEach(q => {
                        html += renderQuestionNode(q, 0);
                    });
                });
            } else {
                (paper.questions || []).forEach(q => {
                    html += renderQuestionNode(q, 0);
                });
            }

            elPaperContent.innerHTML = html;
        }

        function renderQuestionNode(node, depth) {
            // Render Question Node
            // Structure: Question Body -> Solution Block -> Children
            
            // Separation: Top level gets large spacing. Children get indentation/tighter spacing.
            const isTopLevel = depth === 0;
            const containerClass = isTopLevel ? 'mb-16' : 'mt-6 ml-0 lg:ml-4'; // Indentation adapter
            
            const questionBody = md ? md.render(node.question) : node.question;
            
            // Solution Block Logic
            let solutionBlockHtml = '';
            if (node.solutionBlock) {
                const sb = node.solutionBlock;
                const hasAnswer = sb.answer && sb.answer.trim().length > 0;
                const hasDetails = !!sb.solutionDetails;
                
                // Answer
                let answerHtml = '';
                if (hasAnswer) {
                    const answerContent = md ? md.render(sb.answer) : sb.answer;
                    answerHtml = `
                        <div class="mt-4">
                            <div class="text-xs font-bold text-zinc-500 uppercase tracking-wide mb-1">Answer</div>
                            <div class="text-zinc-800 font-medium prose-content">${answerContent}</div>
                        </div>
                    `;
                }

                // Solution Details
                let detailsHtml = '';
                if (hasDetails) {
                    const isExpanded = state.expandedNodes.has(node.id);
                    const toggleText = isExpanded ? 'Hide working' : 'Show working';
                    const displayStyle = isExpanded ? 'block' : 'hidden';
                    const iconRotate = isExpanded ? 'rotate-180' : '';

                    // Construct Expanded Content
                    let expandedContent = '';
                    const details = sb.solutionDetails;

                    // 1. Keep in mind
                    if (details.keepInMind) {
                        expandedContent += `
                            <div class="sd-subsection">
                                <div class="sd-subsection-label flex items-center gap-1">
                                    <svg class="w-3 h-3 text-zinc-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                    Keep in mind
                                </div>
                                <div class="text-zinc-700 text-sm prose-content">${md.render(details.keepInMind)}</div>
                            </div>
                        `;
                    }

                    // 2. Formulas Used
                    if (details.formulasUsed) {
                        expandedContent += `
                            <div class="sd-subsection">
                                <div class="sd-subsection-label">Formulas used</div>
                                <div class="text-zinc-600 text-sm prose-content">${md.render(details.formulasUsed)}</div>
                            </div>
                        `;
                    }

                    // 3. Working
                    if (details.working) {
                        expandedContent += `
                            <div class="sd-subsection mt-4">
                                <div class="sd-subsection-label">Working</div>
                                <div class="text-zinc-700 prose-content">${md.render(details.working)}</div>
                            </div>
                        `;
                    }

                    // 4. Alternative Working
                    if (details.alternativeWorking && Array.isArray(details.alternativeWorking)) {
                        details.alternativeWorking.forEach((alt, idx) => {
                            expandedContent += `
                                <div class="sd-subsection mt-6 pt-4 border-t border-zinc-100">
                                    <div class="sd-subsection-label">Alternative working</div>
                                    <div class="text-zinc-700 prose-content">${md.render(alt)}</div>
                                </div>
                            `;
                        });
                    }

                    detailsHtml = `
                        <div class="mt-4">
                            <button onclick="toggleWorking('${node.id}')" 
                                    class="flex items-center gap-1 text-sm font-medium text-green-700 hover:text-green-800 transition-colors focus:outline-none focus:ring-2 focus:ring-green-600 rounded px-1 -ml-1">
                                <span>${toggleText}</span>
                                <svg class="w-4 h-4 transform transition-transform duration-200 ${iconRotate}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            <div class="mt-3 pl-4 border-l border-zinc-200/60 ${displayStyle}" id="details-${node.id}">
                                ${expandedContent}
                            </div>
                        </div>
                    `;
                }

                // Render Solution Block container only if something exists
                if (hasAnswer || hasDetails) {
                    solutionBlockHtml = `
                        <div class="mt-2">
                            ${answerHtml}
                            ${detailsHtml}
                        </div>
                    `;
                }
            }

            // Child Recursive Render
            let childrenHtml = '';
            if (node.children && node.children.length > 0) {
                childrenHtml = `
                    <div class="mt-4">
                        ${node.children.map(child => renderQuestionNode(child, depth + 1)).join('')}
                    </div>
                `;
            }

            return `
                <div id="q-${node.id}" class="${containerClass} scroll-mt-20">
                    <!-- Question Body -->
                    <div class="flex gap-3">
                        <div class="flex-shrink-0 w-8 pt-1">
                            <span class="text-zinc-500 font-medium text-sm select-none">${node.id}</span>
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="text-zinc-900 text-lg leading-relaxed prose-content">
                                ${questionBody}
                            </div>
                            
                            <!-- Solution Block -->
                            ${solutionBlockHtml}
                        </div>
                    </div>
                    
                    <!-- Children -->
                    ${childrenHtml}
                </div>
            `;
        }

        // --- Interaction Handlers ---

        window.toggleWorking = (nodeId) => {
            if (state.expandedNodes.has(nodeId)) {
                state.expandedNodes.delete(nodeId);
            } else {
                state.expandedNodes.add(nodeId);
            }
            
            // Re-render specifically this part or whole paper?
            // For prototype simplicity, re-render whole paper to maintain state consistency is easiest, 
            // but can jump. Better to just toggle DOM if possible.
            // Given "No Code" constraint on complexity, let's re-render content column.
            const paper = state.papers.find(p => p.key === state.activePaperKey);
            
            // Store scroll position? Browser handles it fairly well if layout doesn't shift drastically above viewport.
            // But re-rendering wipes DOM. Let's try simple DOM toggle for smoother UX, fallback to render if needed.
            // Actually, simply toggle class and text content is better.
            
            const detailsEl = document.getElementById(`details-${nodeId}`);
            const btnEl = document.querySelector(`button[onclick="toggleWorking('${nodeId}')"] span`);
            const iconEl = document.querySelector(`button[onclick="toggleWorking('${nodeId}')"] svg`);
            
            if (detailsEl && btnEl && iconEl) {
                const isHidden = detailsEl.classList.contains('hidden');
                if (isHidden) {
                    detailsEl.classList.remove('hidden');
                    detailsEl.classList.add('block');
                    btnEl.textContent = 'Hide working';
                    iconEl.classList.add('rotate-180');
                    // Render Math in new content if needed? It's already in DOM, just hidden.
                } else {
                    detailsEl.classList.add('hidden');
                    detailsEl.classList.remove('block');
                    btnEl.textContent = 'Show working';
                    iconEl.classList.remove('rotate-180');
                }
            }
        };

        window.scrollToQuestion = (id) => {
            const el = document.getElementById(`q-${id}`);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                updateActiveNav(id);
                // Close drawer if open
                toggleDrawer(false);
            }
        };

        function updateActiveNav(id) {
            state.activeQuestionId = id;
            // Desktop
            document.querySelectorAll('[data-nav-id]').forEach(btn => {
                const isActive = btn.getAttribute('data-nav-id') === id;
                if (isActive) {
                    btn.classList.add('text-green-800', 'font-bold');
                    btn.classList.remove('text-zinc-600', 'font-medium', 'font-normal', 'text-sm', 'text-zinc-500');
                    // Add slight left border or indicator?
                } else {
                    btn.classList.remove('text-green-800', 'font-bold');
                    // Reset to base classes - complex due to hierarchy depth logic in render.
                    // Simplified: just remove active specific classes. 
                    // To do this perfectly, we'd need to re-render nav or keep track of depth classes.
                    // For prototype: Let's accept that we just toggle the active state class.
                    btn.classList.add('text-zinc-600'); 
                }
            });
        }

        // Mobile Drawer Logic
        function toggleDrawer(show) {
            if (show) {
                elMobileDrawer.classList.remove('hidden');
                setTimeout(() => {
                    elMobileDrawerBackdrop.classList.remove('opacity-0');
                    elMobileDrawerPanel.classList.remove('translate-x-full');
                }, 10);
            } else {
                elMobileDrawerBackdrop.classList.add('opacity-0');
                elMobileDrawerPanel.classList.add('translate-x-full');
                setTimeout(() => {
                    elMobileDrawer.classList.add('hidden');
                }, 300);
            }
        }

        elMobileTrigger.addEventListener('click', () => toggleDrawer(true));
        elMobileClose.addEventListener('click', () => toggleDrawer(false));
        elMobileDrawerBackdrop.addEventListener('click', () => toggleDrawer(false));

        // Start
        init();

    </script>
</body>
</html>
