<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"ABC","indexWithinVariant":"94","totalWithinVariant":"320","hueFamily":"pink","intensityMode":"tinted_neutrals","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-09T14:18:16.364Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;ABC&quot;,&quot;indexWithinVariant&quot;:&quot;94&quot;,&quot;totalWithinVariant&quot;:&quot;320&quot;,&quot;hueFamily&quot;:&quot;pink&quot;,&quot;intensityMode&quot;:&quot;tinted_neutrals&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-09T14:18:16.364Z&quot;}'>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RTQ Maths Paper Solution Viewer</title>

<!-- KaTeX CSS (No Integrity/SRI per instructions) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

<!-- Markdown-it (No Integrity/SRI) -->
<script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
<!-- KaTeX JS (No Integrity/SRI) -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<style>
    /* 
     * STAGE 6 ADD-ON: COLORLAB C (Tinted Neutrals + Pink) 
     * Parameter: RTQ_COLORLAB_INTENSITY_MODE = "tinted_neutrals"
     * Parameter: RTQ_COLORLAB_FORCE_HUE_FAMILY = "pink" (Hue approx 340)
     */
    :root {
        /* OKLCH Values - Tinted Neutrals Mode (Pink) */
        /* Hue 340 */
        
        /* Surfaces: C in [0.015 .. 0.035] */
        --color-page-bg: oklch(0.98 0.02 340);
        --color-frame-bg: oklch(0.96 0.025 340);
        --color-paper-bg: oklch(0.99 0.015 340);
        
        /* Wash Surfaces: C in [0.025 .. 0.045] */
        --color-wash: oklch(0.96 0.035 340);
        --color-wash-border: oklch(0.94 0.035 340);

        /* Text: Primary C <= 0.010, Secondary C <= 0.012 */
        --color-text-primary: oklch(0.20 0.01 340);
        --color-text-secondary: oklch(0.40 0.012 340);
        --color-text-tertiary: oklch(0.55 0.012 340);

        /* Accent: C in [0.10 .. 0.16] (Link/Focus/Disclosure) */
        --color-accent: oklch(0.55 0.14 340);
        
        /* Dividers: Low chroma */
        --color-hairline: oklch(0.90 0.02 340);

        /* Metrics */
        --spacing-unit: 8px;
        --border-radius: 0px; /* No rounded corners per constraints */
        --max-paper-width: 800px;
        --nav-width: 240px;
        --header-height: 60px;
    }

    /* Base Reset & Typography */
    * { box-sizing: border-box; }
    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--color-page-bg);
        color: var(--color-text-primary);
        line-height: 1.5;
        overflow-x: hidden; /* Prevent horizontal page scroll */
    }

    /* Layout Shell */
    .app-shell {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        max-width: 1200px;
        margin: 0 auto;
        background-color: var(--color-frame-bg); /* Shared base surface */
    }

    /* Top Controls */
    .top-controls {
        height: var(--header-height);
        padding: 0 var(--spacing-unit) * 3;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--color-hairline);
        background-color: var(--color-frame-bg);
        position: sticky;
        top: 0;
        z-index: 50;
    }

    .paper-selector {
        font-size: 0.95rem;
        padding: 6px 12px;
        border: 1px solid var(--color-hairline);
        border-radius: 2px;
        background: var(--color-paper-bg);
        color: var(--color-text-primary);
    }
    
    .mobile-jump-to {
        display: none; /* Desktop default */
        font-size: 0.9rem;
        background: none;
        border: 1px solid var(--color-hairline);
        padding: 6px 12px;
        color: var(--color-accent);
        cursor: pointer;
    }

    /* Main Content Area: Nav + Paper */
    .content-frame {
        display: flex;
        flex: 1;
        position: relative;
    }

    /* Navigation Rail (Desktop) */
    .nav-rail {
        width: var(--nav-width);
        flex-shrink: 0;
        padding: calc(var(--spacing-unit) * 3) calc(var(--spacing-unit) * 2);
        position: sticky;
        top: var(--header-height);
        height: calc(100vh - var(--header-height));
        overflow-y: auto;
        border-right: 1px solid var(--color-hairline);
        /* Hide Scrollbar visually */
        scrollbar-width: none; 
        -ms-overflow-style: none;
    }
    .nav-rail::-webkit-scrollbar { display: none; }

    .nav-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    /* Navigation Items */
    .nav-section-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--color-text-tertiary);
        margin-top: var(--spacing-unit);
        margin-bottom: 4px;
        padding-left: 8px;
        font-weight: 600;
        pointer-events: none;
    }

    .nav-item {
        display: block;
        padding: 4px 8px;
        font-size: 0.9rem;
        text-decoration: none;
        color: var(--color-text-secondary);
        border-left: 2px solid transparent;
        transition: color 0.1s, border-color 0.1s;
        cursor: pointer;
    }

    .nav-item:hover {
        color: var(--color-text-primary);
        text-decoration: underline;
        text-decoration-color: var(--color-accent);
        text-decoration-thickness: 1px;
    }
    
    .nav-item.active {
        color: var(--color-text-primary);
        font-weight: 600;
        /* Stage 5 Override: Accent marker allowed in nav */
        border-left-color: var(--color-accent); 
    }

    /* Hierarchy visual cues via type scale only (Stage 5.4.5) */
    .nav-item[data-depth="0"] { font-size: 0.95rem; }
    .nav-item[data-depth="1"] { font-size: 0.9rem; color: var(--color-text-secondary); }
    .nav-item[data-depth="2"] { font-size: 0.85rem; color: var(--color-text-tertiary); }
    
    /* Paper Region */
    .paper-region {
        flex: 1;
        padding: calc(var(--spacing-unit) * 4) calc(var(--spacing-unit) * 6);
        background-color: var(--color-paper-bg);
        display: flex;
        flex-direction: column;
        align-items: center; /* Centered content column */
    }

    .paper-content {
        width: 100%;
        max-width: var(--max-paper-width);
    }

    /* Section Headers in Paper */
    .paper-section-header {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--color-text-primary);
        border-bottom: 1px solid var(--color-hairline);
        padding-bottom: var(--spacing-unit);
        margin-top: calc(var(--spacing-unit) * 4);
        margin-bottom: calc(var(--spacing-unit) * 4);
    }
    .paper-section-header:first-child { margin-top: 0; }

    /* Question Nodes */
    .question-node {
        display: flex;
        flex-direction: column;
        margin-bottom: calc(var(--spacing-unit) * 6); /* Largest separation */
        scroll-margin-top: calc(var(--header-height) + 20px);
    }

    .question-body {
        display: flex;
        gap: var(--spacing-unit);
        font-size: 1.05rem;
        line-height: 1.6;
        color: var(--color-text-primary);
    }

    .question-id {
        font-weight: 700;
        min-width: 2.5em;
        flex-shrink: 0;
        color: var(--color-text-secondary); /* subordinate to question text */
    }
    
    .question-prompt {
        flex: 1;
    }
    
    /* Markdown Element Spacing */
    .markdown-content p { margin-top: 0; margin-bottom: 0.8em; }
    .markdown-content p:last-child { margin-bottom: 0; }
    .markdown-content ul, .markdown-content ol { margin-top: 0; margin-bottom: 0.8em; padding-left: 1.5em; }
    
    /* Tables (Stage 5.8.5) */
    .markdown-content table {
        border-collapse: collapse;
        width: 100%;
        margin-bottom: 0.8em;
        font-size: 0.95em;
    }
    .markdown-content th, .markdown-content td {
        border: 1px solid var(--color-hairline);
        padding: 6px 10px;
        text-align: left;
    }
    .markdown-content th {
        font-weight: 600;
    }

    /* Solution Block */
    .solution-block {
        margin-top: calc(var(--spacing-unit) * 2);
        margin-left: 3.5em; /* Indent to align with prompt start roughly */
        display: flex;
        flex-direction: column;
        gap: calc(var(--spacing-unit) * 1.5);
    }

    /* Answer */
    .answer-region {
        display: flex;
        gap: var(--spacing-unit);
        align-items: baseline;
    }
    .answer-label {
        font-weight: 700;
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        flex-shrink: 0;
    }
    .answer-content {
        color: var(--color-text-primary);
        font-weight: 500;
    }

    /* Disclosure Control */
    .disclosure-control {
        background: none;
        border: none;
        padding: 0;
        font-size: 0.9rem;
        color: var(--color-accent);
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 6px;
        width: fit-content;
    }
    .disclosure-control:hover {
        text-decoration: underline;
    }
    .disclosure-control:focus-visible {
        outline: 2px solid var(--color-accent);
        outline-offset: 2px;
    }

    /* Solution Details */
    .solution-details {
        display: none; /* Hidden by default state logic handled in JS */
        flex-direction: column;
        gap: calc(var(--spacing-unit) * 2);
        background-color: var(--color-wash);
        padding: calc(var(--spacing-unit) * 2);
        border-left: 1px solid var(--color-wash-border);
    }
    .solution-details.expanded {
        display: flex;
    }

    /* Subsections within Solution Details */
    .sd-subsection {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    
    .sd-label {
        font-size: 0.85rem;
        font-weight: 700;
        color: var(--color-text-secondary);
        margin-bottom: 4px;
    }
    
    .sd-body {
        font-size: 0.95rem;
        color: var(--color-text-secondary); /* Subordinate but readable */
    }

    /* Keep in mind */
    .sd-keep-in-mind .sd-label {
        color: var(--color-text-primary); /* Slightly higher prominence */
    }
    .sd-keep-in-mind .sd-body {
        color: var(--color-text-primary); 
    }

    /* Alternative working separation */
    .sep-alt-working {
        height: 1px;
        background-color: var(--color-hairline);
        margin: var(--spacing-unit) 0;
    }

    /* Child Questions */
    .children-container {
        margin-top: calc(var(--spacing-unit) * 2);
        display: flex;
        flex-direction: column;
        gap: calc(var(--spacing-unit) * 2);
    }
    .child-question {
        margin-left: 2em; /* Indentation for nesting */
    }
    /* Reduce separation for children */
    .question-node .question-node {
        margin-bottom: calc(var(--spacing-unit) * 3);
    }

    /* KaTeX Containment Invariant */
    .katex-display {
        overflow-x: auto;
        overflow-y: hidden;
        max-width: 100%;
        padding-bottom: 4px; /* Space for scrollbar */
        margin: 0.5em 0;
    }
    /* Hide scrollbar on math unless needed */
    .katex-display::-webkit-scrollbar {
        height: 4px;
    }
    .katex-display::-webkit-scrollbar-thumb {
        background-color: var(--color-text-tertiary);
        border-radius: 2px;
    }

    /* Failure Message */
    .payload-error {
        font-family: monospace;
        color: var(--color-text-primary);
        font-size: 1.2rem;
        text-align: center;
        margin-top: 50px;
    }

    /* Mobile Drawer */
    .mobile-drawer-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5);
        z-index: 100;
        display: none;
    }
    .mobile-drawer {
        position: fixed;
        top: 0; bottom: 0; left: 0;
        width: 85%;
        max-width: 300px;
        background: var(--color-frame-bg);
        z-index: 101;
        transform: translateX(-100%);
        transition: transform 0.2s ease-out;
        display: flex;
        flex-direction: column;
        border-right: 1px solid var(--color-hairline);
    }
    .mobile-drawer.open {
        transform: translateX(0);
    }
    .drawer-header {
        height: var(--header-height);
        padding: 0 var(--spacing-unit) * 2;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--color-hairline);
    }
    .drawer-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--color-text-secondary);
        cursor: pointer;
    }
    .drawer-content {
        flex: 1;
        overflow-y: auto;
        padding: var(--spacing-unit) * 2;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .nav-rail { display: none; } /* Hide sticky rail */
        .mobile-jump-to { display: block; } /* Show trigger */
        .paper-region { padding: var(--spacing-unit) * 2; }
        .solution-block { margin-left: 0; } /* Reclaim space on mobile */
        .child-question { margin-left: 1em; } /* Less indentation */
        .children-container { margin-left: 0; }
        .question-body { gap: 8px; }
        .question-id { min-width: 1.5em; }
    }
</style>
</head>
<body>

<div id="app-root" class="app-shell">
    <!-- Top Controls -->
    <div class="top-controls">
        <select id="paper-selector" class="paper-selector" aria-label="Select Paper"></select>
        <button id="mobile-jump-to" class="mobile-jump-to" aria-label="Open Navigation">Jump to</button>
    </div>

    <!-- Main Content Frame -->
    <div class="content-frame">
        <!-- Desktop Nav Rail -->
        <nav id="nav-rail" class="nav-rail" aria-label="Document Navigation">
            <ul id="nav-list-desktop" class="nav-list"></ul>
        </nav>

        <!-- Paper Region -->
        <main id="paper-region" class="paper-region">
            <div id="paper-content" class="paper-content">
                <!-- Content injected here -->
            </div>
        </main>
    </div>
</div>

<!-- Mobile Drawer -->
<div id="drawer-overlay" class="mobile-drawer-overlay"></div>
<aside id="mobile-drawer" class="mobile-drawer" aria-hidden="true">
    <div class="drawer-header">
        <span style="font-weight: 700; color: var(--color-text-primary);">Jump to</span>
        <button id="drawer-close" class="drawer-close" aria-label="Close Navigation">&times;</button>
    </div>
    <div class="drawer-content">
        <ul id="nav-list-mobile" class="nav-list"></ul>
    </div>
</aside>

<script>
// --- STAGE 0: CONSTANTS ---
const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

// --- Markdown Config (Authoritative) ---
const md = window.markdownit ? window.markdownit({
    html: true,
    linkify: true,
    breaks: false // MUST be false to support KaTeX delimiters
}) : null;

if (md) {
    // Disable escape rule to preserve TeX backslashes
    md.inline.ruler.disable(['escape']);
}

// --- App State ---
let payloadData = null;
let currentPaperId = null;

// --- DOM Elements ---
const elPaperSelector = document.getElementById('paper-selector');
const elPaperContent = document.getElementById('paper-content');
const elNavListDesktop = document.getElementById('nav-list-desktop');
const elNavListMobile = document.getElementById('nav-list-mobile');
const elMobileJumpTo = document.getElementById('mobile-jump-to');
const elDrawerOverlay = document.getElementById('drawer-overlay');
const elMobileDrawer = document.getElementById('mobile-drawer');
const elDrawerClose = document.getElementById('drawer-close');

// --- Initialization ---
async function init() {
    try {
        const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
        if (!response.ok) throw new Error("Fetch failed");
        payloadData = await response.json();
        
        if (!payloadData || !payloadData.papers || payloadData.papers.length === 0) {
            throw new Error("Invalid payload");
        }

        populatePaperSelector();
        
        // Select first paper by default
        currentPaperId = payloadData.papers[0].key;
        renderPaper(currentPaperId);

    } catch (e) {
        console.error(e);
        elPaperContent.innerHTML = `<div class="payload-error">PAPERS PAYLOAD MISSING</div>`;
    }
}

// --- Render Logic ---

function populatePaperSelector() {
    elPaperSelector.innerHTML = '';
    payloadData.papers.forEach(paper => {
        const option = document.createElement('option');
        option.value = paper.key;
        option.textContent = paper.label;
        elPaperSelector.appendChild(option);
    });
    
    elPaperSelector.addEventListener('change', (e) => {
        currentPaperId = e.target.value;
        renderPaper(currentPaperId);
    });
}

function renderPaper(paperId) {
    const paper = payloadData.papers.find(p => p.key === paperId);
    if (!paper) return;

    // Reset scroll
    window.scrollTo(0, 0);
    document.getElementById('nav-rail').scrollTop = 0;

    // Clear Containers
    elPaperContent.innerHTML = '';
    elNavListDesktop.innerHTML = '';
    elNavListMobile.innerHTML = '';

    const navItems = []; // For building navigation
    
    // Determine structure: Flat (questions[]) or Sectioned (sections[])
    if (paper.sections) {
        paper.sections.forEach((section, secIdx) => {
            // Render section header in paper if label exists
            if (section.label && section.label.trim() !== "") {
                const secHeader = document.createElement('div');
                secHeader.className = 'paper-section-header';
                secHeader.textContent = section.label;
                elPaperContent.appendChild(secHeader);
                
                // Nav Section Label
                pushNavSection(section.label, navItems);
            }
            
            // Render questions
            section.questions.forEach(q => {
                const qNode = createQuestionNode(q, paper.defaults, 0);
                elPaperContent.appendChild(qNode);
                collectNavItems(q, 0, navItems);
            });
        });
    } else if (paper.questions) {
        paper.questions.forEach(q => {
            const qNode = createQuestionNode(q, paper.defaults, 0);
            elPaperContent.appendChild(qNode);
            collectNavItems(q, 0, navItems);
        });
    }

    // Render Navigation
    renderNavigation(navItems);

    // Apply KaTeX Auto-Render
    renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
    });
}

// --- Content Construction ---

function createQuestionNode(qData, defaults, depth) {
    const node = document.createElement('div');
    node.className = `question-node ${depth > 0 ? 'child-question' : ''}`;
    node.id = `q-${qData.id}`;

    // 1. Question Body
    const bodyEl = document.createElement('div');
    bodyEl.className = 'question-body';
    
    const idEl = document.createElement('div');
    idEl.className = 'question-id';
    idEl.textContent = qData.id;
    
    const promptEl = document.createElement('div');
    promptEl.className = 'question-prompt markdown-content';
    promptEl.innerHTML = md ? md.render(qData.question) : qData.question;
    
    bodyEl.appendChild(idEl);
    bodyEl.appendChild(promptEl);
    node.appendChild(bodyEl);

    // 2. Solution Block (Optional)
    if (qData.solutionBlock) {
        const solBlock = document.createElement('div');
        solBlock.className = 'solution-block';
        
        // Answer (Optional)
        if (qData.solutionBlock.answer) {
            const ansRegion = document.createElement('div');
            ansRegion.className = 'answer-region';
            
            const ansLabel = document.createElement('div');
            ansLabel.className = 'answer-label';
            ansLabel.textContent = 'Answer';
            
            const ansContent = document.createElement('div');
            ansContent.className = 'answer-content markdown-content';
            ansContent.innerHTML = md ? md.render(qData.solutionBlock.answer) : qData.solutionBlock.answer;
            
            ansRegion.appendChild(ansLabel);
            ansRegion.appendChild(ansContent);
            solBlock.appendChild(ansRegion);
        }

        // Solution Details (Optional)
        const sdData = qData.solutionBlock.solutionDetails;
        if (sdData) {
            const isExpandedDefault = (defaults && defaults.expandedAll !== undefined) ? defaults.expandedAll : true;
            
            // Toggle Control
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'disclosure-control';
            toggleBtn.setAttribute('aria-expanded', String(isExpandedDefault));
            toggleBtn.innerHTML = `<span>${isExpandedDefault ? 'Hide' : 'Show'} working</span> <span>${isExpandedDefault ? '▲' : '▼'}</span>`;
            
            // Details Container
            const detailsRegion = document.createElement('div');
            detailsRegion.className = `solution-details ${isExpandedDefault ? 'expanded' : ''}`;
            
            toggleBtn.onclick = () => {
                const isExpanded = detailsRegion.classList.contains('expanded');
                if (isExpanded) {
                    detailsRegion.classList.remove('expanded');
                    toggleBtn.setAttribute('aria-expanded', 'false');
                    toggleBtn.innerHTML = `<span>Show working</span> <span>▼</span>`;
                } else {
                    detailsRegion.classList.add('expanded');
                    toggleBtn.setAttribute('aria-expanded', 'true');
                    toggleBtn.innerHTML = `<span>Hide working</span> <span>▲</span>`;
                }
            };

            solBlock.appendChild(toggleBtn);
            
            // Render Subsections
            // Order: Keep in mind -> Formulas used -> Working -> Alternative working
            
            // Keep in mind
            if (sdData.keepInMind) {
                const sub = createSDSubsection('Keep in mind', sdData.keepInMind, 'sd-keep-in-mind');
                detailsRegion.appendChild(sub);
            }
            
            // Formulas used
            if (sdData.formulasUsed) {
                const sub = createSDSubsection('Formulas used', sdData.formulasUsed, 'sd-formulas-used');
                detailsRegion.appendChild(sub);
            }
            
            // Working
            if (sdData.working) {
                const sub = createSDSubsection('Working', sdData.working, 'sd-working');
                detailsRegion.appendChild(sub);
            }
            
            // Alternative Working (Array)
            if (sdData.alternativeWorking && Array.isArray(sdData.alternativeWorking)) {
                sdData.alternativeWorking.forEach(altContent => {
                    const sep = document.createElement('div');
                    sep.className = 'sep-alt-working';
                    detailsRegion.appendChild(sep);
                    
                    const sub = createSDSubsection('Alternative working', altContent, 'sd-alt-working');
                    detailsRegion.appendChild(sub);
                });
            }

            solBlock.appendChild(detailsRegion);
        }
        
        node.appendChild(solBlock);
    }

    // 3. Children (Recursive)
    if (qData.children && qData.children.length > 0) {
        const childContainer = document.createElement('div');
        childContainer.className = 'children-container';
        qData.children.forEach(child => {
            const childNode = createQuestionNode(child, defaults, depth + 1);
            childContainer.appendChild(childNode);
            // Collect nav items handled in parent loop for flattened list? 
            // Actually recursion for DOM building happens here, but nav collection happens separately in loop.
        });
        node.appendChild(childContainer);
    }

    return node;
}

function createSDSubsection(label, contentRaw, extraClass) {
    const wrapper = document.createElement('div');
    wrapper.className = `sd-subsection ${extraClass || ''}`;
    
    const lbl = document.createElement('div');
    lbl.className = 'sd-label';
    lbl.textContent = label;
    
    const body = document.createElement('div');
    body.className = 'sd-body markdown-content';
    body.innerHTML = md ? md.render(contentRaw) : contentRaw;
    
    wrapper.appendChild(lbl);
    wrapper.appendChild(body);
    return wrapper;
}

// --- Navigation Logic ---

function pushNavSection(label, list) {
    list.push({ type: 'section', label });
}

function collectNavItems(q, depth, list) {
    list.push({ type: 'item', id: q.id, depth });
    if (q.children) {
        q.children.forEach(c => collectNavItems(c, depth + 1, list));
    }
}

function renderNavigation(items) {
    // Fill both Desktop and Mobile lists
    [elNavListDesktop, elNavListMobile].forEach(container => {
        container.innerHTML = '';
        items.forEach(item => {
            if (item.type === 'section') {
                const li = document.createElement('li');
                li.className = 'nav-section-label';
                li.textContent = item.label;
                container.appendChild(li);
            } else {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.className = 'nav-item';
                a.textContent = item.id;
                a.dataset.depth = item.depth;
                a.onclick = (e) => {
                    e.preventDefault();
                    scrollToQuestion(item.id);
                    if (container === elNavListMobile) toggleDrawer(false);
                };
                li.appendChild(a);
                container.appendChild(li);
            }
        });
    });

    // Setup scroll spy
    setupScrollSpy(items);
}

function scrollToQuestion(id) {
    const el = document.getElementById(`q-${id}`);
    if (el) {
        // Offset for sticky header
        const headerOffset = 80;
        const elementPosition = el.getBoundingClientRect().top;
        const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
        
        window.scrollTo({
            top: offsetPosition,
            behavior: "smooth"
        });
    }
}

// --- Interaction & Utilities ---

let activeNavObserver = null;

function setupScrollSpy(items) {
    if (activeNavObserver) activeNavObserver.disconnect();

    const questionIds = items.filter(i => i.type === 'item').map(i => i.id);
    const options = {
        root: null,
        rootMargin: '-20% 0px -70% 0px', // Trigger when element is near top
        threshold: 0
    };

    activeNavObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const qId = entry.target.id.replace('q-', '');
                updateActiveNav(qId);
            }
        });
    }, options);

    questionIds.forEach(id => {
        const el = document.getElementById(`q-${id}`);
        if (el) activeNavObserver.observe(el);
    });
}

function updateActiveNav(id) {
    document.querySelectorAll('.nav-item').forEach(el => {
        el.classList.remove('active');
        if (el.textContent === id) {
            el.classList.add('active');
            // Auto-scroll nav rail to keep active item visible
            el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
    });
}

function toggleDrawer(show) {
    const isOpen = show !== undefined ? show : !elMobileDrawer.classList.contains('open');
    if (isOpen) {
        elMobileDrawer.classList.add('open');
        elDrawerOverlay.style.display = 'block';
        elMobileDrawer.setAttribute('aria-hidden', 'false');
    } else {
        elMobileDrawer.classList.remove('open');
        elDrawerOverlay.style.display = 'none';
        elMobileDrawer.setAttribute('aria-hidden', 'true');
    }
}

// Mobile Events
elMobileJumpTo.addEventListener('click', () => toggleDrawer(true));
elDrawerClose.addEventListener('click', () => toggleDrawer(false));
elDrawerOverlay.addEventListener('click', () => toggleDrawer(false));

// Init
init();

</script>
</body>
</html>
