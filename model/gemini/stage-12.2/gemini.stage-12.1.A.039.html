<!DOCTYPE html>
<html lang="en" class="antialiased">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"A","indexWithinVariant":"39","totalWithinVariant":"50","hueFamily":"","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T12:55:05.793Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;A&quot;,&quot;indexWithinVariant&quot;:&quot;39&quot;,&quot;totalWithinVariant&quot;:&quot;50&quot;,&quot;hueFamily&quot;:&quot;&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T12:55:05.793Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ – Maths Paper Solution Viewer</title>

    <!-- Tailwind CSS (No SRI) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS (No SRI) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- KaTeX JS (No SRI) -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Markdown-it (No SRI) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <!-- Lucide Icons (No SRI) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Tailwind Config for ColorLab A (Light mode only, clean typography, paper feel) -->
    <script>
        tailwind.config = {
            darkMode: 'class', // Disabled per requirements (Light only)
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
                    },
                    colors: {
                        // ColorLab A: Custom palette freedom within "Calm, Paper-like" constraints
                        paper: {
                            bg: '#FAFAF9', // Warm neutral background (Stone-50ish)
                            surface: '#FFFFFF', 
                            text: '#1C1917', // Stone-900
                            muted: '#57534E', // Stone-600
                            border: '#E7E5E4', // Stone-200
                        },
                        // Restrained accent for focus/links/active states
                        accent: {
                            DEFAULT: '#2563EB', // Royal Blue
                            hover: '#1D4ED8',
                            light: '#EFF6FF',
                        }
                    },
                    spacing: {
                        '18': '4.5rem',
                    }
                }
            }
        }
    </script>

    <style>
        /* Base styles */
        body {
            background-color: #FAFAF9; /* paper.bg */
            color: #1C1917; /* paper.text */
        }

        /* Hide scrollbar for navigation but keep functionality */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* KaTeX Containment Invariant */
        /* Prevent page-level horizontal scroll, allow local scroll for math */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 4px; /* Space for scrollbar if needed */
            -webkit-overflow-scrolling: touch;
        }
        
        /* Typography refinements */
        .prose p {
            margin-bottom: 0.75em;
            line-height: 1.6;
        }
        .prose p:last-child {
            margin-bottom: 0;
        }
        
        /* Table styles per Stage 5.8.5 */
        .rtq-table-wrapper {
            overflow-x: auto;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .rtq-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }
        .rtq-table th, .rtq-table td {
            border: 1px solid #E7E5E4;
            padding: 0.5rem 0.75rem;
            text-align: left;
        }
        .rtq-table th {
            font-weight: 600;
        }

        /* Solution Details Transition */
        .details-enter-active, .details-leave-active {
            transition: all 0.2s ease-out;
            max-height: 2000px; /* Arbitrary large height for CSS transition hack */
            opacity: 1;
            overflow: hidden;
        }
        .details-leave-to, .details-enter-from {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }
        
        /* Focus styles per Stage 5.5.2 */
        :focus-visible {
            outline: 2px solid #2563EB;
            outline-offset: 2px;
            border-radius: 2px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- App Root -->
    <div id="app" class="flex flex-col grow relative">
        <!-- Loading State -->
        <div class="flex items-center justify-center h-screen text-paper-muted">
            Loading Paper...
        </div>
    </div>

    <!-- Main Application Logic -->
    <script>
        // --- STAGE 0: CONSTANTS ---
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // --- STATE MANAGEMENT ---
        const state = {
            papers: [],
            currentPaperKey: null,
            collapsedStates: {}, // key: questionId, value: boolean (true = collapsed)
            mobileNavOpen: false,
            loading: true,
            error: false
        };

        // --- MARKDOWN SETUP (Stage 6 Add-on) ---
        // Configure markdown-it with html: true, linkify: true, breaks: false
        // Disable escape rule to preserve TeX backslashes
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            breaks: false 
        }) : null;

        if (md) {
            md.inline.ruler.disable(['escape']);
        }

        // --- DOM ELEMENTS ---
        const app = document.getElementById('app');

        // --- INITIALIZATION ---
        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error('Failed to load payload');
                
                const data = await response.json();
                if (!data.papers || !Array.isArray(data.papers)) throw new Error('Invalid payload format');
                
                state.papers = data.papers;
                
                // Select first paper by default if available
                if (state.papers.length > 0) {
                    selectPaper(state.papers[0].key);
                } else {
                    renderError("No papers found in payload.");
                }
            } catch (err) {
                console.error(err);
                renderError(); // PAPERS PAYLOAD MISSING
            }
        }

        // --- LOGIC: PAPER SELECTION ---
        function selectPaper(key) {
            state.currentPaperKey = key;
            state.collapsedStates = {}; // Reset collapse states
            state.loading = false;
            state.error = false;
            state.mobileNavOpen = false;
            render();
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function getCurrentPaper() {
            return state.papers.find(p => p.key === state.currentPaperKey);
        }

        // --- LOGIC: EXPAND/COLLAPSE ---
        function isCollapsed(questionId) {
            const paper = getCurrentPaper();
            const defaults = paper.defaults || {};
            // If explicit state exists, use it
            if (state.collapsedStates.hasOwnProperty(questionId)) {
                return state.collapsedStates[questionId];
            }
            // Otherwise check paper defaults. 
            // Brief: "Expanded by default when present" unless paper.defaults.expandedAll=false
            if (defaults.expandedAll === false) return true;
            return false;
        }

        function toggleSolution(questionId) {
            const current = isCollapsed(questionId);
            state.collapsedStates[questionId] = !current;
            
            // Re-render specific solution block or whole app? 
            // For prototype simplicity, re-rendering whole app is safer for consistent state, 
            // but might lose scroll position if not careful. 
            // Better: update DOM in place or re-render container. 
            // Given the constraints and size, full re-render is acceptable if we restore scroll, 
            // but let's try to just update the specific element class if possible.
            // Actually, React-like logic is complex in vanilla. 
            // We will re-render the app. Scroll stability is an invariant.
            
            // Capture scroll
            const scrollY = window.scrollY;
            render();
            // Restore scroll (approximate, since content height changes)
            // The brief says "Expanding or collapsing content must not intentionally reposition the user’s scroll position beyond the natural layout shift".
            // Browser handles natural layout shift if we just change DOM. Re-rendering from scratch resets scroll.
            // Let's implement inline toggle via DOM manipulation for smoothness.
            
            const contentId = `solution-details-${questionId}`;
            const btnId = `toggle-btn-${questionId}`;
            const el = document.getElementById(contentId);
            const btn = document.getElementById(btnId);
            const btnIcon = btn.querySelector('.lucide-chevron-down') || btn.querySelector('.lucide-chevron-right');
            const btnText = btn.querySelector('span');
            
            if (el) {
                // If we rely on render() to apply classes, we need to prevent full re-render for toggles to maintain scroll.
                // Re-rendering entire app resets scroll to top. 
                // We will manually toggle classes here to satisfy "Scroll position stability".
                const collapsed = state.collapsedStates[questionId];
                
                if (collapsed) {
                    el.classList.add('hidden');
                    btnText.textContent = "Show working";
                    if(btnIcon) {
                        btnIcon.classList.remove('rotate-180');
                    }
                } else {
                    el.classList.remove('hidden');
                    btnText.textContent = "Hide working";
                    if(btnIcon) {
                        btnIcon.classList.add('rotate-180');
                    }
                }
            }
            // We do NOT call render() here to avoid scroll jump.
        }

        // --- LOGIC: NAVIGATION ---
        function scrollToQuestion(id) {
            const el = document.getElementById(`q-${id}`);
            if (el) {
                // Offset for sticky header if any, though design has sticky nav rail, not header.
                // Mobile might have header.
                // Just scrollIntoView for now.
                el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                state.mobileNavOpen = false;
                renderMobileNavOverlay(); // Update mobile nav state
            }
        }

        function toggleMobileNav() {
            state.mobileNavOpen = !state.mobileNavOpen;
            renderMobileNavOverlay();
        }

        // --- RENDERERS ---

        function renderError(msg) {
            app.innerHTML = `
                <div class="flex items-center justify-center h-screen flex-col gap-4 text-paper-text">
                    <div class="font-semibold text-lg">PAPERS PAYLOAD MISSING</div>
                    ${msg ? `<div class="text-sm text-paper-muted">${msg}</div>` : ''}
                </div>
            `;
        }

        function render() {
            if (state.error) return renderError();
            if (state.loading) return;

            const paper = getCurrentPaper();
            if (!paper) return;

            // Shell Structure
            app.innerHTML = `
                <!-- Top Controls (Aligned with DocumentFrameShell) -->
                <div class="w-full bg-paper-bg border-b border-paper-border z-20 relative">
                    <div class="max-w-[1200px] mx-auto px-4 lg:px-8 h-16 flex items-center justify-between">
                        <div class="flex items-center gap-4">
                            <label for="paper-select" class="sr-only">Select Paper</label>
                            <select id="paper-select" class="bg-white border border-paper-border rounded-md py-1.5 px-3 text-sm font-medium text-paper-text focus:ring-2 focus:ring-accent focus:outline-none shadow-sm">
                                ${state.papers.map(p => `<option value="${p.key}" ${p.key === state.currentPaperKey ? 'selected' : ''}>${p.label}</option>`).join('')}
                            </select>
                        </div>
                        
                        <!-- Mobile Jump To Trigger -->
                        <button onclick="toggleMobileNav()" class="lg:hidden flex items-center gap-2 text-sm font-medium text-accent hover:text-accent-hover transition-colors py-2 px-3 rounded-md hover:bg-paper-border/30">
                            <span>Jump to</span>
                            <i data-lucide="menu" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>

                <!-- DocumentFrameShell -->
                <div class="flex-grow w-full max-w-[1200px] mx-auto flex items-stretch relative">
                    
                    <!-- Desktop Navigation Rail (Sticky) -->
                    <aside class="hidden lg:block w-64 flex-shrink-0 border-r border-paper-border/50 relative">
                        <div class="sticky top-0 h-[calc(100vh-4rem)] overflow-y-auto no-scrollbar py-8 pr-6 pl-4 lg:pl-8">
                            ${renderNavigationList(paper, false)}
                        </div>
                    </aside>

                    <!-- Paper Content Column -->
                    <main class="flex-grow min-w-0 py-8 px-4 lg:px-12 pb-32">
                        ${renderPaperBody(paper)}
                    </main>

                </div>
            `;

            // Mobile Nav Overlay (Drawer)
            const drawer = document.createElement('div');
            drawer.id = 'mobile-drawer-container';
            app.appendChild(drawer);
            renderMobileNavOverlay();

            // Bind Event Listeners
            document.getElementById('paper-select').addEventListener('change', (e) => selectPaper(e.target.value));

            // Run KaTeX & Icons
            renderMath();
            lucide.createIcons();
        }

        function renderMobileNavOverlay() {
            const container = document.getElementById('mobile-drawer-container');
            if (!container) return;

            if (!state.mobileNavOpen) {
                container.innerHTML = '';
                // Unlock body scroll
                document.body.style.overflow = '';
                return;
            }

            // Lock body scroll
            document.body.style.overflow = 'hidden';
            
            const paper = getCurrentPaper();

            container.innerHTML = `
                <div class="fixed inset-0 z-50 flex justify-end" role="dialog" aria-modal="true">
                    <!-- Backdrop -->
                    <div class="absolute inset-0 bg-black/20 backdrop-blur-sm" onclick="toggleMobileNav()"></div>
                    
                    <!-- Drawer -->
                    <div class="relative w-full max-w-xs bg-paper-surface h-full shadow-xl flex flex-col animate-in slide-in-from-right duration-200">
                        <div class="flex items-center justify-between p-4 border-b border-paper-border">
                            <h2 class="text-sm font-semibold text-paper-text">Jump to</h2>
                            <button onclick="toggleMobileNav()" class="p-2 rounded-md hover:bg-paper-border text-paper-muted hover:text-paper-text transition-colors">
                                <i data-lucide="x" class="w-5 h-5"></i>
                                <span class="sr-only">Close navigation</span>
                            </button>
                        </div>
                        <div class="flex-1 overflow-y-auto p-4">
                            ${renderNavigationList(paper, true)}
                        </div>
                    </div>
                </div>
            `;
            lucide.createIcons();
        }

        function renderNavigationList(paper, isMobile) {
            let html = '<nav class="flex flex-col gap-1" aria-label="Question navigation">';
            
            // Check for sections
            const hasSections = paper.sections && paper.sections.length > 0;
            const nodes = hasSections ? paper.sections : (paper.questions || []);

            // Helper for recursive linear list (Navigation is flat list)
            const flattenQuestions = (items) => {
                let flat = [];
                items.forEach(q => {
                    flat.push(q);
                    if (q.children && q.children.length > 0) {
                        flat = flat.concat(flattenQuestions(q.children));
                    }
                });
                return flat;
            };

            if (hasSections) {
                nodes.forEach(section => {
                    // Render Section Label if exists
                    if (section.label && section.label.trim().length > 0) {
                        html += `
                            <div class="mt-4 mb-2 first:mt-0 text-xs font-bold text-paper-muted uppercase tracking-wider select-none px-2">
                                ${section.label}
                            </div>
                        `;
                    }
                    const sectionQs = flattenQuestions(section.questions || []);
                    sectionQs.forEach(q => {
                        html += renderNavItem(q);
                    });
                });
            } else {
                const flatQs = flattenQuestions(nodes);
                flatQs.forEach(q => {
                    html += renderNavItem(q);
                });
            }

            html += '</nav>';
            return html;
        }

        function renderNavItem(question) {
            // Hierarchy via type scale/quietness, same left edge
            // Using ID length or specific regex to guess "sub-question" for styling is fragile,
            // but brief says "nesting depth is derived ONLY from children[]". 
            // BUT flattened list loses depth context unless passed.
            // Wait, we need to pass depth to `renderNavItem` or calculate it. 
            // Let's keep it simple: The visual design brief says "Navigation is visually flat... no nested visual indentation... hierarchy via restrained type scale".
            // Since we flattened the list, we treat them mostly equally but maybe smaller font for long IDs? 
            // Actually, we can check if the ID implies nesting (like contains brackets) as a heuristic since we don't have depth in the flattened array easily without traversing differently.
            // Let's just render identifiers purely flat as requested. "No visual indentation".
            
            // Determine if active? We don't track active scroll position in this prototype (add-on not required, but good UX). 
            // We will just render links.
            
            return `
                <button onclick="scrollToQuestion('${question.id}')" class="text-left w-full py-1.5 px-2 rounded hover:bg-paper-border/40 transition-colors text-sm text-paper-muted hover:text-paper-text focus-visible:ring-2 focus-visible:ring-accent outline-none">
                    <span class="font-medium font-sans text-paper-text/80 hover:text-accent transition-colors">${question.id}</span>
                </button>
            `;
        }

        function renderPaperBody(paper) {
            let html = '<div class="flex flex-col gap-12">'; // Top level separation (largest)
            
            const hasSections = paper.sections && paper.sections.length > 0;
            
            if (hasSections) {
                paper.sections.forEach(section => {
                    html += `<section class="flex flex-col gap-12">`;
                    // Section Header
                    if (section.label && section.label.trim().length > 0) {
                        html += `
                            <div class="border-b border-paper-border pb-4 mb-4">
                                <h2 class="text-xl font-bold text-paper-text">${section.label}</h2>
                            </div>
                        `;
                    }
                    // Questions
                    (section.questions || []).forEach(q => {
                        html += renderQuestionNode(q, 0, paper.defaults);
                    });
                    html += `</section>`;
                });
            } else {
                (paper.questions || []).forEach(q => {
                    html += renderQuestionNode(q, 0, paper.defaults);
                });
            }
            
            html += '</div>';
            return html;
        }

        function renderQuestionNode(node, depth, paperDefaults) {
            const isTopLevel = depth === 0;
            const containerClass = isTopLevel ? "" : "mt-6"; // Separation for children
            const indentClass = depth > 0 ? "pl-4 lg:pl-8 border-l-2 border-transparent" : ""; // Indentation for children (subtle)
            
            // Check for Solution Block
            const hasSolutionBlock = !!node.solutionBlock;
            const answer = node.solutionBlock?.answer;
            const solutionDetails = node.solutionBlock?.solutionDetails;
            const hasSolutionDetails = !!solutionDetails;
            
            // Render Components
            const questionBody = processMarkdown(node.question || "");
            const answerBody = answer ? processMarkdown(answer) : null;
            
            // Check collapsed state
            const collapsed = isCollapsed(node.id);
            
            let html = `
                <div id="q-${node.id}" class="${containerClass} ${indentClass} group scroll-mt-24">
                    <!-- Question Body -->
                    <div class="flex gap-4">
                        <div class="flex-shrink-0 w-10 pt-1 text-sm font-bold text-paper-muted/80 select-none text-right">
                            ${node.id}
                        </div>
                        <div class="flex-grow min-w-0">
                            <!-- Prompt -->
                            <div class="prose max-w-none text-base text-paper-text font-medium">
                                ${questionBody}
                            </div>
            `;
            
            if (hasSolutionBlock) {
                html += `<div class="mt-4 flex flex-col gap-4">`; // Gap between Question and Solution Block
                
                // Answer (Visible by default if present)
                if (answer) {
                    html += `
                        <div class="relative">
                            <div class="text-xs font-bold text-paper-muted uppercase tracking-wider mb-1">Answer</div>
                            <div class="prose max-w-none text-paper-text bg-paper-bg">
                                ${answerBody}
                            </div>
                        </div>
                    `;
                }
                
                // Solution Details Control & Content
                if (hasSolutionDetails) {
                    const btnId = `toggle-btn-${node.id}`;
                    const contentId = `solution-details-${node.id}`;
                    const iconRotate = collapsed ? "" : "rotate-180";
                    const btnText = collapsed ? "Show working" : "Hide working";
                    const hiddenClass = collapsed ? "hidden" : "";
                    
                    html += `
                        <div class="mt-1">
                            <!-- Toggle -->
                            <button id="${btnId}" onclick="toggleSolution('${node.id}')" class="flex items-center gap-2 text-sm font-medium text-accent hover:text-accent-hover transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-1 focus-visible:ring-accent rounded px-1 -ml-1">
                                <span>${btnText}</span>
                                <i data-lucide="chevron-down" class="w-4 h-4 transition-transform duration-200 ${iconRotate}"></i>
                            </button>
                            
                            <!-- Expandable Region -->
                            <div id="${contentId}" class="${hiddenClass} mt-4 pl-0 lg:pl-0 border-l-2 border-accent/20 ml-0.5 pl-4 animate-in fade-in slide-in-from-top-2 duration-200">
                                <div class="flex flex-col gap-6 text-sm lg:text-base">
                    `;
                    
                    // Order: Keep in mind, Formulas used, Working, Alternative working
                    
                    // Keep in Mind
                    if (solutionDetails.keepInMind) {
                        html += `
                            <div class="bg-yellow-50/50 p-4 rounded-sm border-l-2 border-yellow-200 text-stone-800">
                                <div class="font-bold text-xs uppercase tracking-wider text-stone-500 mb-2">Keep in mind</div>
                                <div class="prose max-w-none prose-sm">
                                    ${processMarkdown(solutionDetails.keepInMind)}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Formulas Used
                    if (solutionDetails.formulasUsed) {
                        html += `
                            <div>
                                <div class="font-bold text-xs uppercase tracking-wider text-paper-muted mb-2">Formulas used</div>
                                <div class="prose max-w-none text-paper-muted">
                                    ${processMarkdown(solutionDetails.formulasUsed)}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Working (Primary)
                    if (solutionDetails.working) {
                        html += `
                            <div>
                                <div class="font-bold text-xs uppercase tracking-wider text-paper-muted mb-2">Working</div>
                                <div class="prose max-w-none text-paper-text/90">
                                    ${processMarkdown(solutionDetails.working)}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Alternative Working (Array)
                    if (solutionDetails.alternativeWorking && Array.isArray(solutionDetails.alternativeWorking)) {
                        solutionDetails.alternativeWorking.forEach((alt, idx) => {
                            html += `
                                <div class="pt-4 border-t border-paper-border/50">
                                    <div class="font-bold text-xs uppercase tracking-wider text-paper-muted mb-2">Alternative working</div>
                                    <div class="prose max-w-none text-paper-text/90">
                                        ${processMarkdown(alt)}
                                    </div>
                                </div>
                            `;
                        });
                    } else if (typeof solutionDetails.alternativeWorking === 'string') {
                         // Fallback if string
                         html += `
                            <div class="pt-4 border-t border-paper-border/50">
                                <div class="font-bold text-xs uppercase tracking-wider text-paper-muted mb-2">Alternative working</div>
                                <div class="prose max-w-none text-paper-text/90">
                                    ${processMarkdown(solutionDetails.alternativeWorking)}
                                </div>
                            </div>
                        `;
                    }
                    
                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                html += `</div>`; // End Solution Block Wrapper
            }
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            // Recursively render children
            if (node.children && node.children.length > 0) {
                // Children container
                html += `<div class="flex flex-col gap-6 mt-6">`;
                node.children.forEach(child => {
                    html += renderQuestionNode(child, depth + 1, paperDefaults);
                });
                html += `</div>`;
            }
            
            return html;
        }

        // --- UTILS: MARKDOWN & MATH ---
        function processMarkdown(text) {
            if (!text) return '';
            if (!md) return text; // Fallback
            // Fix tables: markdown-it renders standard tables. We need to wrap them for overflow.
            // Since markdown-it output is string, we can string-replace <table> with wrapper? 
            // Or rely on CSS max-width. CSS overflow-x on table parent is best.
            // Let's wrap tables in a div via simple regex post-processing or a custom renderer.
            // Regex for simple replacement:
            let html = md.render(text);
            html = html.replace(/<table>/g, '<div class="rtq-table-wrapper"><table class="rtq-table">');
            html = html.replace(/<\/table>/g, '</table></div>');
            return html;
        }

        function renderMath() {
            // KaTeX Auto-render
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false,
                output: 'html', // Accessible HTML
                trust: true // Allow basic commands
            });
        }

        // --- START ---
        init();

    </script>
</body>
</html>
