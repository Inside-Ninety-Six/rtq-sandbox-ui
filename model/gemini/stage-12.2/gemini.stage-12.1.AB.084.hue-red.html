<!DOCTYPE html>
<html lang="en">
<head>
  <!-- RTQ_RUN {"generator":"rtq-prototype-batch","model":"gemini-3-pro-preview","prefix":"gemini.stage-12.1","variant":"AB","indexWithinVariant":"84","totalWithinVariant":"200","hueFamily":"red","intensityMode":"","primaryHueFamily":"","secondaryHueFamily":"","dualIntensityMode":"","timestamp":"2026-01-08T17:12:15.595Z"} -->
  <meta name="rtq-run" content='{&quot;generator&quot;:&quot;rtq-prototype-batch&quot;,&quot;model&quot;:&quot;gemini-3-pro-preview&quot;,&quot;prefix&quot;:&quot;gemini.stage-12.1&quot;,&quot;variant&quot;:&quot;AB&quot;,&quot;indexWithinVariant&quot;:&quot;84&quot;,&quot;totalWithinVariant&quot;:&quot;200&quot;,&quot;hueFamily&quot;:&quot;red&quot;,&quot;intensityMode&quot;:&quot;&quot;,&quot;primaryHueFamily&quot;:&quot;&quot;,&quot;secondaryHueFamily&quot;:&quot;&quot;,&quot;dualIntensityMode&quot;:&quot;&quot;,&quot;timestamp&quot;:&quot;2026-01-08T17:12:15.595Z&quot;}'>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTQ Maths Paper Viewer</title>

    <!-- Tailwind CSS (via CDN for prototyping) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        // COLORLAB B: FORCED HUE FAMILY = RED
                        // Using slate for neutrals to keep it cool/paper-like, red for accents
                        neutral: {
                            50: '#f9fafb',
                            100: '#f3f4f6', 
                            200: '#e5e7eb',
                            300: '#d1d5db',
                            400: '#9ca3af',
                            500: '#6b7280',
                            600: '#4b5563',
                            700: '#374151',
                            800: '#1f2937',
                            900: '#111827',
                        },
                        accent: {
                            50: '#fef2f2',
                            100: '#fee2e2',
                            200: '#fecaca',
                            300: '#fca5a5',
                            400: '#f87171',
                            500: '#ef4444',
                            600: '#dc2626', // Primary interactive red
                            700: '#b91c1c',
                            800: '#991b1b',
                            900: '#7f1d1d',
                        }
                    }
                }
            }
        }
    </script>

    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- External Libraries (KaTeX JS, Markdown-it) -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <style>
        /* Base reset & Typography overrides */
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Scrollbar hiding for Nav */
        .scrollbar-none {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .scrollbar-none::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        /* KaTeX Containment Invariant */
        /* Display math must not overflow page */
        .katex-display {
            margin: 1em 0;
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 2px; /* Scrollbar breathing room */
        }
        /* Inline math background invariant */
        .katex {
            background-color: transparent !important;
        }
        
        /* Table styles for Markdown */
        .prose table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
            margin: 1rem 0;
        }
        .prose th, .prose td {
            border: 1px solid #e5e7eb; /* neutral-200 */
            padding: 0.5rem;
            text-align: left;
        }
        .prose th {
            font-weight: 600;
            background-color: transparent;
        }
        .prose td {
            vertical-align: top;
        }

        /* Markdown Content Rhythm */
        .prose p {
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }
        .prose p:last-child {
            margin-bottom: 0;
        }
        .prose ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .prose ol {
            list-style-type: decimal;
            padding-left: 1.5rem;
            margin-bottom: 0.75rem;
        }

        /* Focus styles */
        :focus-visible {
            outline: 2px solid #dc2626; /* accent-600 */
            outline-offset: 2px;
        }

        /* Nav Sticky Behavior */
        .nav-sticky {
            position: sticky;
            top: 0;
            height: 100vh;
        }

        /* Drawer Transition */
        .drawer-transform {
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
    </style>
</head>
<body class="bg-white text-neutral-900">

    <!-- App Root -->
    <div id="app"></div>

    <script>
        // ===== STAGE 0: CONSTANTS =====
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        // ===== STATE =====
        let state = {
            papers: [],
            currentPaperKey: null,
            payloadLoaded: false,
            payloadError: false,
            isDrawerOpen: false,
            // Track expanded states per question ID. 
            // If paper defaults expandedAll=true, we treat missing keys as expanded.
            // If expandedAll=false, we treat missing keys as collapsed.
            expandedState: {} 
        };

        // ===== MARKDOWN CONFIGURATION =====
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            breaks: false // Critical: prevent <br> in math blocks
        }) : null;

        if (md) {
            // Disable escape rule to preserve TeX backslashes
            md.inline.ruler.disable(['escape']);
        }

        // ===== DOM ELEMENTS =====
        const app = document.getElementById('app');

        // ===== CORE FUNCTIONS =====

        async function init() {
            try {
                const response = await fetch(RTQ_PAPERS_PAYLOAD_PATH);
                if (!response.ok) throw new Error("Payload missing");
                const data = await response.json();
                
                state.papers = data.papers || [];
                if (state.papers.length > 0) {
                    // Default to first paper
                    selectPaper(state.papers[0].key);
                }
                state.payloadLoaded = true;
            } catch (e) {
                console.error(e);
                state.payloadError = true;
            }
            render();
        }

        function selectPaper(key) {
            state.currentPaperKey = key;
            state.expandedState = {}; // Reset expansion state
            state.isDrawerOpen = false;
            // Scroll to top
            window.scrollTo(0, 0);
            render();
        }

        function toggleDrawer() {
            state.isDrawerOpen = !state.isDrawerOpen;
            render();
        }

        function toggleSolution(questionId) {
            const paper = getCurrentPaper();
            const defaultExpanded = paper.defaults?.expandedAll !== false; // Default true unless explicitly false
            
            // Current state logic
            const isCurrentlyExpanded = state.expandedState.hasOwnProperty(questionId) 
                ? state.expandedState[questionId] 
                : defaultExpanded;

            state.expandedState[questionId] = !isCurrentlyExpanded;
            renderPaperContent(); // Re-render just the paper part to preserve scroll
        }

        function scrollToQuestion(id) {
            // Close drawer if open (mobile)
            if (state.isDrawerOpen) {
                toggleDrawer();
            }
            
            const el = document.getElementById(`q-${id}`);
            if (el) {
                // Smooth scroll with offset for sticky headers/comfort
                const y = el.getBoundingClientRect().top + window.pageYOffset - 24;
                window.scrollTo({top: y, behavior: 'smooth'});
            }
        }

        function getCurrentPaper() {
            return state.papers.find(p => p.key === state.currentPaperKey);
        }

        function getQuestionIsExpanded(questionId, paper) {
            const defaultExpanded = paper.defaults?.expandedAll !== false;
            if (state.expandedState.hasOwnProperty(questionId)) {
                return state.expandedState[questionId];
            }
            return defaultExpanded;
        }

        // ===== RENDERING =====

        function render() {
            app.innerHTML = '';
            
            if (state.payloadError) {
                app.innerHTML = `
                    <div class="flex items-center justify-center min-h-screen">
                        <div class="text-neutral-500 font-medium">PAPERS PAYLOAD MISSING</div>
                    </div>
                `;
                return;
            }

            if (!state.payloadLoaded) {
                app.innerHTML = `
                    <div class="flex items-center justify-center min-h-screen">
                        <div class="text-neutral-400">Loading...</div>
                    </div>
                `;
                return;
            }

            const currentPaper = getCurrentPaper();

            // Shell Container
            const shell = document.createElement('div');
            shell.className = "max-w-7xl mx-auto min-h-screen flex flex-col md:flex-row relative";

            // Mobile Top Bar (Nav Trigger + Selector)
            const mobileHeader = document.createElement('div');
            mobileHeader.className = "md:hidden sticky top-0 z-30 bg-white/95 backdrop-blur border-b border-neutral-100 px-4 h-14 flex items-center justify-between";
            mobileHeader.innerHTML = `
                <button id="drawer-trigger" class="text-sm font-medium text-accent-600 focus:outline-none">
                    Jump to
                </button>
                <div id="mobile-selector-mount"></div>
            `;
            shell.appendChild(mobileHeader);

            // Desktop Nav Column
            const navCol = document.createElement('aside');
            navCol.className = "hidden md:block w-48 lg:w-64 flex-shrink-0 border-r border-neutral-100 bg-white nav-sticky overflow-y-auto scrollbar-none";
            
            // Top Controls (Desktop)
            const desktopControls = document.createElement('div');
            desktopControls.className = "p-6 pb-4";
            
            // Paper Selector Component
            const selectorContainer = document.createElement('div');
            selectorContainer.className = "relative";
            const select = document.createElement('select');
            select.className = "appearance-none w-full bg-neutral-50 border border-neutral-200 text-neutral-700 py-2 px-3 pr-8 rounded focus:outline-none focus:ring-1 focus:ring-accent-600 text-sm";
            select.addEventListener('change', (e) => selectPaper(e.target.value));
            
            state.papers.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.key;
                opt.textContent = p.label;
                opt.selected = p.key === state.currentPaperKey;
                select.appendChild(opt);
            });
            
            // Chevron for select
            const chevron = document.createElement('div');
            chevron.className = "pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-neutral-500";
            chevron.innerHTML = `<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>`;
            
            selectorContainer.appendChild(select);
            selectorContainer.appendChild(chevron);
            desktopControls.appendChild(selectorContainer);
            
            navCol.appendChild(desktopControls);
            
            // Navigation List
            const navList = document.createElement('nav');
            navList.className = "px-6 pb-10 space-y-1";
            navList.appendChild(renderNavigationList(currentPaper));
            navCol.appendChild(navList);

            shell.appendChild(navCol);

            // Paper Content Column
            const paperCol = document.createElement('main');
            paperCol.id = "paper-content-region";
            paperCol.className = "flex-1 min-w-0 bg-white relative";
            
            // We'll render paper content into a container we can re-render independently
            const paperContainer = document.createElement('div');
            paperContainer.id = "paper-container";
            paperCol.appendChild(paperContainer);

            shell.appendChild(paperCol);
            app.appendChild(shell);

            // Render Paper Content
            renderPaperContent();

            // Mobile Selector Injection
            // Clone the selector for mobile header
            const mobileSelectorMount = document.getElementById('mobile-selector-mount');
            if (mobileSelectorMount) {
                const mobileSelContainer = selectorContainer.cloneNode(true);
                const mobileSelect = mobileSelContainer.querySelector('select');
                mobileSelect.value = state.currentPaperKey;
                mobileSelect.addEventListener('change', (e) => selectPaper(e.target.value));
                mobileSelectorMount.appendChild(mobileSelContainer);
            }

            // Mobile Drawer Logic
            document.getElementById('drawer-trigger')?.addEventListener('click', toggleDrawer);
            renderDrawer(currentPaper);
        }

        function renderNavigationList(paper) {
            const wrapper = document.createElement('div');
            
            // Helper to render recursively or flat depending on model. 
            // Design brief says: Flat list, identifiers only. Section labels as separators.
            
            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    // Section Label (if present)
                    if (section.label && section.label.trim().length > 0) {
                        const secHeader = document.createElement('div');
                        secHeader.className = "mt-6 mb-2 text-xs font-semibold text-neutral-400 uppercase tracking-wider select-none";
                        secHeader.textContent = section.label;
                        wrapper.appendChild(secHeader);
                    } else if (idx > 0) {
                        // Spacing if no label but new section
                        const spacer = document.createElement('div');
                        spacer.className = "h-4";
                        wrapper.appendChild(spacer);
                    }

                    // Questions
                    renderNavItems(section.questions, wrapper);
                });
            } else if (paper.questions) {
                renderNavItems(paper.questions, wrapper);
            }

            return wrapper;
        }

        function renderNavItems(questions, container) {
            questions.forEach(q => {
                // Item
                const btn = document.createElement('button');
                btn.className = "group flex w-full items-center text-left py-1 text-sm font-medium text-neutral-500 hover:text-neutral-900 focus:outline-none focus:text-accent-600 transition-colors duration-200";
                
                // Active state logic could be here (intersection observer), 
                // but strictly we just need jump functionality.
                
                // Content
                // Hierarchy via type scale is tricky in a flat list loop, 
                // but the brief says "Flat list... no nested visual indentation".
                // We'll keep it simple: identifier only.
                
                const idSpan = document.createElement('span');
                idSpan.textContent = q.id;
                // Subtle hierarchy cue: if id length > 3 or contains parens, maybe lighter?
                // Keeping strict to brief: "Hierarchy via type scale... same left edge"
                
                // Checking depth implicitly: typically shorter IDs are top level.
                // We won't over-engineer detection, just render flat.
                
                btn.appendChild(idSpan);
                
                btn.addEventListener('click', () => scrollToQuestion(q.id));
                container.appendChild(btn);

                // Children (Flattened)
                if (q.children && q.children.length > 0) {
                    renderNavItems(q.children, container);
                }
            });
        }

        function renderDrawer(paper) {
            // Remove existing drawer if any
            const existing = document.getElementById('mobile-drawer');
            if (existing) existing.remove();

            if (!state.isDrawerOpen) return;

            const overlay = document.createElement('div');
            overlay.id = "mobile-drawer";
            overlay.className = "fixed inset-0 z-50 flex md:hidden";

            // Backdrop
            const backdrop = document.createElement('div');
            backdrop.className = "absolute inset-0 bg-neutral-900/20 backdrop-blur-sm transition-opacity";
            backdrop.addEventListener('click', toggleDrawer);
            overlay.appendChild(backdrop);

            // Panel
            const panel = document.createElement('div');
            panel.className = "relative flex-1 w-64 max-w-[80%] bg-white shadow-xl h-full flex flex-col drawer-transform";
            
            // Header
            const header = document.createElement('div');
            header.className = "flex items-center justify-between px-4 h-14 border-b border-neutral-100 flex-shrink-0";
            header.innerHTML = `<span class="font-semibold text-neutral-900">Jump to</span>`;
            const closeBtn = document.createElement('button');
            closeBtn.className = "text-neutral-500 hover:text-neutral-900 p-1";
            closeBtn.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>`;
            closeBtn.addEventListener('click', toggleDrawer);
            header.appendChild(closeBtn);
            panel.appendChild(header);

            // List
            const listRegion = document.createElement('div');
            listRegion.className = "flex-1 overflow-y-auto p-4 space-y-1";
            listRegion.appendChild(renderNavigationList(paper));
            panel.appendChild(listRegion);

            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        function renderPaperContent() {
            const container = document.getElementById('paper-container');
            if (!container) return;
            
            // Save scroll position relative to questions? 
            // The browser usually handles this if we replace innerHTML quickly, 
            // but since expansion changes height, natural layout shift occurs.
            // Brief says: "Expanding... must not intentionally reposition... beyond natural layout shift".
            // So we just re-render.

            container.innerHTML = '';
            const paper = getCurrentPaper();

            const paperWrapper = document.createElement('div');
            paperWrapper.className = "max-w-3xl mx-auto px-6 py-8 md:py-12";

            if (paper.sections) {
                paper.sections.forEach((section, idx) => {
                    // Section Header
                    if (section.label && section.label.trim().length > 0) {
                        const secEl = document.createElement('div');
                        secEl.className = "border-b border-neutral-200 pb-2 mb-8 mt-12 first:mt-0";
                        secEl.innerHTML = `<h2 class="text-xl font-semibold text-neutral-900">${section.label}</h2>`;
                        paperWrapper.appendChild(secEl);
                    }
                    
                    const qList = document.createElement('div');
                    qList.className = "space-y-12"; // Top level spacing
                    section.questions.forEach(q => {
                        qList.appendChild(renderQuestionNode(q, paper, 0));
                    });
                    paperWrapper.appendChild(qList);
                });
            } else if (paper.questions) {
                const qList = document.createElement('div');
                qList.className = "space-y-12";
                paper.questions.forEach(q => {
                    qList.appendChild(renderQuestionNode(q, paper, 0));
                });
                paperWrapper.appendChild(qList);
            }
            
            // Bottom padding
            const spacer = document.createElement('div');
            spacer.className = "h-32";
            paperWrapper.appendChild(spacer);

            container.appendChild(paperWrapper);

            // Run KaTeX
            renderMathInElement(container, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false,
                output: 'html' // Use HTML output for better accessibility/layout
            });
        }

        function renderQuestionNode(node, paper, depth) {
            const wrapper = document.createElement('div');
            wrapper.id = `q-${node.id}`;
            wrapper.className = "group/node relative";

            // Indentation logic via spacing (not container borders)
            // Depth 0: no indent. Depth 1: pl-0 or small. 
            // Brief says: "Sub-questions... distinguished using indentation... not visual containers"
            // We'll apply padding-left based on depth, but keep it responsive.
            // Mobile: keep indentation small to preserve width.
            const paddingClass = depth > 0 ? (depth === 1 ? "pl-4 md:pl-8" : "pl-6 md:pl-12") : "";
            if (paddingClass) wrapper.className += ` ${paddingClass}`;
            
            // Spacing between siblings at depth > 0 is tighter
            const spacingClass = depth > 0 ? "mt-6" : "";
            if (spacingClass) wrapper.className += ` ${spacingClass}`;

            // 1. Question Body
            const qBody = document.createElement('div');
            qBody.className = "text-neutral-900";
            
            // Identifier
            const idEl = document.createElement('span');
            idEl.className = "font-bold text-neutral-500 mr-2 select-none";
            idEl.textContent = node.id;
            
            // Render MD content
            const contentHtml = md ? md.render(node.question || '') : (node.question || '');
            
            // Combine ID + Content. 
            // The content usually comes wrapped in <p>. We want the ID to be visually inline-block or floating.
            // A clean way is a flex row or float.
            // Let's use a flex layout for ID and Body to handle alignment nicely.
            const flexRow = document.createElement('div');
            flexRow.className = "flex items-start";
            
            const idCol = document.createElement('div');
            idCol.className = "flex-shrink-0 w-8 md:w-12 pt-0.5"; // Fixed width for alignment
            idCol.appendChild(idEl);

            const contentCol = document.createElement('div');
            contentCol.className = "flex-1 min-w-0 prose prose-neutral max-w-none text-neutral-900 prose-p:leading-normal prose-p:my-1";
            contentCol.innerHTML = contentHtml;

            // Using flex for top-level, but for sub-questions inline might be better?
            // Let's try standard flow with float/inline-block for simplicity and robustness with markdown paragraphs.
            // Actually, separating ID column is cleaner for scanning.
            
            flexRow.appendChild(idCol);
            flexRow.appendChild(contentCol);
            qBody.appendChild(flexRow);
            wrapper.appendChild(qBody);

            // 2. Solution Block
            if (node.solutionBlock) {
                const sb = node.solutionBlock;
                const hasAnswer = !!sb.answer;
                const hasDetails = !!sb.solutionDetails;

                if (hasAnswer || hasDetails) {
                    const sbWrapper = document.createElement('div');
                    // Align with content column (skip ID width)
                    sbWrapper.className = "ml-8 md:ml-12 mt-3";

                    // Answer
                    if (hasAnswer) {
                        const ansRow = document.createElement('div');
                        ansRow.className = "mb-3 text-neutral-900 flex items-baseline gap-2";
                        
                        const ansLabel = document.createElement('span');
                        ansLabel.className = "text-xs font-bold uppercase tracking-wide text-neutral-500 select-none";
                        ansLabel.textContent = "Answer";
                        
                        const ansVal = document.createElement('div');
                        ansVal.className = "prose prose-neutral max-w-none prose-p:my-0 font-medium";
                        ansVal.innerHTML = md ? md.render(sb.answer) : sb.answer;

                        ansRow.appendChild(ansLabel);
                        ansRow.appendChild(ansVal);
                        sbWrapper.appendChild(ansRow);
                    }

                    // Solution Details Toggle
                    if (hasDetails) {
                        const isExpanded = getQuestionIsExpanded(node.id, paper);
                        
                        // Toggle Control
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = "group flex items-center text-sm font-medium text-accent-600 hover:text-accent-700 focus:outline-none transition-colors mb-2";
                        toggleBtn.onclick = () => toggleSolution(node.id);
                        
                        const chevron = isExpanded 
                            ? `<svg class="w-4 h-4 mr-1 transition-transform rotate-180" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>`
                            : `<svg class="w-4 h-4 mr-1 transition-transform rotate-0" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>`;
                        
                        toggleBtn.innerHTML = `${chevron}<span>${isExpanded ? 'Hide working' : 'Show working'}</span>`;
                        sbWrapper.appendChild(toggleBtn);

                        // Expanded Content
                        if (isExpanded) {
                            const details = sb.solutionDetails;
                            const detailsRegion = document.createElement('div');
                            // Region Styling: Stage 5 permits subtle cues.
                            // We use a transparent background but ensure spacing. 
                            // Add a subtle left border to demarcate region boundary visually without being a "box".
                            detailsRegion.className = "relative pl-4 border-l-2 border-neutral-100 mt-2 space-y-6";

                            // Helper for subsections
                            const renderSubsection = (label, content, isList = false) => {
                                if (!content) return null;
                                const sub = document.createElement('div');
                                const subLabel = document.createElement('div');
                                subLabel.className = "text-xs font-bold text-neutral-400 uppercase tracking-wider mb-1";
                                subLabel.textContent = label;
                                
                                const subBody = document.createElement('div');
                                subBody.className = "prose prose-neutral max-w-none text-neutral-700 text-sm";
                                if (isList && content.indexOf('- ') !== 0 && content.indexOf('* ') !== 0) {
                                    // if not already a list, maybe treat as lines? 
                                    // Payload usually has markdown lists.
                                }
                                subBody.innerHTML = md ? md.render(content) : content;
                                
                                sub.appendChild(subLabel);
                                sub.appendChild(subBody);
                                return sub;
                            };

                            // Keep in mind
                            const kim = renderSubsection('Keep in mind', details.keepInMind);
                            if (kim) detailsRegion.appendChild(kim);

                            // Formulas
                            const form = renderSubsection('Formulas used', details.formulasUsed);
                            if (form) detailsRegion.appendChild(form);

                            // Working
                            // Internal Grammar: Working vs Alt Working separation
                            if (details.working) {
                                const w = document.createElement('div');
                                const wLabel = document.createElement('div');
                                wLabel.className = "text-xs font-bold text-neutral-400 uppercase tracking-wider mb-1";
                                wLabel.textContent = "Working";
                                w.appendChild(wLabel);
                                
                                const wBody = document.createElement('div');
                                wBody.className = "prose prose-neutral max-w-none text-neutral-800";
                                wBody.innerHTML = md ? md.render(details.working) : details.working;
                                w.appendChild(wBody);
                                
                                detailsRegion.appendChild(w);
                            }

                            // Alternative Working
                            if (details.alternativeWorking && Array.isArray(details.alternativeWorking)) {
                                details.alternativeWorking.forEach((alt, idx) => {
                                    const aw = document.createElement('div');
                                    // Stronger separation from main working (Stage 5.8.7)
                                    aw.className = "pt-4 border-t border-neutral-100 border-dashed"; 
                                    
                                    const awLabel = document.createElement('div');
                                    awLabel.className = "text-xs font-bold text-neutral-400 uppercase tracking-wider mb-1";
                                    awLabel.textContent = "Alternative working";
                                    aw.appendChild(awLabel);
                                    
                                    const awBody = document.createElement('div');
                                    awBody.className = "prose prose-neutral max-w-none text-neutral-800";
                                    awBody.innerHTML = md ? md.render(alt) : alt;
                                    aw.appendChild(awBody);
                                    
                                    detailsRegion.appendChild(aw);
                                });
                            }

                            sbWrapper.appendChild(detailsRegion);
                        }
                    }

                    wrapper.appendChild(sbWrapper);
                }
            }

            // 3. Children
            if (node.children && node.children.length > 0) {
                const childrenContainer = document.createElement('div');
                // No border, just spacing/indent handled by recursive calls
                node.children.forEach(child => {
                    childrenContainer.appendChild(renderQuestionNode(child, paper, depth + 1));
                });
                wrapper.appendChild(childrenContainer);
            }

            return wrapper;
        }

        // Start
        init();

    </script>
</body>
</html>
