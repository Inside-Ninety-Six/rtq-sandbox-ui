<!-- index.html -->
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>RTQ – Maths Paper Solution Viewer (Stress Test Harness)</title>

    <!-- KaTeX (CDN) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <style>
        :root {
            --bg: #f7f7f7;
            --paper: #ffffff;
            --ink: #111111;
            --muted: #555555;
            --line: #e6e6e6;
            --line-strong: #cfcfcf;
            --shadow: rgba(0, 0, 0, 0.08);
            --radius: 10px;
            --gap: 16px;
            --focus: #000000;

            --subtle: #fbfbfb;
            --subtle2: #f9f9f9;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            color: var(--ink);
            background: var(--bg);
            line-height: 1.5;
        }

        :focus-visible {
            outline: 3px solid var(--focus);
            outline-offset: 2px;
        }

        /* Top controls (Paper selector remains) */
        .topbar {
            position: sticky;
            top: 0;
            z-index: 50;
            background: #efefef;
            border-bottom: 1px solid var(--line-strong);
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .topbar .left {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
            flex: 1 1 auto;
        }

        .topbar .title {
            font-weight: 900;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .control {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 0 0 auto;
        }

        label {
            font-size: 12px;
            font-weight: 900;
            color: var(--muted);
            white-space: nowrap;
        }

        select {
            appearance: none;
            border: 1px solid var(--line-strong);
            background: #ffffff;
            color: var(--ink);
            border-radius: 8px;
            padding: 8px 10px;
            font-weight: 800;
            cursor: pointer;
        }

        .iconbtn {
            appearance: none;
            border: 1px solid var(--line-strong);
            background: #ffffff;
            color: var(--ink);
            border-radius: 8px;
            padding: 8px 10px;
            font-weight: 800;
            cursor: pointer;
        }

        .iconbtn:active {
            transform: translateY(1px);
        }

        /* Inline nav panel (single-page scroll; no nested scroll) */
        .navpanel {
            display: none;
            padding: 10px 12px 6px;
            border-bottom: 1px solid var(--line);
            background: #f2f2f2;
        }

        .navpanel.open {
            display: block;
        }

        /* App layout */
        .app {
            display: block;
            padding: 14px 12px 60px;
            max-width: 1250px;
            margin: 0 auto;
        }

        .layout {
            display: block;
        }

        /* Minimal navigation chrome (quiet text list style; no panel card) */
        .rail {
            display: none;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        .rail h2,
        .navpanel h2 {
            margin: 0 0 8px;
            font-size: 12px;
            font-weight: 900;
            color: var(--muted);
            letter-spacing: 0.2px;
        }

        .nav {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 6px;
        }

        .nav li {
            margin: 0;
        }

        .nav a {
            display: inline-block;
            padding: 0;
            border: none;
            background: transparent;
            border-radius: 0;
            text-decoration: none;
            color: var(--muted);
            font-weight: 900;
            font-size: 12px;
            line-height: 1.25;
        }

        .nav a:hover {
            color: var(--ink);
            text-decoration: underline;
            text-decoration-thickness: 2px;
            text-underline-offset: 2px;
        }

        .nav a:focus-visible {
            outline: 2px solid var(--focus);
            outline-offset: 3px;
            text-decoration: none;
        }

        .nav a small {
            display: block;
            margin-top: 2px;
            font-size: 11px;
            font-weight: 700;
            color: var(--muted);
            opacity: 0.85;
        }

        .nav-sep {
            padding: 0;
            border: none;
            background: transparent;
            border-radius: 0;
            font-weight: 900;
            font-size: 12px;
            color: var(--muted);
            letter-spacing: 0.3px;
            margin-top: 6px;
        }

        /* Paper */
        .paper {
            background: var(--paper);
            border: 1px solid var(--line-strong);
            border-radius: var(--radius);
            box-shadow: 0 2px 10px var(--shadow);
            padding: 18px 18px 10px;
            overflow: visible;
            /* no nested scroll */
        }

        .paper-header {
            padding-bottom: 10px;
            margin-bottom: 6px;
            border-bottom: 1px solid var(--line);
        }

        .paper-header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 950;
        }

        .paper-header p {
            margin: 6px 0 0;
            color: var(--muted);
            font-size: 13px;
        }

        /* Section headings (part of paper only when present) */
        .section {
            margin: 18px 0 0;
            padding: 12px 0 0;
            border-top: 1px solid var(--line);
        }

        .section h2 {
            margin: 0 0 10px;
            font-size: 16px;
            font-weight: 950;
        }

        /* Questions (no cards/panels around whole question) */
        .q {
            margin: 18px 0 0;
            padding: 0;
            background: transparent;
        }

        .q+.q {
            margin-top: 22px;
            padding-top: 18px;
            border-top: 1px solid var(--line);
        }

        .qhead {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            margin: 0 0 10px;
        }

        .qhead h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 950;
        }

        .qmeta {
            color: var(--muted);
            font-size: 12px;
            white-space: nowrap;
            font-weight: 900;
        }

        /* Nesting (indentation only; no borders) */
        .nest {
            margin-top: 14px;
            padding-left: 14px;
        }

        .nest.nest-2 {
            padding-left: 28px;
        }

        .nest h4,
        .nest h5 {
            margin: 0 0 8px;
            font-weight: 950;
        }

        .nest h4 {
            font-size: 14px;
        }

        .nest h5 {
            font-size: 13px;
        }

        /* Blocks (no borders) */
        .block {
            margin: 10px 0 0;
            padding: 0;
            background: transparent;
        }

        .block-title {
            margin: 0 0 6px;
            font-weight: 950;
            font-size: 13px;
            letter-spacing: 0.2px;
        }

        .block p {
            margin: 0 0 8px;
        }

        .block p:last-child {
            margin-bottom: 0;
        }

        /* Default visibility (finalised): answers visible, workings collapsed */
        .answer {
            margin-top: 12px;
            padding: 10px 12px;
            background: var(--subtle);
        }

        .working {
            margin-top: 10px;
            padding: 10px 12px;
            background: var(--subtle2);
        }

        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin: 0 0 6px;
        }

        .toggle-row .block-title {
            margin: 0;
        }

        .toggle {
            appearance: none;
            border: 1px solid var(--line-strong);
            background: #ffffff;
            color: var(--ink);
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 900;
            cursor: pointer;
            flex: 0 0 auto;
        }

        .working-content[hidden] {
            display: none;
        }

        .working-preview {
            color: var(--muted);
            font-size: 12.5px;
            margin: 0;
        }

        /* KaTeX rendering wrappers */
        .katex-inline {
            display: inline-block;
            padding: 0 2px;
            vertical-align: baseline;
        }

        .katex-block {
            margin: 6px 0;
        }

        .mathstack {
            display: grid;
            align-content: start;
            justify-content: left;
            gap: 6px;
            margin-top: 6px;
        }

        .mathline {
            padding: 8px 10px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #f3f3f3;
            overflow-wrap: anywhere;
        }

        .mathline.plain {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 13px;
        }

        /* Diagram wrapper inside question block */
        .diagram {
            margin: 10px 0 0;
            padding: 10px 10px;
            background: #f4f4f4;
            border: 1px solid var(--line);
            border-radius: 8px;
        }

        .diagram svg {
            width: 100%;
            height: auto;
            display: block;
        }

        /* Desktop responsive */
        @media (min-width: 900px) {
            .layout {
                display: grid;
                grid-template-columns: 240px 1fr;
                gap: var(--gap);
                align-items: start;
            }

            .rail {
                display: block;
            }

            .navpanel {
                display: none !important;
            }

            /* nav panel is for smaller screens */
            .topbar .left .iconbtn {
                display: none;
            }

            /* menu not needed on desktop */
        }
    </style>
</head>

<body>
    <!-- Sticky top controls (includes Paper Selector) -->
    <header class="topbar" aria-label="Top controls">
        <div class="left">
            <button class="iconbtn" id="navToggle" type="button" aria-controls="navPanel" aria-expanded="false">
                Menu
            </button>
            <div class="title">RTQ – Maths Paper (Continuous Scroll)</div>
        </div>

        <div class="control" aria-label="Paper selector control">
            <label for="paperSelect">Paper</label>
            <select id="paperSelect">
                <option value="short">Short paper</option>
                <option value="standard">Standard paper</option>
                <option value="standardExpanded">Standard (Workings Expanded)</option>
                <option value="diagram">Diagram-heavy paper</option>
                <option value="sectioned">Sectioned paper</option>
            </select>
        </div>
    </header>

    <!-- Inline navigation panel (mobile/tablet) -->
    <div class="navpanel" id="navPanel" aria-label="Navigation panel">
        <h2>Navigation</h2>
        <nav aria-label="Questions (panel)">
            <ul class="nav" id="navListPanel"></ul>
        </nav>
    </div>

    <main class="app">
        <div class="layout">
            <!-- Desktop rail -->
            <aside class="rail" aria-label="Question navigation (rail)">
                <h2>Navigation</h2>
                <nav aria-label="Questions (rail)">
                    <ul class="nav" id="navListRail"></ul>
                </nav>
            </aside>

            <!-- Paper container (single continuous document) -->
            <section class="paper" aria-label="Paper content">
                <div class="paper-header">
                    <h1 id="paperTitle">RTQ – Maths Paper</h1>
                    <p id="paperSubtitle">Answers visible by default. Workings collapsed by default. Questions always
                        visible.</p>
                </div>
                <div id="paperRoot"></div>
            </section>
        </div>
    </main>

    <script>
        (function () {
            // ------------------ Diagrams (inline SVG; grayscale; 4 types reused) ------------------
            function svgGeometry() {
                return `
          <div class="diagram" aria-label="Diagram (geometry)">
            <svg viewBox="0 0 320 180" role="img" aria-label="Geometry diagram">
              <rect x="1" y="1" width="318" height="178" fill="#fff" stroke="#cfcfcf" />
              <polygon points="70,140 160,40 250,140" fill="#f2f2f2" stroke="#444" stroke-width="2"/>
              <circle cx="160" cy="40" r="4" fill="#444"/>
              <circle cx="70" cy="140" r="4" fill="#444"/>
              <circle cx="250" cy="140" r="4" fill="#444"/>
              <text x="155" y="28" font-size="12" fill="#111">A</text>
              <text x="54" y="156" font-size="12" fill="#111">B</text>
              <text x="258" y="156" font-size="12" fill="#111">C</text>
              <text x="18" y="22" font-size="12" fill="#111">[math labels]</text>
            </svg>
          </div>`;
            }
            function svgBars() {
                return `
          <div class="diagram" aria-label="Diagram (ratio bars)">
            <svg viewBox="0 0 320 180" role="img" aria-label="Ratio bars diagram">
              <rect x="1" y="1" width="318" height="178" fill="#fff" stroke="#cfcfcf" />
              <text x="14" y="22" font-size="12" fill="#111">Ratio bars</text>
              <rect x="20" y="45" width="260" height="22" fill="#f2f2f2" stroke="#444"/>
              <g stroke="#444" stroke-width="2">
                <line x1="20" y1="45" x2="20" y2="67"/>
                <line x1="85" y1="45" x2="85" y2="67"/>
                <line x1="150" y1="45" x2="150" y2="67"/>
                <line x1="215" y1="45" x2="215" y2="67"/>
                <line x1="280" y1="45" x2="280" y2="67"/>
              </g>
              <text x="22" y="92" font-size="12" fill="#111">A</text>
              <text x="22" y="124" font-size="12" fill="#111">B</text>
              <rect x="20" y="100" width="180" height="22" fill="#eaeaea" stroke="#444"/>
              <rect x="20" y="132" width="240" height="22" fill="#f0f0f0" stroke="#444"/>
              <text x="200" y="114" font-size="12" fill="#111">[math labels]</text>
            </svg>
          </div>`;
            }
            function svgGrid() {
                return `
          <div class="diagram" aria-label="Diagram (coordinate grid)">
            <svg viewBox="0 0 320 180" role="img" aria-label="Coordinate grid diagram">
              <rect x="1" y="1" width="318" height="178" fill="#fff" stroke="#cfcfcf" />
              <g stroke="#dddddd">
                ${Array.from({ length: 15 }).map((_, i) => `<line x1="${20 + i * 20}" y1="20" x2="${20 + i * 20}" y2="160"/>`).join("")}
                ${Array.from({ length: 8 }).map((_, i) => `<line x1="20" y1="${20 + i * 20}" x2="300" y2="${20 + i * 20}"/>`).join("")}
              </g>
              <g stroke="#444" stroke-width="2">
                <line x1="20" y1="160" x2="300" y2="160"/>
                <line x1="20" y1="20" x2="20" y2="160"/>
              </g>
              <polyline points="40,140 120,100 200,80 280,40" fill="none" stroke="#444" stroke-width="2"/>
              <circle cx="120" cy="100" r="4" fill="#444"/>
              <circle cx="200" cy="80" r="4" fill="#444"/>
              <text x="205" y="72" font-size="12" fill="#111">P</text>
              <text x="24" y="18" font-size="12" fill="#111">[math labels]</text>
            </svg>
          </div>`;
            }
            function svgArray() {
                return `
          <div class="diagram" aria-label="Diagram (array)">
            <svg viewBox="0 0 320 180" role="img" aria-label="Array diagram">
              <rect x="1" y="1" width="318" height="178" fill="#fff" stroke="#cfcfcf" />
              <text x="14" y="22" font-size="12" fill="#111">Grid / array</text>
              <g stroke="#444" fill="#f2f2f2">
                ${Array.from({ length: 4 }).map((_, r) =>
                    Array.from({ length: 6 }).map((_, c) => {
                        const x = 30 + c * 40, y = 40 + r * 30;
                        return `<rect x="${x}" y="${y}" width="36" height="26"/>`;
                    }).join("")
                ).join("")}
              </g>
              <text x="30" y="160" font-size="12" fill="#111">[math labels]</text>
            </svg>
          </div>`;
            }
            const diagramTypes = { geometry: svgGeometry, bars: svgBars, grid: svgGrid, array: svgArray };

            // ------------------ Helpers ------------------
            function el(tag, attrs, children) {
                const node = document.createElement(tag);
                if (attrs) {
                    Object.keys(attrs).forEach(k => {
                        if (k === "class") node.className = attrs[k];
                        else if (k === "html") node.innerHTML = attrs[k];
                        else if (k.startsWith("aria-")) node.setAttribute(k, attrs[k]);
                        else if (k === "id") node.id = attrs[k];
                        else if (k === "href") node.setAttribute("href", attrs[k]);
                        else if (k === "type") node.setAttribute("type", attrs[k]);
                        else node.setAttribute(k, attrs[k]);
                    });
                }
                (children || []).forEach(ch => {
                    if (typeof ch === "string") node.appendChild(document.createTextNode(ch));
                    else if (ch) node.appendChild(ch);
                });
                return node;
            }

            function katexInline(tex) {
                // rendered at load time; falls back to plain text if KaTeX missing
                const span = el("span", { class: "katex-inline js-katex", "data-tex": tex, "data-display": "false" }, []);
                return span.outerHTML;
            }
            function katexBlock(tex) {
                const div = el("div", { class: "katex-block mathline js-katex", "data-tex": tex, "data-display": "true" }, []);
                return div.outerHTML;
            }

            function makeQuestionBlock(questionHtml, diagramKey) {
                const parts = [`<p class="block-title">Question</p>${questionHtml}`];
                if (diagramKey && diagramTypes[diagramKey]) parts.push(diagramTypes[diagramKey]());
                return el("div", { class: "block question", html: parts.join("") }, []);
            }

            function makeAnswerBlock(answerTexOrHtml, isTex) {
                const html = isTex
                    ? `<p class="block-title">Answer</p>${katexBlock(answerTexOrHtml)}`
                    : `<p class="block-title">Answer</p>${answerTexOrHtml}`;
                return el("div", { class: "block answer", html }, []);
            }

            function makeWorkingBlock(qid, texLines) {
                const working = el("div", { class: "block working" }, []);

                const toggleRow = el("div", { class: "toggle-row" }, [
                    el("p", { class: "block-title" }, ["Working"]),
                    el("button", {
                        class: "toggle js-working-toggle",
                        type: "button",
                        "aria-expanded": "false",
                        "data-target": qid + "-working"
                    }, ["Show working"])
                ]);

                const preview = el("p", { class: "working-preview" }, ["Working is hidden. Use “Show working” to expand inline."]);

                const content = el("div", { class: "working-content", id: qid + "-working" }, []);
                content.hidden = true;

                // Store TeX lines as JSON for rendering at load time
                const stack = el("div", {
                    class: "mathstack js-katex-stack",
                    "data-tex": JSON.stringify(texLines || [])
                }, []);
                content.appendChild(stack);

                working.appendChild(toggleRow);
                working.appendChild(preview);
                working.appendChild(content);
                return working;
            }

            // Recursive nesting renderer (each level: Question → Answer → Working)
            function renderNode(node, depth) {
                // depth 0 => top-level question
                const wrapperTag = depth === 0 ? "article" : "section";
                const wrapperClass = depth === 0 ? "q" : ("nest nest-" + depth);
                const wrapper = el(wrapperTag, { class: wrapperClass, id: node.id, "aria-label": node.label }, []);

                if (depth === 0) {
                    const head = el("div", { class: "qhead" }, [
                        el("h3", {}, [node.label]),
                        el("div", { class: "qmeta" }, [node.meta || node.label])
                    ]);
                    wrapper.appendChild(head);
                } else {
                    const hTag = depth === 1 ? "h4" : "h5";
                    wrapper.appendChild(el(hTag, {}, [node.label]));
                }

                wrapper.appendChild(makeQuestionBlock(node.questionHtml || "<p>(No prompt.)</p>", node.diagram || null));
                wrapper.appendChild(makeAnswerBlock(node.answerTex || "\\text{(answer)}", true));
                wrapper.appendChild(makeWorkingBlock(node.id, node.workingTexLines || ["x=1"]));

                if (node.children && node.children.length) {
                    node.children.forEach(ch => wrapper.appendChild(renderNode(ch, depth + 1)));
                }

                return wrapper;
            }

            // ------------------ Long working generators (50–60 TeX lines) ------------------
            function longAlgebraLines(seed) {
                // deterministic, valid KaTeX TeX lines; 55 lines
                const a = 2 + (seed % 5);
                const b = 3 + (seed % 7);
                const c = 1 + (seed % 4);
                const d = 4 + (seed % 6);

                const lines = [];
                lines.push(`\\text{Start: } (${a}x+${b})(x+${c})-${d}`);
                lines.push(`= ${a}x\\cdot x + ${a}x\\cdot ${c} + ${b}\\cdot x + ${b}\\cdot ${c} - ${d}`);
                lines.push(`= ${a}x^{2} + ${a * c}x + ${b}x + ${b * c} - ${d}`);
                lines.push(`= ${a}x^{2} + ${(a * c + b)}x + ${(b * c - d)}`);
                lines.push(`\\text{Complete the square:}`);
                lines.push(`= ${a}\\left(x^{2} + \\frac{${(a * c + b)}}{${a}}x\\right) + ${(b * c - d)}`);
                lines.push(`= ${a}\\left(x^{2} + \\frac{${(a * c + b)}}{${a}}x + \\left(\\frac{${(a * c + b)}}{${2 * a}}\\right)^{2}\\right) + ${(b * c - d)} - ${a}\\left(\\frac{${(a * c + b)}}{${2 * a}}\\right)^{2}`);
                lines.push(`= ${a}\\left(x + \\frac{${(a * c + b)}}{${2 * a}}\\right)^{2} + ${(b * c - d)} - \\frac{${(a * c + b) * (a * c + b)}}{${4 * a}}`);

                // filler transformations (varied, still algebraic)
                const base = (a * c + b);
                for (let i = 1; i <= 47; i++) {
                    const k = i + 1;
                    const p = base + (i % 9);
                    const q = (b * c - d) - (i % 7);
                    const r = (i % 5) + 2;
                    if (i % 6 === 0) {
                        lines.push(`\\text{Factor check: } ${a}x^{2} + ${p}x + ${q} = (\\sqrt{${a}}x + ${r})(\\sqrt{${a}}x + ${Math.max(1, r - 1)}) + \\text{(remainder)}`);
                    } else if (i % 6 === 1) {
                        lines.push(`\\text{Substitute } x=${k}:\\quad ${a}(${k})^{2} + ${p}(${k}) + ${q}`);
                    } else if (i % 6 === 2) {
                        lines.push(`= ${a * k * k} + ${p * k} + ${q}`);
                    } else if (i % 6 === 3) {
                        lines.push(`= ${(a * k * k + p * k + q)}`);
                    } else if (i % 6 === 4) {
                        lines.push(`\\text{Rewrite: } ${a}x^{2} + ${p}x + ${q} = ${a}\\left(x + \\frac{${p}}{${2 * a}}\\right)^{2} + \\left(${q} - \\frac{${p * p}}{${4 * a}}\\right)`);
                    } else {
                        lines.push(`\\text{Simplify: } \\frac{${p}}{${2 * a}} = \\frac{${p}}{${2 * a}}\\quad\\text{and}\\quad \\frac{${p * p}}{${4 * a}} = \\frac{${p * p}}{${4 * a}}`);
                    }
                }

                // ensure 55 lines total
                return lines.slice(0, 55);
            }

            function shortWorkingLines(seed) {
                const n = 3 + (seed % 4);
                return [
                    `\\text{Compute: } ${n}\\times 4`,
                    `= ${n * 4}`,
                    `\\text{Result: } ${n * 4}`
                ];
            }

            // ------------------ Datasets ------------------
            // Each dataset returns: { id, title, subtitle, navItems, nodes, defaultWorkingsExpanded }
            function buildShortPaper() {
                const nav = [];
                const nodes = [];

                // Q1
                const q1 = renderNode({
                    id: "short-q1",
                    label: "Question 1",
                    meta: "1",
                    questionHtml: `<p>A toy costs £3. How much do 4 toys cost?</p>`,
                    answerTex: `12`,
                    workingTexLines: [`4\\times 3`, `=12`]
                }, 0);
                nav.push({ type: "link", text: "1", href: "#short-q1", small: "Question 1" });
                nodes.push(q1);

                // Q2
                const q2 = renderNode({
                    id: "short-q2",
                    label: "Question 2",
                    meta: "2",
                    questionHtml: `<p>Write the next two numbers in the sequence:</p>${katexBlock("5,10,15,20,\\_,\\_")}`,
                    answerTex: `25,\\;30`,
                    workingTexLines: [`20+5=25`, `25+5=30`]
                }, 0);
                nav.push({ type: "link", text: "2", href: "#short-q2", small: "Question 2" });
                nodes.push(q2);

                // Q3 with deeper nesting: 3(a)(i), 3(a)(ii), 3(b)
                const q3Node = {
                    id: "short-q3",
                    label: "Question 3",
                    meta: "3",
                    questionHtml: `<p>Work with the expression ${katexInline("2x+6")}.</p>`,
                    answerTex: `\\text{See parts}`,
                    workingTexLines: [`\\text{Parts (a) and (b) follow.}`],
                    children: [
                        {
                            id: "short-q3a",
                            label: "Sub-question 3(a)",
                            questionHtml: `<p>Evaluate when ${katexInline("x=4")}.</p>`,
                            answerTex: `14`,
                            workingTexLines: [`2(4)+6`, `=8+6`, `=14`],
                            children: [
                                {
                                    id: "short-q3ai",
                                    label: "Sub-sub-question 3(a)(i)",
                                    questionHtml: `<p>Show substitution step.</p>`,
                                    answerTex: `2(4)+6`,
                                    workingTexLines: [`2x+6`, `\\Rightarrow 2(4)+6`]
                                },
                                {
                                    id: "short-q3aii",
                                    label: "Sub-sub-question 3(a)(ii)",
                                    questionHtml: `<p>Finish the arithmetic.</p>`,
                                    answerTex: `14`,
                                    workingTexLines: [`2(4)+6=8+6`, `8+6=14`]
                                }
                            ]
                        },
                        {
                            id: "short-q3b",
                            label: "Sub-question 3(b)",
                            questionHtml: `<p>Simplify ${katexInline("3x+2x+6")}.</p>`,
                            answerTex: `5x+6`,
                            workingTexLines: [`3x+2x=5x`, `\\Rightarrow 5x+6`]
                        }
                    ]
                };
                const q3 = renderNode(q3Node, 0);
                nav.push({ type: "link", text: "3", href: "#short-q3", small: "Question 3" });
                nav.push({ type: "link", text: "3a", href: "#short-q3a", small: "Sub-question" });
                nav.push({ type: "link", text: "3ai", href: "#short-q3ai", small: "Sub-sub" });
                nav.push({ type: "link", text: "3aii", href: "#short-q3aii", small: "Sub-sub" });
                nav.push({ type: "link", text: "3b", href: "#short-q3b", small: "Sub-question" });
                nodes.push(q3);

                // Q4–Q6 simple
                for (let i = 4; i <= 6; i++) {
                    const id = "short-q" + i;
                    const node = renderNode({
                        id,
                        label: "Question " + i,
                        meta: String(i),
                        questionHtml: `<p>Short arithmetic prompt ${katexInline("n=4")}.</p>`,
                        answerTex: `${(i + 2) * 4}`,
                        workingTexLines: shortWorkingLines(i)
                    }, 0);
                    nav.push({ type: "link", text: String(i), href: "#" + id, small: "Question " + i });
                    nodes.push(node);
                }

                return {
                    id: "short",
                    title: "Short paper",
                    subtitle: "6 questions total (includes deeper nesting: 3(a)(i), 3(a)(ii)).",
                    navItems: nav,
                    nodes,
                    defaultWorkingsExpanded: false
                };
            }

            function buildStandardPaper(expandedDefault) {
                const nav = [];
                const nodes = [];

                for (let i = 1; i <= 35; i++) {
                    const id = "std-q" + i;

                    // Sprinkle deeper nesting:
                    // Q18(a)(i), Q18(a)(ii), Q18(b)
                    if (i === 18) {
                        const q18 = {
                            id,
                            label: "Question 18",
                            meta: "18",
                            questionHtml: `<p>Work through the parts below.</p>`,
                            answerTex: `\\text{See parts}`,
                            workingTexLines: [`\\text{Parts (a) and (b) follow.}`],
                            children: [
                                {
                                    id: "std-q18a",
                                    label: "Sub-question 18(a)",
                                    questionHtml: `<p>Simplify ${katexInline("(x+2)(x-2)")}.</p>`,
                                    answerTex: `x^{2}-4`,
                                    workingTexLines: [`(x+2)(x-2)`, `=x^{2}-4`],
                                    children: [
                                        {
                                            id: "std-q18ai",
                                            label: "Sub-sub-question 18(a)(i)",
                                            questionHtml: `<p>Expand step.</p>`,
                                            answerTex: `x^{2}-2x+2x-4`,
                                            workingTexLines: [`(x+2)(x-2)`, `=x(x-2)+2(x-2)`, `=x^{2}-2x+2x-4`]
                                        },
                                        {
                                            id: "std-q18aii",
                                            label: "Sub-sub-question 18(a)(ii)",
                                            questionHtml: `<p>Collect like terms.</p>`,
                                            answerTex: `x^{2}-4`,
                                            workingTexLines: [`x^{2}-2x+2x-4`, `=x^{2}-4`]
                                        }
                                    ]
                                },
                                {
                                    id: "std-q18b",
                                    label: "Sub-question 18(b)",
                                    questionHtml: `<p>Evaluate at ${katexInline("x=3")}.</p>`,
                                    answerTex: `5`,
                                    workingTexLines: [`x^{2}-4`, `=3^{2}-4`, `=9-4=5`]
                                }
                            ]
                        };
                        nodes.push(renderNode(q18, 0));
                        nav.push({ type: "link", text: "18", href: "#std-q18", small: "Question" });
                        nav.push({ type: "link", text: "18a", href: "#std-q18a", small: "Sub-question" });
                        nav.push({ type: "link", text: "18ai", href: "#std-q18ai", small: "Sub-sub" });
                        nav.push({ type: "link", text: "18aii", href: "#std-q18aii", small: "Sub-sub" });
                        nav.push({ type: "link", text: "18b", href: "#std-q18b", small: "Sub-question" });
                        continue;
                    }

                    // Q30(a)(i) long working deep nesting (core stress test)
                    if (i === 30) {
                        const q30 = {
                            id,
                            label: "Question 30",
                            meta: "30",
                            questionHtml: `<p>Answer the parts. One deeply nested part contains a truly long working.</p>`,
                            answerTex: `\\text{See parts}`,
                            workingTexLines: [`\\text{Parts (a) and (b) follow.}`],
                            children: [
                                {
                                    id: "std-q30a",
                                    label: "Sub-question 30(a)",
                                    questionHtml: `<p>Consider the expression ${katexInline("(3x+5)(x+2)-4")}.</p>`,
                                    answerTex: `\\text{See sub-parts}`,
                                    workingTexLines: [`\\text{Sub-parts (i) and (ii) follow.}`],
                                    children: [
                                        {
                                            id: "std-q30ai",
                                            label: "Sub-sub-question 30(a)(i)",
                                            questionHtml: `<p>Simplify fully (long working).</p>`,
                                            answerTex: `3x^{2}+11x+6`,
                                            workingTexLines: longAlgebraLines(301) // 55 lines
                                        },
                                        {
                                            id: "std-q30aii",
                                            label: "Sub-sub-question 30(a)(ii)",
                                            questionHtml: `<p>Evaluate at ${katexInline("x=1")}.</p>`,
                                            answerTex: `20`,
                                            workingTexLines: [`3(1)^{2}+11(1)+6`, `=3+11+6=20`]
                                        }
                                    ]
                                },
                                {
                                    id: "std-q30b",
                                    label: "Sub-question 30(b)",
                                    questionHtml: `<p>State the degree of ${katexInline("3x^{2}+11x+6")}.</p>`,
                                    answerTex: `2`,
                                    workingTexLines: [`\\text{Highest power of }x\\text{ is }2`]
                                }
                            ]
                        };
                        nodes.push(renderNode(q30, 0));
                        nav.push({ type: "link", text: "30", href: "#std-q30", small: "Question" });
                        nav.push({ type: "link", text: "30a", href: "#std-q30a", small: "Sub-question" });
                        nav.push({ type: "link", text: "30ai", href: "#std-q30ai", small: "Sub-sub (long)" });
                        nav.push({ type: "link", text: "30aii", href: "#std-q30aii", small: "Sub-sub" });
                        nav.push({ type: "link", text: "30b", href: "#std-q30b", small: "Sub-question" });
                        continue;
                    }

                    // Standard questions: Q26–Q35 long workings (50–60 lines)
                    const isLong = i >= 26 && i <= 35;
                    const node = renderNode({
                        id,
                        label: "Question " + i,
                        meta: String(i),
                        questionHtml: isLong
                            ? `<p>Long algebra prompt:</p>${katexBlock("(2x+3)(x+4)-5")}${katexBlock("\\text{Simplify}")}`
                            : `<p>Standard prompt with ${katexInline("x")}.</p>${katexBlock("\\text{(prompt placeholder)}")}`,
                        answerTex: isLong ? `\\text{(short final form)}` : `\\text{(short answer)}`,
                        workingTexLines: isLong ? longAlgebraLines(i) : [
                            `\\text{Step 1: }\\; x+${(i % 7) + 1}`,
                            `\\text{Step 2: }\\; (x+${(i % 7) + 1})+${(i % 5) + 2}`,
                            `\\text{Result: }\\; x+${(i % 7) + 1 + (i % 5) + 2}`
                        ]
                    }, 0);

                    nav.push({ type: "link", text: String(i), href: "#" + id, small: "Question " + i });
                    nodes.push(node);
                }

                return {
                    id: expandedDefault ? "standardExpanded" : "standard",
                    title: expandedDefault ? "Standard (Workings Expanded)" : "Standard paper",
                    subtitle: expandedDefault
                        ? "35 questions total. Q26–Q35 have long workings. In this dataset only: ALL workings start expanded."
                        : "35 questions total. Q26–Q35 have long workings (50–60 lines each).",
                    navItems: nav,
                    nodes,
                    defaultWorkingsExpanded: !!expandedDefault
                };
            }

            function buildDiagramPaper() {
                const nav = [];
                const nodes = [];
                const diagramQs = new Set([2, 4, 6, 9, 12, 14, 17, 20]);
                const diagramCycle = ["geometry", "bars", "grid", "array"];
                let dIdx = 0;

                for (let i = 1; i <= 20; i++) {
                    const id = "dia-q" + i;
                    const hasDiagram = diagramQs.has(i);
                    const diag = hasDiagram ? diagramCycle[dIdx++ % diagramCycle.length] : null;

                    // Sprinkle nesting in one diagram question (e.g., Q12(a)(i), Q12(a)(ii))
                    if (i === 12) {
                        const q12 = {
                            id,
                            label: "Question 12",
                            meta: "12",
                            questionHtml: `<p>Use the diagram and answer parts below.</p>`,
                            diagram: diag,
                            answerTex: `\\text{See parts}`,
                            workingTexLines: [`\\text{Parts (a) follow.}`],
                            children: [
                                {
                                    id: "dia-q12a",
                                    label: "Sub-question 12(a)",
                                    questionHtml: `<p>Find the value of ${katexInline("\\angle ABC")}.</p>`,
                                    answerTex: `60^{\\circ}`,
                                    workingTexLines: [`\\text{Using angle rules.}`, `60^{\\circ}`],
                                    children: [
                                        {
                                            id: "dia-q12ai",
                                            label: "Sub-sub-question 12(a)(i)",
                                            questionHtml: `<p>State the rule used.</p>`,
                                            answerTex: `\\text{Angles in a triangle sum to }180^{\\circ}`,
                                            workingTexLines: [`\\angle A+\\angle B+\\angle C=180^{\\circ}`]
                                        },
                                        {
                                            id: "dia-q12aii",
                                            label: "Sub-sub-question 12(a)(ii)",
                                            questionHtml: `<p>Compute the missing angle.</p>`,
                                            answerTex: `60^{\\circ}`,
                                            workingTexLines: [`180^{\\circ}-70^{\\circ}-50^{\\circ}=60^{\\circ}`]
                                        }
                                    ]
                                }
                            ]
                        };
                        nodes.push(renderNode(q12, 0));
                        nav.push({ type: "link", text: "12", href: "#dia-q12", small: "Question (diagram)" });
                        nav.push({ type: "link", text: "12a", href: "#dia-q12a", small: "Sub-question" });
                        nav.push({ type: "link", text: "12ai", href: "#dia-q12ai", small: "Sub-sub" });
                        nav.push({ type: "link", text: "12aii", href: "#dia-q12aii", small: "Sub-sub" });
                        continue;
                    }

                    const node = renderNode({
                        id,
                        label: "Question " + i,
                        meta: String(i),
                        diagram: diag,
                        questionHtml: hasDiagram
                            ? `<p>Refer to the diagram. Compute ${katexInline("x")}.</p>`
                            : `<p>Diagram-free prompt with ${katexInline("x")}.</p>`,
                        answerTex: `\\text{(short answer)}`,
                        workingTexLines: [
                            `\\text{Step 1: read the given values.}`,
                            `\\text{Step 2: apply a rule.}`,
                            `\\text{Result: } x=\\text{(value)}`
                        ]
                    }, 0);

                    nav.push({ type: "link", text: String(i), href: "#" + id, small: hasDiagram ? "Question (diagram)" : "Question" });
                    nodes.push(node);
                }

                return {
                    id: "diagram",
                    title: "Diagram-heavy paper",
                    subtitle: "20 questions total, with 8 questions containing diagrams (inline SVG placeholders). Includes nesting at Q12(a)(i)/(ii).",
                    navItems: nav,
                    nodes,
                    defaultWorkingsExpanded: false
                };
            }

            function buildSectionedPaper() {
                const nav = [];
                const nodes = [];

                // Section A
                nodes.push(el("div", { class: "section", id: "sec-a", "aria-label": "Section A" }, [el("h2", {}, ["Section A"])]));
                nav.push({ type: "sep", text: "A" });

                for (let i = 1; i <= 35; i++) {
                    const id = "sec-a" + i;

                    // Sprinkle nesting in Section A (e.g., A20(a)(i)/(ii))
                    if (i === 20) {
                        const a20 = {
                            id,
                            label: "Question A20",
                            meta: "A20",
                            questionHtml: `<p>Section A multi-part question.</p>`,
                            answerTex: `\\text{See parts}`,
                            workingTexLines: [`\\text{Parts (a) follow.}`],
                            children: [
                                {
                                    id: "sec-a20a",
                                    label: "Sub-question A20(a)",
                                    questionHtml: `<p>Simplify ${katexInline("(x+1)^2")}.</p>`,
                                    answerTex: `x^{2}+2x+1`,
                                    workingTexLines: [`(x+1)^{2}`, `=x^{2}+2x+1`],
                                    children: [
                                        {
                                            id: "sec-a20ai",
                                            label: "Sub-sub-question A20(a)(i)",
                                            questionHtml: `<p>Expand.</p>`,
                                            answerTex: `x^{2}+x+x+1`,
                                            workingTexLines: [`(x+1)(x+1)`, `=x^{2}+x+x+1`]
                                        },
                                        {
                                            id: "sec-a20aii",
                                            label: "Sub-sub-question A20(a)(ii)",
                                            questionHtml: `<p>Collect like terms.</p>`,
                                            answerTex: `x^{2}+2x+1`,
                                            workingTexLines: [`x^{2}+x+x+1`, `=x^{2}+2x+1`]
                                        }
                                    ]
                                }
                            ]
                        };
                        nodes.push(renderNode(a20, 0));
                        nav.push({ type: "link", text: "A20", href: "#sec-a20", small: "Question" });
                        nav.push({ type: "link", text: "A20a", href: "#sec-a20a", small: "Sub-question" });
                        nav.push({ type: "link", text: "A20ai", href: "#sec-a20ai", small: "Sub-sub" });
                        nav.push({ type: "link", text: "A20aii", href: "#sec-a20aii", small: "Sub-sub" });
                        continue;
                    }

                    nodes.push(renderNode({
                        id,
                        label: "Question A" + i,
                        meta: "A" + i,
                        questionHtml: `<p>Section A prompt with ${katexInline("x")}.</p>${katexBlock("\\text{(prompt placeholder)}")}`,
                        answerTex: `\\text{(short answer)}`,
                        workingTexLines: [`x+${(i % 9) + 1}`, `\\text{(simplify)}`, `x+${(i % 9) + 1}`]
                    }, 0));
                    nav.push({ type: "link", text: "A" + i, href: "#" + id, small: "Question" });
                }

                // Section B
                nodes.push(el("div", { class: "section", id: "sec-b", "aria-label": "Section B" }, [el("h2", {}, ["Section B"])]));
                nav.push({ type: "sep", text: "B" });

                for (let i = 1; i <= 8; i++) {
                    const id = "sec-b" + i;
                    nodes.push(renderNode({
                        id,
                        label: "Question B" + i,
                        meta: "B" + i,
                        questionHtml: `<p>Section B medium prompt.</p>${katexBlock("\\text{(prompt placeholder)}")}`,
                        answerTex: `\\text{(short answer)}`,
                        workingTexLines: [
                            `\\text{Step 1}`,
                            `\\text{Step 2}`,
                            `\\text{Result}`
                        ]
                    }, 0));
                    nav.push({ type: "link", text: "B" + i, href: "#" + id, small: "Question" });
                }

                // Section C (6 questions; all very long workings 50–60 lines)
                nodes.push(el("div", { class: "section", id: "sec-c", "aria-label": "Section C" }, [el("h2", {}, ["Section C"])]));
                nav.push({ type: "sep", text: "C" });

                for (let i = 1; i <= 6; i++) {
                    const id = "sec-c" + i;

                    // One Section C question includes nesting too (still long work in the main level)
                    if (i === 3) {
                        const c3 = {
                            id,
                            label: "Question C3",
                            meta: "C3",
                            questionHtml: `<p>Section C long prompt (includes nested parts).</p>${katexBlock("(4x+7)(x+3)-6")}`,
                            answerTex: `\\text{(short final form)}`,
                            workingTexLines: longAlgebraLines(700 + i), // 55 lines
                            children: [
                                {
                                    id: "sec-c3a",
                                    label: "Sub-question C3(a)",
                                    questionHtml: `<p>State a simplified intermediate form.</p>`,
                                    answerTex: `4x^{2}+19x+15`,
                                    workingTexLines: [`(4x+7)(x+3)-6`, `=4x^{2}+19x+15`]
                                }
                            ]
                        };
                        nodes.push(renderNode(c3, 0));
                        nav.push({ type: "link", text: "C3", href: "#sec-c3", small: "Question (long)" });
                        nav.push({ type: "link", text: "C3a", href: "#sec-c3a", small: "Sub-question" });
                        continue;
                    }

                    nodes.push(renderNode({
                        id,
                        label: "Question C" + i,
                        meta: "C" + i,
                        questionHtml: `<p>Section C long prompt.</p>${katexBlock("(3x+5)(x+2)-4")}${katexBlock("\\text{Simplify}")}`,
                        answerTex: `\\text{(short final form)}`,
                        workingTexLines: longAlgebraLines(600 + i) // 55 lines
                    }, 0));
                    nav.push({ type: "link", text: "C" + i, href: "#" + id, small: "Question (long)" });
                }

                return {
                    id: "sectioned",
                    title: "Sectioned paper",
                    subtitle: "Paper contains Section A (35), Section B (8), Section C (6 long workings; 50–60 lines each). Includes nested items in A20 and C3.",
                    navItems: nav,
                    nodes,
                    defaultWorkingsExpanded: false
                };
            }

            const datasets = {
                short: buildShortPaper,
                standard: () => buildStandardPaper(false),
                standardExpanded: () => buildStandardPaper(true),
                diagram: buildDiagramPaper,
                sectioned: buildSectionedPaper
            };

            // ------------------ Render + Nav ------------------
            const paperRoot = document.getElementById("paperRoot");
            const paperTitle = document.getElementById("paperTitle");
            const paperSubtitle = document.getElementById("paperSubtitle");

            const navRail = document.getElementById("navListRail");
            const navPanel = document.getElementById("navListPanel");

            const paperSelect = document.getElementById("paperSelect");

            function clearNode(node) {
                while (node.firstChild) node.removeChild(node.firstChild);
            }

            function buildNavList(navItems, ul) {
                clearNode(ul);
                navItems.forEach(item => {
                    const li = document.createElement("li");
                    if (item.type === "sep") {
                        li.appendChild(el("div", { class: "nav-sep" }, [item.text]));
                    } else {
                        const a = el("a", { href: item.href }, []);
                        a.appendChild(document.createTextNode(item.text));
                        if (item.small) {
                            const sm = document.createElement("small");
                            sm.textContent = item.small;
                            a.appendChild(sm);
                        }
                        li.appendChild(a);
                    }
                    ul.appendChild(li);
                });
            }

            function setWorkingDefaults(defaultExpanded) {
                const toggles = document.querySelectorAll(".js-working-toggle");
                toggles.forEach(btn => {
                    const targetId = btn.getAttribute("data-target");
                    const panel = document.getElementById(targetId);
                    if (!panel) return;

                    const next = !!defaultExpanded;
                    btn.setAttribute("aria-expanded", String(next));
                    panel.hidden = !next;
                    btn.textContent = next ? "Hide working" : "Show working";

                    // Ensure each toggle only affects its own block (no cross-question effects)
                    btn.addEventListener("click", () => {
                        const expanded = btn.getAttribute("aria-expanded") === "true";
                        const state = !expanded;
                        btn.setAttribute("aria-expanded", String(state));
                        panel.hidden = !state;
                        btn.textContent = state ? "Hide working" : "Show working";
                    });
                });

                // Preview text remains visible even when expanded? Keep it; but if expanded, it becomes redundant.
                // Hide preview only in the same block when expanded to reduce noise (still local; no cross-question effects).
                const workings = document.querySelectorAll(".block.working");
                workings.forEach(w => {
                    const btn = w.querySelector(".js-working-toggle");
                    const preview = w.querySelector(".working-preview");
                    if (!btn || !preview) return;
                    const expanded = btn.getAttribute("aria-expanded") === "true";
                    preview.style.display = expanded ? "none" : "";
                    btn.addEventListener("click", () => {
                        const isExpanded = btn.getAttribute("aria-expanded") === "true";
                        preview.style.display = isExpanded ? "none" : "";
                    });
                });
            }

            function renderKatex() {
                // Render individual elements
                const single = document.querySelectorAll(".js-katex");
                single.forEach(node => {
                    const tex = node.getAttribute("data-tex") || "";
                    const display = (node.getAttribute("data-display") || "false") === "true";
                    if (window.katex && typeof window.katex.render === "function") {
                        try {
                            window.katex.render(tex, node, { displayMode: display, throwOnError: false });
                        } catch (e) {
                            node.classList.add("plain");
                            node.textContent = tex;
                        }
                    } else {
                        node.classList.add("plain");
                        node.textContent = tex;
                    }
                });

                // Render stacks (working lines)
                const stacks = document.querySelectorAll(".js-katex-stack");
                stacks.forEach(stack => {
                    let arr = [];
                    try {
                        arr = JSON.parse(stack.getAttribute("data-tex") || "[]");
                    } catch (e) {
                        arr = [];
                    }
                    stack.innerHTML = "";
                    arr.forEach(tex => {
                        const line = document.createElement("div");
                        line.className = "mathline";
                        if (window.katex && typeof window.katex.render === "function") {
                            try {
                                window.katex.render(tex, line, { displayMode: true, throwOnError: false });
                            } catch (e) {
                                line.classList.add("plain");
                                line.textContent = tex;
                            }
                        } else {
                            line.classList.add("plain");
                            line.textContent = tex;
                        }
                        stack.appendChild(line);
                    });
                });
            }

            function renderPaper(key) {
                const build = datasets[key];
                const data = build();

                paperTitle.textContent = data.title;
                paperSubtitle.textContent =
                    data.subtitle + " Answers visible by default. " +
                    (data.defaultWorkingsExpanded ? "Workings expanded by default." : "Workings collapsed by default.") +
                    " Questions always visible.";

                clearNode(paperRoot);
                data.nodes.forEach(n => paperRoot.appendChild(n));

                buildNavList(data.navItems, navRail);
                buildNavList(data.navItems, navPanel);

                // Defaults + invariants
                setWorkingDefaults(data.defaultWorkingsExpanded);

                // Render KaTeX lines (working lines rendered at load time; fallback to plain text if missing)
                renderKatex();
            }

            // ------------------ Navigation panel behavior (mobile/tablet) ------------------
            const navToggle = document.getElementById("navToggle");
            const navPanelWrap = document.getElementById("navPanel");

            function openNav() {
                navPanelWrap.classList.add("open");
                navToggle.setAttribute("aria-expanded", "true");
            }
            function closeNav() {
                navPanelWrap.classList.remove("open");
                navToggle.setAttribute("aria-expanded", "false");
            }

            navToggle.addEventListener("click", () => {
                const isOpen = navPanelWrap.classList.contains("open");
                if (isOpen) closeNav(); else openNav();
            });

            // Navigation is non-destructive: do not change expanded/collapsed states on click
            navPanel.addEventListener("click", (e) => {
                const a = e.target.closest && e.target.closest('a[href^="#"]');
                if (a) closeNav();
            });

            // ------------------ Paper selector ------------------
            paperSelect.addEventListener("change", () => {
                renderPaper(paperSelect.value);
            });

            // ------------------ Init ------------------
            renderPaper("short");
        })();
    </script>
</body>

</html>