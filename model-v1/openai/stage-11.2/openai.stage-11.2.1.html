<!doctype html>
<html lang="en-GB">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>RTQ – Maths Paper Solution Viewer (Prototype)</title>

    <!-- KaTeX (CDN) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        crossorigin="anonymous"></script>

    <!-- Markdown-it (CDN) -->
    <script defer src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"
        crossorigin="anonymous"></script>

    <style>
        :root {
            --bg: #f6f6f6;
            --frame: #ffffff;
            --ink: #121212;
            --muted: #444;
            --quiet: #666;
            --hairline: #d8d8d8;
            --wash: #f2f2f2;
            --wash2: #ededed;

            --gutter: 18px;
            --frameMax: 1080px;

            --fs-base: 16px;
            --lh-base: 1.55;

            --fs-q: 16px;
            --lh-q: 1.6;

            --fs-id: 14px;
            --fs-nav: 13px;
            --fs-nav-sub: 12px;
            --fs-answer: 14px;
            --fs-sd: 14px;
            --lh-sd: 1.45;

            --sp-1: 6px;
            --sp-2: 10px;
            --sp-3: 14px;
            --sp-4: 18px;
            --sp-5: 26px;
            --sp-6: 34px;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            font-size: var(--fs-base);
            line-height: var(--lh-base);
            overflow-x: hidden;
            /* page must never horizontally scroll */
        }

        /* Focus styling (basic, non-themed) */
        :focus-visible {
            outline: 2px solid #000;
            outline-offset: 2px;
        }

        /* Top controls region */
        .top-controls {
            width: 100%;
            padding: var(--sp-4) 0 var(--sp-3);
        }

        .top-controls-inner {
            max-width: var(--frameMax);
            margin: 0 auto;
            padding: 0 var(--gutter);
            display: flex;
            align-items: center;
            gap: var(--sp-2);
            justify-content: space-between;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: var(--sp-2);
            min-width: 0;
        }

        label {
            font-size: 13px;
            color: var(--quiet);
            white-space: nowrap;
        }

        select {
            font: inherit;
            font-size: 14px;
            padding: 8px 10px;
            border: 1px solid var(--hairline);
            border-radius: 0;
            background: #fff;
            color: var(--ink);
            min-width: 220px;
        }

        .jump-btn {
            font: inherit;
            font-size: 14px;
            padding: 8px 10px;
            border: 1px solid var(--hairline);
            border-radius: 0;
            background: #fff;
            color: var(--ink);
            cursor: pointer;
        }

        .jump-btn:hover {
            text-decoration: underline;
        }

        .top-divider {
            max-width: var(--frameMax);
            margin: 0 auto;
            padding: 0 var(--gutter);
        }

        .hairline {
            height: 1px;
            background: var(--hairline);
            width: 100%;
        }

        /* DocumentFrameShell */
        .frame {
            max-width: var(--frameMax);
            margin: 0 auto var(--sp-6);
            padding: 0 var(--gutter);
        }

        .frame-surface {
            background: var(--frame);
            /* shared base surface */
            padding: var(--sp-4);
        }

        .columns {
            display: flex;
            align-items: flex-start;
            gap: var(--sp-4);
        }

        /* Navigation rail */
        nav {
            width: 160px;
            flex: 0 0 160px;
            position: sticky;
            top: 12px;
            align-self: flex-start;
        }

        .nav-inner {
            max-height: calc(100vh - 24px);
            overflow-y: auto;
            padding-right: 4px;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* legacy */
        }

        .nav-inner::-webkit-scrollbar {
            display: none;
        }

        /* WebKit/Blink */

        .nav-section-label {
            font-size: 12px;
            letter-spacing: 0.02em;
            color: var(--quiet);
            margin: 0 0 var(--sp-2);
        }

        .nav-section {
            margin: 0 0 var(--sp-4);
            padding: 0;
        }

        .nav-items {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .nav-item {
            margin: 0;
            padding: 0;
        }

        .nav-link {
            width: 100%;
            text-align: left;
            display: block;
            font: inherit;
            font-size: var(--fs-nav);
            color: var(--quiet);
            background: transparent;
            border: 0;
            padding: 6px 0;
            cursor: pointer;
            text-decoration: none;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        .nav-link[aria-current="true"] {
            font-weight: 700;
            /* weight-only */
            color: var(--ink);
            text-decoration: none;
        }

        .nav-link.depth-1 {
            font-size: var(--fs-nav-sub);
        }

        .nav-link.depth-2 {
            font-size: 11px;
        }

        .nav-link.depth-3 {
            font-size: 11px;
        }

        /* Boundary between nav and paper column */
        .col-sep {
            width: 1px;
            background: var(--hairline);
            flex: 0 0 1px;
            margin-top: 2px;
        }

        /* Paper column */
        main {
            flex: 1 1 auto;
            min-width: 0;
            /* prevents overflow */
        }

        .paper-surface {
            background: transparent;
            /* paper surface exists inside shared base */
        }

        /* Section header */
        .section-header {
            font-size: 14px;
            color: var(--ink);
            font-weight: 700;
            margin: 0 0 var(--sp-3);
        }

        .section-divider {
            margin: 0 0 var(--sp-4);
        }

        /* Question node */
        .q-node {
            padding: 0;
            margin: 0 0 var(--sp-6);
            /* top-level inter-question spacing (largest unit) */
        }

        .q-node.depth-1 {
            margin-bottom: var(--sp-5);
        }

        .q-node.depth-2 {
            margin-bottom: var(--sp-4);
        }

        .q-node.depth-3 {
            margin-bottom: var(--sp-4);
        }

        .q-body {
            display: flex;
            gap: var(--sp-2);
            align-items: flex-start;
        }

        .q-id {
            flex: 0 0 auto;
            font-size: var(--fs-id);
            color: var(--muted);
            line-height: var(--lh-q);
            margin-top: 1px;
            white-space: nowrap;
        }

        .q-prompt {
            flex: 1 1 auto;
            min-width: 0;
            font-size: var(--fs-q);
            line-height: var(--lh-q);
            color: var(--ink);
        }

        /* Solution block boundary */
        .q-to-solution {
            margin: var(--sp-3) 0 0;
        }

        .q-to-solution .hairline {
            background: var(--hairline);
        }

        /* Answer */
        .answer {
            margin-top: var(--sp-3);
        }

        .answer-label {
            font-size: 12px;
            color: var(--quiet);
            font-weight: 700;
            margin: 0 0 var(--sp-1);
        }

        .answer-content {
            font-size: var(--fs-answer);
            color: var(--ink);
            line-height: 1.5;
            min-width: 0;
        }

        /* Solution details control + region */
        .sd-control-wrap {
            margin-top: var(--sp-3);
        }

        .sd-toggle {
            font: inherit;
            font-size: 14px;
            padding: 0;
            border: 0;
            background: transparent;
            color: var(--ink);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: underline;
        }

        .sd-toggle:active {
            transform: translateY(0);
        }

        .sd-chevron {
            width: 10px;
            height: 10px;
            display: inline-block;
            border-right: 2px solid var(--ink);
            border-bottom: 2px solid var(--ink);
            transform: rotate(45deg);
            margin-top: -1px;
        }

        .sd-toggle[aria-expanded="true"] .sd-chevron {
            transform: rotate(-135deg);
            margin-top: 1px;
        }

        .answer-to-sd-sep {
            margin-top: var(--sp-3);
        }

        .sd-region[hidden] {
            display: none;
        }

        .sd-region {
            margin-top: var(--sp-3);
            padding: var(--sp-3);
            background: var(--wash);
            /* optional subtle region wash when expanded */
        }

        .sd-block {
            margin: 0;
        }

        .sd-label {
            font-size: 12px;
            font-weight: 700;
            color: var(--quiet);
            margin: 0 0 var(--sp-2);
        }

        .sd-body {
            font-size: var(--fs-sd);
            line-height: var(--lh-sd);
            color: var(--ink);
            min-width: 0;
        }

        .sd-sep {
            margin: var(--sp-3) 0;
        }

        /* Children container + indentation (spacing-only) */
        .children {
            margin-top: var(--sp-4);
            padding-left: 18px;
        }

        @media (max-width: 720px) {
            .children {
                padding-left: 12px;
            }

            /* adapt indentation to preserve line length */
        }

        /* Markdown content primitives (quiet, non-card) */
        .md p {
            margin: 0 0 var(--sp-2);
        }

        .md p:last-child {
            margin-bottom: 0;
        }

        .md ul,
        .md ol {
            margin: 0 0 var(--sp-2);
            padding-left: 18px;
        }

        .md li {
            margin: 0 0 4px;
        }

        .md blockquote {
            margin: 0 0 var(--sp-2);
            padding-left: 10px;
            border-left: 2px solid var(--hairline);
            color: var(--muted);
        }

        .md pre {
            margin: 0 0 var(--sp-2);
            padding: 10px;
            border: 1px solid var(--hairline);
            background: #fff;
            overflow-x: auto;
            /* allowed within element */
            max-width: 100%;
        }

        .md code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.95em;
        }

        .md table {
            border-collapse: collapse;
            width: 100%;
            margin: 0 0 var(--sp-2);
            font-size: 13px;
        }

        .md th,
        .md td {
            border: 1px solid var(--hairline);
            padding: 6px 8px;
            vertical-align: top;
        }

        .md th {
            font-weight: 700;
            background: #fff;
            /* no fills beyond neutral white */
        }

        /* Inline SVG diagrams authored in payload */
        .md svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: var(--sp-2) 0;
        }

        /* KaTeX containment invariant */
        .katex-display {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 6px 0;
            background: var(--wash2);
            /* subtle underlay for display math only */
        }

        .katex-display>.katex {
            display: inline-block;
            /* keeps intrinsic width for scrolling */
            max-width: 100%;
        }

        .katex {
            white-space: normal;
        }

        /* Ensure display math never forces parent wider than container */
        .md,
        .q-prompt,
        .answer-content,
        .sd-body,
        main,
        .frame-surface {
            min-width: 0;
        }

        /* Mobile: nav drawer */
        .mobile-only {
            display: none;
        }

        .desktop-only {
            display: block;
        }

        @media (max-width: 860px) {

            nav.desktop-only,
            .col-sep.desktop-only {
                display: none;
            }

            .desktop-only {
                display: none;
            }

            .mobile-only {
                display: inline-flex;
            }

            .frame-surface {
                padding: var(--sp-3);
            }

            .columns {
                display: block;
            }

            main {
                width: 100%;
            }

            select {
                min-width: 180px;
            }
        }

        .drawer-overlay[hidden] {
            display: none;
        }

        .drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            /* optional scrim */
            display: flex;
            justify-content: flex-end;
            z-index: 50;
        }

        .drawer {
            width: min(320px, 86vw);
            height: 100%;
            background: #fff;
            border-left: 1px solid var(--hairline);
            display: flex;
            flex-direction: column;
        }

        .drawer-header {
            padding: var(--sp-4);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--sp-2);
        }

        .drawer-title {
            margin: 0;
            font-size: 14px;
            font-weight: 700;
            color: var(--ink);
        }

        .drawer-close {
            font: inherit;
            font-size: 14px;
            border: 1px solid var(--hairline);
            background: #fff;
            padding: 6px 10px;
            border-radius: 0;
            cursor: pointer;
        }

        .drawer-divider {
            padding: 0 var(--sp-4);
        }

        .drawer-nav {
            padding: var(--sp-3) var(--sp-4) var(--sp-4);
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .drawer-nav::-webkit-scrollbar {
            display: none;
        }

        /* Deterministic missing payload message */
        .missing {
            padding: var(--sp-4) 0;
            font-size: 14px;
            color: var(--ink);
            font-weight: 700;
            letter-spacing: 0.01em;
        }
    </style>
</head>

<body>
    <header class="top-controls" aria-label="Top controls">
        <div class="top-controls-inner">
            <div class="control-group">
                <label for="paperSelect">Paper</label>
                <select id="paperSelect" aria-label="Paper selector"></select>
            </div>
            <button id="jumpBtn" class="jump-btn mobile-only" type="button" aria-haspopup="dialog"
                aria-controls="navDrawer">Jump to</button>
        </div>
        <div class="top-divider">
            <div class="hairline" aria-hidden="true"></div>
        </div>
    </header>

    <div class="frame" aria-label="Document frame">
        <div class="frame-surface">
            <div class="columns">
                <nav class="desktop-only" aria-label="Document navigation">
                    <div id="navInner" class="nav-inner" tabindex="0"></div>
                </nav>

                <div class="col-sep desktop-only" aria-hidden="true"></div>

                <main aria-label="Paper content">
                    <div id="paperRoot" class="paper-surface"></div>
                </main>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div id="drawerOverlay" class="drawer-overlay" hidden>
        <div id="navDrawer" class="drawer" role="dialog" aria-modal="true" aria-label="Jump to">
            <div class="drawer-header">
                <h2 class="drawer-title">Jump to</h2>
                <button id="drawerClose" class="drawer-close" type="button">Close</button>
            </div>
            <div class="drawer-divider">
                <div class="hairline" aria-hidden="true"></div>
            </div>
            <div id="drawerNav" class="drawer-nav" tabindex="0" aria-label="Drawer navigation"></div>
        </div>
    </div>

    <script>
        // CANONICAL CONSTANT — PAPERS PAYLOAD PATH (v1.0)
        const RTQ_PAPERS_PAYLOAD_PATH = "../../../payload/rtq.papers.payload.v2.json";

        // CANONICAL CONSTANT — SHADCN TOKEN PROFILES PATH (v1.0)
        const RTQ_SHADCN_TOKEN_PROFILES_PATH = "../../../payload/rtq.shadcn.token.profiles.v1.json";

        (function () {
            const els = {
                paperSelect: document.getElementById("paperSelect"),
                paperRoot: document.getElementById("paperRoot"),
                navInner: document.getElementById("navInner"),
                drawerOverlay: document.getElementById("drawerOverlay"),
                drawer: document.getElementById("navDrawer"),
                drawerNav: document.getElementById("drawerNav"),
                jumpBtn: document.getElementById("jumpBtn"),
                drawerClose: document.getElementById("drawerClose")
            };

            /** Markdown-it instance with required settings:
             * - html passthrough enabled
             * - escape rule disabled to preserve TeX backslashes
             */
            function createMarkdownRenderer() {
                if (!window.markdownit) return null;
                const md = window.markdownit({
                    html: true,
                    linkify: true,
                    breaks: false
                });
                try {
                    if (md && md.inline && md.inline.ruler && md.inline.ruler.disable) {
                        md.inline.ruler.disable(["escape"]);
                    }
                } catch (e) { }
                return md;
            }

            const md = createMarkdownRenderer();

            let payload = null;
            let currentPaperIndex = 0;
            let expandedMap = new Map(); // questionId -> boolean (Solution Details expanded)
            let activeQuestionId = null;
            let io = null;

            // Optional fetch for token profiles (exists for runtime parity; not required for this prototype)
            // Must not duplicate literal path; references canonical constant only.
            async function loadTokenProfiles() {
                try {
                    await fetch(RTQ_SHADCN_TOKEN_PROFILES_PATH, { cache: "no-store" });
                } catch (e) { }
            }

            function clearIO() {
                if (io) {
                    io.disconnect();
                    io = null;
                }
            }

            function setBodyScrollLocked(locked) {
                document.body.style.overflow = locked ? "hidden" : "";
            }

            // Focus trap for drawer (no background interaction while open)
            function trapFocus(container) {
                const focusableSelector = [
                    'a[href]',
                    'button:not([disabled])',
                    'input:not([disabled])',
                    'select:not([disabled])',
                    'textarea:not([disabled])',
                    '[tabindex]:not([tabindex="-1"])'
                ].join(',');

                function getFocusable() {
                    return Array.from(container.querySelectorAll(focusableSelector))
                        .filter(el => el.offsetParent !== null && !el.hasAttribute("hidden"));
                }

                function onKeyDown(e) {
                    if (e.key !== "Tab") return;
                    const focusables = getFocusable();
                    if (focusables.length === 0) return;
                    const first = focusables[0];
                    const last = focusables[focusables.length - 1];
                    const active = document.activeElement;

                    if (e.shiftKey) {
                        if (active === first || active === container) {
                            e.preventDefault();
                            last.focus();
                        }
                    } else {
                        if (active === last) {
                            e.preventDefault();
                            first.focus();
                        }
                    }
                }

                container.addEventListener("keydown", onKeyDown);
                return () => container.removeEventListener("keydown", onKeyDown);
            }

            let releaseTrap = null;
            let lastFocused = null;

            function openDrawer() {
                lastFocused = document.activeElement;
                els.drawerOverlay.hidden = false;
                setBodyScrollLocked(true);

                if (!releaseTrap) releaseTrap = trapFocus(els.drawer);
                // focus drawer nav for immediate keyboard scrolling
                setTimeout(() => els.drawerNav.focus(), 0);
            }

            function closeDrawer() {
                els.drawerOverlay.hidden = true;
                setBodyScrollLocked(false);
                if (releaseTrap) {
                    releaseTrap();
                    releaseTrap = null;
                }
                if (lastFocused && typeof lastFocused.focus === "function") {
                    lastFocused.focus();
                }
            }

            els.jumpBtn.addEventListener("click", openDrawer);
            els.drawerClose.addEventListener("click", closeDrawer);
            els.drawerOverlay.addEventListener("click", (e) => {
                if (e.target === els.drawerOverlay) closeDrawer();
            });
            document.addEventListener("keydown", (e) => {
                if (!els.drawerOverlay.hidden && e.key === "Escape") {
                    e.preventDefault();
                    closeDrawer();
                }
            });

            function safeText(s) {
                return (s == null) ? "" : String(s);
            }

            function isNonEmptyString(s) {
                return typeof s === "string" && s.trim().length > 0;
            }

            function renderMarkdownInto(container, markdown) {
                const wrap = document.createElement("div");
                wrap.className = "md";
                if (md) {
                    try {
                        wrap.innerHTML = md.render(safeText(markdown));
                    } catch (e) {
                        wrap.textContent = safeText(markdown);
                    }
                } else {
                    wrap.textContent = safeText(markdown);
                }
                container.appendChild(wrap);
                return wrap;
            }

            function renderKaTeXWithin(container) {
                // Must run after Markdown → HTML is in DOM.
                if (!window.renderMathInElement) return;
                try {
                    window.renderMathInElement(container, {
                        delimiters: [
                            { left: "$$", right: "$$", display: true },
                            { left: "$", right: "$", display: false }
                        ],
                        throwOnError: false
                    });
                } catch (e) {
                    // Graceful fallback: do nothing (plain text remains)
                }
            }

            function collectNavItemsFromQuestions(questions, depth, out) {
                for (const q of questions || []) {
                    out.push({ id: safeText(q.id), depth: depth });
                    if (Array.isArray(q.children) && q.children.length) {
                        collectNavItemsFromQuestions(q.children, depth + 1, out);
                    }
                }
            }

            function buildNavModelForPaper(paper) {
                const model = [];
                if (Array.isArray(paper.sections)) {
                    for (const sec of paper.sections) {
                        const label = safeText(sec.label);
                        const hasLabel = label.trim().length > 0;
                        model.push({ type: "section", label: hasLabel ? label : null, questions: sec.questions || [] });
                    }
                } else {
                    model.push({ type: "flat", label: null, questions: paper.questions || [] });
                }
                return model;
            }

            function buildExpandedMapForPaper(paper) {
                expandedMap.clear();
                const expandedAll = !!(paper && paper.defaults && paper.defaults.expandedAll === true);

                function walk(qs) {
                    for (const q of qs || []) {
                        const qid = safeText(q.id);
                        const hasSD = !!(q && q.solutionBlock && q.solutionBlock.solutionDetails);
                        if (hasSD) {
                            expandedMap.set(qid, expandedAll);
                        }
                        if (Array.isArray(q.children) && q.children.length) {
                            walk(q.children);
                        }
                    }
                }

                if (Array.isArray(paper.sections)) {
                    for (const sec of paper.sections) {
                        walk(sec.questions || []);
                    }
                } else {
                    walk(paper.questions || []);
                }
            }

            function renderNav(container, paper) {
                container.innerHTML = "";

                const model = buildNavModelForPaper(paper);

                for (const block of model) {
                    const sectionWrap = document.createElement("div");
                    sectionWrap.className = "nav-section";

                    if (block.type === "section" && block.label) {
                        const secLabel = document.createElement("div");
                        secLabel.className = "nav-section-label";
                        secLabel.textContent = block.label;
                        sectionWrap.appendChild(secLabel);

                        // separator between section label → items (spacing baseline, optional hairline)
                        const sep = document.createElement("div");
                        sep.style.margin = "0 0 var(--sp-2)";
                        sectionWrap.appendChild(sep);
                    }

                    const items = [];
                    collectNavItemsFromQuestions(block.questions, 0, items);

                    const ul = document.createElement("ul");
                    ul.className = "nav-items";

                    for (const item of items) {
                        const li = document.createElement("li");
                        li.className = "nav-item";

                        const btn = document.createElement("button");
                        btn.type = "button";
                        btn.className = "nav-link depth-" + Math.min(item.depth, 3);
                        btn.textContent = item.id;
                        btn.dataset.targetId = item.id;
                        btn.setAttribute("aria-current", (item.id === activeQuestionId) ? "true" : "false");

                        btn.addEventListener("click", () => {
                            const el = document.getElementById("q-" + cssEscapeId(item.id));
                            if (el) {
                                el.scrollIntoView({ block: "start", inline: "nearest", behavior: "auto" });
                            }
                            if (!els.drawerOverlay.hidden) {
                                closeDrawer();
                            }
                        });

                        li.appendChild(btn);
                        ul.appendChild(li);
                    }

                    sectionWrap.appendChild(ul);
                    container.appendChild(sectionWrap);
                }
            }

            function updateNavCurrent() {
                // update desktop + drawer nav current indication (weight-only)
                for (const root of [els.navInner, els.drawerNav]) {
                    const links = root.querySelectorAll(".nav-link");
                    links.forEach(a => {
                        const tid = a.dataset.targetId;
                        a.setAttribute("aria-current", (tid && tid === activeQuestionId) ? "true" : "false");
                    });
                }
            }

            function observeQuestions() {
                clearIO();
                const qEls = Array.from(els.paperRoot.querySelectorAll("[data-question-id]"));
                if (!qEls.length) return;

                // Find the most recently intersecting question near top of viewport
                io = new IntersectionObserver((entries) => {
                    const visible = entries
                        .filter(e => e.isIntersecting)
                        .map(e => ({ id: e.target.getAttribute("data-question-id"), top: e.boundingClientRect.top }))
                        .filter(v => !!v.id)
                        .sort((a, b) => a.top - b.top);

                    if (visible.length) {
                        // choose the one closest to top but not too far above
                        const chosen = visible.find(v => v.top >= -20) || visible[0];
                        if (chosen && chosen.id && chosen.id !== activeQuestionId) {
                            activeQuestionId = chosen.id;
                            updateNavCurrent();
                        }
                    }
                }, {
                    root: null,
                    rootMargin: "-10% 0px -70% 0px",
                    threshold: [0.01, 0.1]
                });

                qEls.forEach(el => io.observe(el));
            }

            function renderSolutionDetails(sd, qid, parent) {
                const isExpanded = !!expandedMap.get(qid);

                const controlWrap = document.createElement("div");
                controlWrap.className = "sd-control-wrap";

                const btn = document.createElement("button");
                btn.type = "button";
                btn.className = "sd-toggle";
                btn.setAttribute("aria-expanded", isExpanded ? "true" : "false");
                btn.setAttribute("aria-controls", "sd-" + cssEscapeId(qid));
                btn.innerHTML = '<span class="sd-chevron" aria-hidden="true"></span><span class="sd-toggle-text"></span>';

                const textSpan = btn.querySelector(".sd-toggle-text");
                textSpan.textContent = isExpanded ? "Hide working" : "Show working";

                btn.addEventListener("click", () => {
                    const next = !expandedMap.get(qid);
                    expandedMap.set(qid, next);
                    btn.setAttribute("aria-expanded", next ? "true" : "false");
                    textSpan.textContent = next ? "Hide working" : "Show working";

                    const region = parent.querySelector("#sd-" + cssEscapeId(qid));
                    if (region) {
                        region.hidden = !next;
                    }
                    // No auto scrolling / focus movement; preserves invariants.
                });

                controlWrap.appendChild(btn);
                parent.appendChild(controlWrap);

                // separator between Answer ↔ Solution Details boundary (spacing + optional hairline)
                const sep = document.createElement("div");
                sep.className = "answer-to-sd-sep";
                sep.appendChild(makeHairline());
                parent.appendChild(sep);

                const region = document.createElement("div");
                region.className = "sd-region";
                region.id = "sd-" + safeDomId(qid);
                region.hidden = !isExpanded;

                // Subsections in locked order: Keep in mind, Formulas used, Working, Alternative working
                const blocks = [];

                if (sd && isNonEmptyString(sd.keepInMind)) {
                    blocks.push({ label: "Keep in mind", body: sd.keepInMind });
                }
                if (sd && isNonEmptyString(sd.formulasUsed)) {
                    blocks.push({ label: "Formulas used", body: sd.formulasUsed });
                }
                if (sd && isNonEmptyString(sd.working)) {
                    blocks.push({ label: "Working", body: sd.working });
                }
                if (sd && Array.isArray(sd.alternativeWorking) && sd.alternativeWorking.length) {
                    for (const alt of sd.alternativeWorking) {
                        if (isNonEmptyString(alt)) {
                            blocks.push({ label: "Alternative working", body: alt });
                        }
                    }
                }

                blocks.forEach((b, idx) => {
                    const block = document.createElement("div");
                    block.className = "sd-block";

                    const label = document.createElement("div");
                    label.className = "sd-label";
                    label.textContent = b.label;
                    block.appendChild(label);

                    const body = document.createElement("div");
                    body.className = "sd-body";
                    renderMarkdownInto(body, b.body);
                    block.appendChild(body);

                    region.appendChild(block);

                    if (idx < blocks.length - 1) {
                        const s = document.createElement("div");
                        s.className = "sd-sep";
                        s.appendChild(makeHairline());
                        region.appendChild(s);
                    }
                });

                parent.appendChild(region);

                // KaTeX after region content is in DOM
                renderKaTeXWithin(region);
            }

            function makeHairline() {
                const d = document.createElement("div");
                d.className = "hairline";
                d.setAttribute("aria-hidden", "true");
                return d;
            }

            function renderQuestionNode(q, depth) {
                const qid = safeText(q.id);
                const node = document.createElement("section");
                node.className = "q-node depth-" + Math.min(depth, 3);
                node.id = "q-" + safeDomId(qid);
                node.setAttribute("data-question-id", qid);

                // Question body
                const body = document.createElement("div");
                body.className = "q-body";

                const idEl = document.createElement("div");
                idEl.className = "q-id";
                idEl.textContent = qid;

                const prompt = document.createElement("div");
                prompt.className = "q-prompt";
                renderMarkdownInto(prompt, q.question);
                body.appendChild(idEl);
                body.appendChild(prompt);

                node.appendChild(body);

                // KaTeX for question prompt
                renderKaTeXWithin(prompt);

                // Solution block: render only if present AND has answer or solutionDetails
                const sb = q.solutionBlock;
                const hasAnswer = !!(sb && isNonEmptyString(sb.answer));
                const hasSD = !!(sb && sb.solutionDetails);
                const shouldRenderSolutionBlock = !!(sb && (hasAnswer || hasSD));

                if (shouldRenderSolutionBlock) {
                    // boundary separator (spacing + optional divider)
                    const boundary = document.createElement("div");
                    boundary.className = "q-to-solution";
                    boundary.appendChild(makeHairline());
                    node.appendChild(boundary);

                    // Answer (visible by default when present)
                    if (hasAnswer) {
                        const ans = document.createElement("div");
                        ans.className = "answer";

                        const label = document.createElement("div");
                        label.className = "answer-label";
                        label.textContent = "Answer";
                        ans.appendChild(label);

                        const content = document.createElement("div");
                        content.className = "answer-content";
                        renderMarkdownInto(content, sb.answer);
                        ans.appendChild(content);

                        node.appendChild(ans);
                        renderKaTeXWithin(content);
                    }

                    // Solution Details (collapsed by default unless expandedAll=true)
                    if (hasSD) {
                        renderSolutionDetails(sb.solutionDetails, qid, node);
                    }
                }

                // Children container
                if (Array.isArray(q.children) && q.children.length) {
                    const children = document.createElement("div");
                    children.className = "children";

                    // parent → children separator (spacing + optional hairline divider)
                    const sep = document.createElement("div");
                    sep.style.margin = "0 0 var(--sp-3)";
                    sep.appendChild(makeHairline());
                    children.appendChild(sep);

                    for (const child of q.children) {
                        children.appendChild(renderQuestionNode(child, depth + 1));
                    }
                    node.appendChild(children);
                }

                return node;
            }

            function renderPaper(paper) {
                els.paperRoot.innerHTML = "";
                activeQuestionId = null;
                clearIO();

                const root = document.createElement("div");

                if (Array.isArray(paper.sections)) {
                    for (let sIndex = 0; sIndex < paper.sections.length; sIndex++) {
                        const sec = paper.sections[sIndex];
                        const label = safeText(sec.label);
                        const hasLabel = label.trim().length > 0;

                        if (hasLabel) {
                            const sh = document.createElement("div");
                            sh.className = "section-header";
                            sh.textContent = label;
                            root.appendChild(sh);

                            const div = document.createElement("div");
                            div.className = "section-divider";
                            div.appendChild(makeHairline());
                            root.appendChild(div);
                        }

                        const qs = sec.questions || [];
                        for (const q of qs) {
                            root.appendChild(renderQuestionNode(q, 0));
                        }

                        // separator to next section header boundary (optional; only if another section follows)
                        if (sIndex < paper.sections.length - 1) {
                            const between = document.createElement("div");
                            between.style.margin = "0 0 var(--sp-5)";
                            between.appendChild(makeHairline());
                            root.appendChild(between);
                        }
                    }
                } else {
                    const qs = paper.questions || [];
                    for (const q of qs) {
                        root.appendChild(renderQuestionNode(q, 0));
                    }
                }

                els.paperRoot.appendChild(root);

                // Build observers + nav after DOM is present
                observeQuestions();

                // Initialize active state to first question if none
                const first = els.paperRoot.querySelector("[data-question-id]");
                if (first) {
                    activeQuestionId = first.getAttribute("data-question-id");
                }
                renderNav(els.navInner, paper);
                renderNav(els.drawerNav, paper);
                updateNavCurrent();
            }

            function renderMissing() {
                els.paperRoot.innerHTML = "";
                els.navInner.innerHTML = "";
                els.drawerNav.innerHTML = "";

                const msg = document.createElement("div");
                msg.className = "missing";
                msg.textContent = "PAPERS PAYLOAD MISSING";
                els.paperRoot.appendChild(msg);
            }

            function populatePaperSelector(papers) {
                els.paperSelect.innerHTML = "";
                (papers || []).forEach((p, idx) => {
                    const opt = document.createElement("option");
                    opt.value = String(idx);
                    opt.textContent = safeText(p.label);
                    els.paperSelect.appendChild(opt);
                });
            }

            els.paperSelect.addEventListener("change", () => {
                const nextIndex = Number(els.paperSelect.value);
                if (!payload || !Array.isArray(payload.papers)) return;
                if (!Number.isFinite(nextIndex) || nextIndex < 0 || nextIndex >= payload.papers.length) return;

                currentPaperIndex = nextIndex;

                const paper = payload.papers[currentPaperIndex];
                buildExpandedMapForPaper(paper); // only set to paper defaults; no extra mutation
                renderPaper(paper);
            });

            // Utilities: ensure safe IDs for DOM (but keep display ids unchanged)
            function cssEscapeId(s) {
                // limited escape to support query selectors; ids are used in dataset, not raw selectors except with getElementById
                return safeDomId(s);
            }
            function safeDomId(s) {
                // Keep it deterministic, reversible enough for unique mapping, without inventing semantics.
                // Replace characters not valid for HTML id with underscores.
                return safeText(s).replace(/[^A-Za-z0-9\-_:.]/g, "_");
            }

            async function loadPayload() {
                try {
                    const res = await fetch(RTQ_PAPERS_PAYLOAD_PATH, { cache: "no-store" });
                    if (!res.ok) throw new Error("Bad status");
                    const data = await res.json();
                    if (!data || !Array.isArray(data.papers)) throw new Error("Bad schema");
                    payload = data;

                    populatePaperSelector(payload.papers);

                    // Default to first paper in order
                    currentPaperIndex = 0;
                    els.paperSelect.value = "0";

                    const paper = payload.papers[currentPaperIndex];
                    buildExpandedMapForPaper(paper);
                    renderPaper(paper);
                } catch (e) {
                    payload = null;
                    renderMissing();
                }
            }

            // Start (wait for external scripts to be available)
            function whenReady() {
                // ensure markdown-it loaded (optional); KaTeX optional
                loadTokenProfiles();
                loadPayload();
            }

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", whenReady, { once: true });
            } else {
                whenReady();
            }
        })();
    </script>
</body>

</html>