<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RTQ – Maths Paper Solution Viewer (Stress-Test Harness)</title>

  <!-- KaTeX (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIXt0J9bV1dO8Hn0oT0VqgH1f0YQ5yPzqkYwz4o2m2a3QwCwJfCwZ3FQFQ0F9w" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-sP7tKQmK0w+qfJk8x8QyZ0b5v7S0wW2GvG6eY0bWwH8m3qG2dG8Jt8xR9p8e8b8K"
    crossorigin="anonymous"></script>

  <style>
    :root {
      --ink: #111;
      --muted: #555;
      --hair: #d7d7d7;
      --paper: #fff;
      --bg: #fff;
      --frame: 1120px;
      --navw: 140px;
      --gutter: 16px;
      --q-gap: 28px;
      --inner-gap: 10px;
      --indent: 18px;
      --tap: 44px;
      --topbar-h: 56px;
      --focus: 2px solid #111;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--ink);
      background: var(--bg);
    }

    /* Top bar */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 40;
      background: var(--paper);
      border-bottom: 1px solid var(--hair);
    }

    .frame {
      max-width: var(--frame);
      margin: 0 auto;
      padding: 0 var(--gutter);
    }

    .topbar-inner {
      height: var(--topbar-h);
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 240px;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
    }

    select {
      height: 40px;
      padding: 0 10px;
      border: 1px solid var(--hair);
      background: var(--paper);
      color: var(--ink);
      border-radius: 6px;
      max-width: 320px;
    }

    select:focus {
      outline: var(--focus);
      outline-offset: 2px;
    }

    /* Layout */
    .layout {
      display: grid;
      grid-template-columns: var(--navw) 1fr;
      gap: 24px;
      padding-top: 18px;
      padding-bottom: 48px;
    }

    /* Navigation rail */
    .nav-rail {
      position: relative;
      min-width: var(--navw);
    }

    .nav-sticky {
      position: sticky;
      top: calc(var(--topbar-h) + 12px);
      max-height: calc(100vh - (var(--topbar-h) + 24px));
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .nav-title {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    nav[aria-label="Question navigation"] {
      overflow-y: auto;
      padding-right: 6px;
      /* hide scrollbar, keep functional */
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* legacy */
    }

    nav[aria-label="Question navigation"]::-webkit-scrollbar {
      display: none;
    }

    /* WebKit/Blink */

    nav:focus {
      outline: var(--focus);
      outline-offset: 3px;
    }

    .nav-sep {
      font-size: 12px;
      color: var(--muted);
      padding: 8px 0 4px 0;
    }

    .nav-item {
      display: block;
      width: 100%;
      text-align: left;
      border: 0;
      background: transparent;
      color: var(--ink);
      padding: 8px 0;
      min-height: 32px;
      cursor: pointer;
      font-size: 14px;
    }

    .nav-item:hover {
      text-decoration: underline;
    }

    .nav-item:focus {
      outline: var(--focus);
      outline-offset: 3px;
    }

    .nav-item[aria-current="true"] {
      font-weight: 700;
      text-decoration: none;
    }

    /* Paper content */
    main {
      min-width: 0;
    }

    .paper-title {
      margin: 0 0 18px 0;
      font-size: 16px;
      font-weight: 600;
    }

    /* Section headers (A/B/C) */
    .section-header {
      margin: 24px 0 10px 0;
      font-size: 13px;
      color: var(--muted);
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    /* Questions */
    .q {
      margin: 0 0 var(--q-gap) 0;
    }

    .q-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      min-width: 0;
    }

    .q-num {
      flex: 0 0 auto;
      width: 56px;
      font-weight: 700;
      color: var(--ink);
    }

    .q-body {
      min-width: 0;
      flex: 1 1 auto;
    }

    .q-prompt {
      margin: 0 0 var(--inner-gap) 0;
    }

    .q-answer {
      margin: 0 0 var(--inner-gap) 0;
      color: var(--ink);
    }

    .q-answer .ans-label {
      font-size: 12px;
      color: var(--muted);
      margin-right: 6px;
      white-space: nowrap;
    }

    /* Working toggle + preview */
    .working-row {
      margin-top: 2px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toggle {
      appearance: none;
      border: 1px solid var(--hair);
      background: transparent;
      color: var(--ink);
      border-radius: 8px;
      padding: 10px 12px;
      min-height: var(--tap);
      width: fit-content;
      cursor: pointer;
      font-size: 14px;
    }

    .toggle:hover {
      text-decoration: underline;
    }

    .toggle:focus {
      outline: var(--focus);
      outline-offset: 3px;
    }

    .working-preview {
      color: var(--muted);
      font-size: 14px;
      max-width: 70ch;
    }

    .working {
      color: var(--muted);
      font-size: 14px;
      max-width: 78ch;
    }

    .working[hidden] {
      display: none !important;
    }

    /* Indentation for nesting (no borders/containers) */
    .depth-1 .q-body {
      padding-left: calc(var(--indent) * 1);
    }

    .depth-2 .q-body {
      padding-left: calc(var(--indent) * 2);
    }

    /* Diagrams */
    .diagram {
      margin: 10px 0 0 0;
      max-width: 520px;
    }

    .diagram svg {
      width: 100%;
      height: auto;
      display: block;
    }

    /* KaTeX containers: prevent page-level horizontal scrolling */
    .math-block {
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 2px 0;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .math-block::-webkit-scrollbar {
      display: none;
    }

    .math-block:focus {
      outline: var(--focus);
      outline-offset: 3px;
    }

    /* Mobile / Tablet */
    .jump-btn {
      border: 1px solid var(--hair);
      background: transparent;
      color: var(--ink);
      border-radius: 8px;
      min-height: 40px;
      padding: 0 12px;
      cursor: pointer;
      display: none;
    }

    .jump-btn:hover {
      text-decoration: underline;
    }

    .jump-btn:focus {
      outline: var(--focus);
      outline-offset: 3px;
    }

    @media (max-width: 900px) {
      :root {
        --navw: 120px;
        --frame: 980px;
      }
    }

    @media (max-width: 760px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .nav-rail {
        display: none;
      }

      .jump-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .q-num {
        width: 44px;
      }

      .paper-title {
        font-size: 15px;
      }

      .toggle {
        width: 100%;
        max-width: 320px;
      }

      .depth-1 .q-body {
        padding-left: 12px;
      }

      .depth-2 .q-body {
        padding-left: 22px;
      }
    }

    /* Drawer */
    .drawer-backdrop[hidden] {
      display: none !important;
    }

    .drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.25);
      z-index: 60;
      display: flex;
      justify-content: flex-end;
    }

    .drawer {
      width: min(360px, 92vw);
      height: 100%;
      background: var(--paper);
      border-left: 1px solid var(--hair);
      padding: 14px 14px 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .drawer-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .drawer-title {
      font-weight: 600;
      font-size: 14px;
    }

    .drawer-close {
      border: 1px solid var(--hair);
      background: transparent;
      border-radius: 8px;
      min-height: 40px;
      padding: 0 12px;
      cursor: pointer;
    }

    .drawer-close:focus {
      outline: var(--focus);
      outline-offset: 3px;
    }

    .drawer-nav {
      overflow-y: auto;
      padding-right: 6px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .drawer-nav::-webkit-scrollbar {
      display: none;
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      * {
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>

<body>
  <header class="topbar">
    <div class="frame topbar-inner">
      <div class="controls">
        <label for="paperSelect">Paper</label>
        <select id="paperSelect" aria-label="Paper selector"></select>
      </div>
      <button id="jumpBtn" class="jump-btn" type="button" aria-haspopup="dialog" aria-controls="navDrawer">Jump
        to</button>
    </div>
  </header>

  <div class="frame layout" id="appShell">
    <aside class="nav-rail" aria-label="Navigation rail">
      <div class="nav-sticky">
        <div class="nav-title">Questions</div>
        <nav id="navList" aria-label="Question navigation" tabindex="0"></nav>
      </div>
    </aside>

    <main id="paper" aria-label="Paper content">
      <!-- injected -->
    </main>
  </div>

  <!-- Drawer (mobile/tablet) -->
  <div id="drawerBackdrop" class="drawer-backdrop" hidden>
    <div id="navDrawer" class="drawer" role="dialog" aria-modal="true" aria-label="Jump to question">
      <div class="drawer-head">
        <div class="drawer-title">Jump to</div>
        <button id="drawerClose" class="drawer-close" type="button">Close</button>
      </div>
      <nav id="drawerNav" class="drawer-nav" aria-label="Question navigation (drawer)" tabindex="0"></nav>
    </div>
  </div>

  <script>
    (function () {
      const $ = (sel, root = document) => root.querySelector(sel);

      const paperSelect = $("#paperSelect");
      const navList = $("#navList");
      const drawerNav = $("#drawerNav");
      const paperEl = $("#paper");
      const jumpBtn = $("#jumpBtn");
      const drawerBackdrop = $("#drawerBackdrop");
      const drawer = $("#navDrawer");
      const drawerClose = $("#drawerClose");
      const appShell = $("#appShell");

      let lastFocus = null;

      function safeId(str) {
        return "q-" + String(str)
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^\w()-]/g, "")
          .replace(/\(/g, "(").replace(/\)/g, ")");
      }

      function makeEl(tag, className, attrs) {
        const el = document.createElement(tag);
        if (className) el.className = className;
        if (attrs) {
          for (const [k, v] of Object.entries(attrs)) {
            if (v === null || v === undefined) continue;
            if (k === "text") el.textContent = v;
            else el.setAttribute(k, v);
          }
        }
        return el;
      }

      // Diagrams (inline SVG placeholders, grayscale)
      function diagramSVG(type, seed = 0) {
        const stroke = "#111";
        const fill = "none";
        const hair = "#777";

        if (type === "geometry") {
          return `
          <svg viewBox="0 0 320 180" role="img" aria-label="Geometry diagram">
            <rect x="1" y="1" width="318" height="178" fill="${fill}" stroke="${hair}" stroke-width="1"/>
            <circle cx="248" cy="92" r="34" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
            <path d="M52 132 L150 44 L196 132 Z" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
            <text x="46" y="146" font-size="12" fill="${stroke}">A</text>
            <text x="146" y="38" font-size="12" fill="${stroke}">B</text>
            <text x="198" y="146" font-size="12" fill="${stroke}">C</text>
            <text x="242" y="92" font-size="12" fill="${stroke}">O</text>
            <path d="M52 132 L248 92" stroke="${hair}" stroke-width="1.5" stroke-dasharray="4 4"/>
            <text x="128" y="112" font-size="12" fill="${stroke}">x cm</text>
          </svg>`;
        }

        if (type === "bars") {
          const a = 3 + (seed % 3);
          const b = 2 + ((seed + 1) % 3);
          const total = a + b;
          const w = 260, h = 30, x0 = 30, y0 = 70;
          const aw = w * (a / total);
          return `
          <svg viewBox="0 0 320 180" role="img" aria-label="Ratio bar diagram">
            <rect x="1" y="1" width="318" height="178" fill="${fill}" stroke="${hair}" stroke-width="1"/>
            <text x="30" y="44" font-size="12" fill="${stroke}">Ratio bar (A:B)</text>
            <rect x="${x0}" y="${y0}" width="${w}" height="${h}" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
            <line x1="${x0 + aw}" y1="${y0}" x2="${x0 + aw}" y2="${y0 + h}" stroke="${stroke}" stroke-width="2"/>
            <text x="${x0 + aw / 2}" y="${y0 + h + 18}" font-size="12" fill="${stroke}" text-anchor="middle">A (${a})</text>
            <text x="${x0 + aw + (w - aw) / 2}" y="${y0 + h + 18}" font-size="12" fill="${stroke}" text-anchor="middle">B (${b})</text>
          </svg>`;
        }

        if (type === "grid") {
          return `
          <svg viewBox="0 0 320 180" role="img" aria-label="Coordinate grid diagram">
            <rect x="1" y="1" width="318" height="178" fill="${fill}" stroke="${hair}" stroke-width="1"/>
            <g stroke="${hair}" stroke-width="1">
              ${Array.from({ length: 9 }).map((_, i) => `<line x1="${40 + i * 30}" y1="30" x2="${40 + i * 30}" y2="150"/>`).join("")}
              ${Array.from({ length: 5 }).map((_, i) => `<line x1="40" y1="${30 + i * 30}" x2="280" y2="${30 + i * 30}"/>`).join("")}
            </g>
            <g stroke="${stroke}" stroke-width="2">
              <line x1="40" y1="150" x2="280" y2="150"/>
              <line x1="40" y1="30" x2="40" y2="150"/>
            </g>
            <circle cx="130" cy="90" r="4" fill="${stroke}"/>
            <circle cx="220" cy="60" r="4" fill="${stroke}"/>
            <path d="M130 90 L220 60" stroke="${stroke}" stroke-width="2" fill="none"/>
            <text x="126" y="106" font-size="12" fill="${stroke}">P</text>
            <text x="224" y="56" font-size="12" fill="${stroke}">Q</text>
          </svg>`;
        }

        // table-like grid
        return `
        <svg viewBox="0 0 320 180" role="img" aria-label="Table diagram">
          <rect x="1" y="1" width="318" height="178" fill="none" stroke="#777" stroke-width="1"/>
          <text x="30" y="44" font-size="12" fill="#111">Grid / array</text>
          <g stroke="#111" stroke-width="2" fill="none">
            <rect x="60" y="60" width="200" height="90"/>
            <line x1="126.7" y1="60" x2="126.7" y2="150"/>
            <line x1="193.3" y1="60" x2="193.3" y2="150"/>
            <line x1="60" y1="90" x2="260" y2="90"/>
            <line x1="60" y1="120" x2="260" y2="120"/>
          </g>
          <text x="93" y="82" font-size="12" fill="#111" text-anchor="middle">a</text>
          <text x="160" y="82" font-size="12" fill="#111" text-anchor="middle">b</text>
          <text x="227" y="82" font-size="12" fill="#111" text-anchor="middle">c</text>
          <text x="93" y="112" font-size="12" fill="#111" text-anchor="middle">d</text>
          <text x="160" y="112" font-size="12" fill="#111" text-anchor="middle">e</text>
          <text x="227" y="112" font-size="12" fill="#111" text-anchor="middle">f</text>
        </svg>`;
      }

      // Rich text + math parts: [{t:"..."},{m:"latex", display:false},{m:"...", display:true}, ...]
      function renderParts(container, parts) {
        for (const part of parts) {
          if (part.t !== undefined) {
            const span = makeEl("span", null, { text: part.t });
            container.appendChild(span);
          } else if (part.m !== undefined) {
            if (part.display) {
              const block = makeEl("div", "math-block", { tabindex: "0" });
              const node = makeEl("div", "math", { "data-latex": part.m, "data-display": "1" });
              block.appendChild(node);
              container.appendChild(block);
            } else {
              const node = makeEl("span", "math", { "data-latex": part.m, "data-display": "0" });
              container.appendChild(node);
            }
          }
        }
      }

      function katexRenderAll(root = document) {
        const nodes = root.querySelectorAll(".math[data-latex]");
        const hasKatex = !!window.katex && typeof window.katex.render === "function";
        nodes.forEach(node => {
          const latex = node.getAttribute("data-latex") || "";
          const displayMode = node.getAttribute("data-display") === "1";
          if (hasKatex) {
            try {
              window.katex.render(latex, node, { displayMode, throwOnError: false });
            } catch (e) {
              node.textContent = latex;
            }
          } else {
            // graceful fallback (plain text)
            node.textContent = displayMode ? ("[" + latex + "]") : (latex);
          }
        });
      }

      function longWorkingLines(count, seed = 0) {
        const lines = [];
        for (let i = 1; i <= count; i++) {
          const a = (i + seed) % 9 + 1;
          const b = (i + seed * 2) % 7 + 2;
          const c = (i + seed * 3) % 5 + 3;
          lines.push({ m: `\\text{Step ${i}:}\\quad ${a}x + ${b} = ${c}x + ${a + b}`, display: true });
          if (i % 6 === 0) {
            lines.push({ m: `\\Rightarrow\\quad (${a}-${c})x = ${a + b}-${b}`, display: true });
          }
          if (i % 10 === 0) {
            lines.push({ m: `\\text{Check:}\\quad x = \\frac{${a + b}-${b}}{${a}-${c}}`, display: true });
          }
        }
        return lines;
      }

      function mkQuestion(opts) {
        // opts: {key, label, depth, promptParts, answerParts, workingParts, diagrams:[{type,seed}], workingDefaultExpanded}
        return {
          type: "question",
          key: opts.key,
          label: opts.label,
          depth: opts.depth || 0,
          promptParts: opts.promptParts || [{ t: "" }],
          answerParts: opts.answerParts || [{ t: "" }],
          workingParts: opts.workingParts || [],
          diagrams: opts.diagrams || [],
          workingDefaultExpanded: !!opts.workingDefaultExpanded
        };
      }

      function mkSection(title) {
        return { type: "section", title };
      }

      function buildShortPaper() {
        const items = [];
        items.push(mkQuestion({
          key: "1", label: "1",
          promptParts: [
            { t: "Calculate " }, { m: "37 + 58", display: false }, { t: "." }
          ],
          answerParts: [{ t: "" }, { m: "95", display: false }],
          workingParts: [
            { m: "37 + 58 = 95", display: true }
          ]
        }));

        items.push(mkQuestion({
          key: "2", label: "2",
          promptParts: [
            { t: "Work out " }, { m: "\\frac{3}{5}\\text{ of }40", display: false }, { t: "." }
          ],
          answerParts: [{ m: "24", display: false }],
          workingParts: [
            { m: "\\frac{3}{5}\\times 40 = 3\\times 8 = 24", display: true }
          ]
        }));

        items.push(mkQuestion({
          key: "3", label: "3",
          promptParts: [
            { t: "A number is multiplied by 6 to give 54. What is the number?" }
          ],
          answerParts: [{ m: "9", display: false }],
          workingParts: [
            { m: "6x = 54", display: true },
            { m: "x = 54\\div 6 = 9", display: true }
          ]
        }));

        items.push(mkQuestion({
          key: "4", label: "4",
          promptParts: [
            { t: "Find the perimeter of a rectangle with sides " }, { m: "7\\text{ cm}", display: false }, { t: " and " }, { m: "4\\text{ cm}", display: false }, { t: "." }
          ],
          answerParts: [{ m: "22\\text{ cm}", display: false }],
          workingParts: [
            { m: "P = 2(7+4) = 22\\text{ cm}", display: true }
          ]
        }));

        // Multi-part with nesting
        items.push(mkQuestion({
          key: "5", label: "5",
          promptParts: [
            { t: "A shop sells pencils and pens." }
          ],
          answerParts: [{ t: "" }, { m: "\\text{See parts (a) and (b)}", display: false }],
          workingParts: [
            { m: "\\text{Use the information in each part.}", display: true }
          ]
        }));
        items.push(mkQuestion({
          key: "5a", label: "5a", depth: 1,
          promptParts: [
            { t: "(a) A pencil costs " }, { m: "35\\text{p}", display: false }, { t: ". How much for 4 pencils?" }
          ],
          answerParts: [{ m: "\\pounds 1.40", display: false }],
          workingParts: [
            { m: "4\\times 35\\text{p} = 140\\text{p} = \\pounds 1.40", display: true }
          ]
        }));
        items.push(mkQuestion({
          key: "5b", label: "5b", depth: 1,
          promptParts: [
            { t: "(b) A pen costs " }, { m: "\\pounds 1.25", display: false }, { t: ". You have " }, { m: "\\pounds 10", display: false }, { t: ". How many pens can you buy?" }
          ],
          answerParts: [{ m: "8\\text{ pens}", display: false }],
          workingParts: [
            { m: "10\\div 1.25 = 8", display: true }
          ]
        }));

        items.push(mkQuestion({
          key: "6", label: "6",
          promptParts: [
            { t: "Solve " }, { m: "x - 7 = 19", display: false }, { t: "." }
          ],
          answerParts: [{ m: "26", display: false }],
          workingParts: [
            { m: "x = 19 + 7 = 26", display: true }
          ]
        }));

        return { id: "short", name: "Short paper", items, defaults: { workingsExpanded: false } };
      }

      function buildDiagramPaper() {
        const items = [];
        for (let q = 1; q <= 20; q++) {
          const hasDiagram = (q === 2 || q === 5 || q === 7 || q === 9 || q === 12 || q === 14 || q === 17 || q === 19);
          const typeCycle = ["geometry", "bars", "grid", "table"];
          const dType = typeCycle[q % 4];

          items.push(mkQuestion({
            key: String(q),
            label: String(q),
            promptParts: [
              { t: "Answer the question using the diagram." },
              { t: " " },
              { m: "\\text{Show your method.}", display: false }
            ],
            answerParts: [{ m: `${(q % 9) + 1}`, display: false }],
            workingParts: [
              { m: `\\text{From the diagram, read the values and calculate.}`, display: true },
              { m: `${(q % 7) + 2}+${(q % 5) + 3}=${((q % 7) + 2) + ((q % 5) + 3)}`, display: true }
            ],
            diagrams: hasDiagram ? [{ type: dType, seed: q }] : []
          }));
        }
        return { id: "diagram", name: "Diagram-heavy paper", items, defaults: { workingsExpanded: false } };
      }

      function buildStandardPaper(allWorkingsExpanded) {
        const items = [];

        // Q1–Q17 (short/medium mix)
        for (let q = 1; q <= 17; q++) {
          items.push(mkQuestion({
            key: String(q),
            label: String(q),
            promptParts: [
              { t: "Work out " }, { m: `${q * 3}+${q + 11}`, display: false }, { t: "." }
            ],
            answerParts: [{ m: `${(q * 3) + (q + 11)}`, display: false }],
            workingParts: [
              { m: `${q * 3}+${q + 11}=${(q * 3) + (q + 11)}`, display: true }
            ],
            workingDefaultExpanded: !!allWorkingsExpanded
          }));
        }

        // Q18 with deep nesting: 18(a)(i), 18(a)(ii), 18(b)
        items.push(mkQuestion({
          key: "18",
          label: "18",
          promptParts: [
            { t: "A number line problem uses the equation " }, { m: "2x+3=17", display: false }, { t: "." }
          ],
          answerParts: [{ m: "x=7", display: false }],
          workingParts: [
            { m: "2x+3=17", display: true },
            { m: "2x=14", display: true },
            { m: "x=7", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));
        items.push(mkQuestion({
          key: "18a(i)",
          label: "18a(i)",
          depth: 1,
          promptParts: [{ t: "(a)(i) Solve " }, { m: "3x-5=16", display: false }, { t: "." }],
          answerParts: [{ m: "7", display: false }],
          workingParts: [
            { m: "3x-5=16", display: true },
            { m: "3x=21", display: true },
            { m: "x=7", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));
        items.push(mkQuestion({
          key: "18a(ii)",
          label: "18a(ii)",
          depth: 1,
          promptParts: [{ t: "(a)(ii) Solve " }, { m: "5x+10=45", display: false }, { t: "." }],
          answerParts: [{ m: "7", display: false }],
          workingParts: [
            { m: "5x+10=45", display: true },
            { m: "5x=35", display: true },
            { m: "x=7", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));
        items.push(mkQuestion({
          key: "18b",
          label: "18b",
          depth: 1,
          promptParts: [{ t: "(b) Check your answer by substituting " }, { m: "x=7", display: false }, { t: " into " }, { m: "2x+3", display: false }, { t: "." }],
          answerParts: [{ m: "17", display: false }],
          workingParts: [
            { m: "2(7)+3=14+3=17", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));

        // Q19–Q25 (medium)
        for (let q = 19; q <= 25; q++) {
          items.push(mkQuestion({
            key: String(q),
            label: String(q),
            promptParts: [
              { t: "Simplify " }, { m: `${q}a + ${q - 3}a`, display: false }, { t: "." }
            ],
            answerParts: [{ m: `${(q + (q - 3))}a`, display: false }],
            workingParts: [
              { m: `${q}a + ${q - 3}a = ${(q + (q - 3))}a`, display: true }
            ],
            workingDefaultExpanded: !!allWorkingsExpanded
          }));
        }

        // Q26–Q35 (long algebra; collapsed by default unless expanded dataset)
        for (let q = 26; q <= 35; q++) {
          const seed = q - 25;
          const baseWorking = [
            { m: `\\text{Solve the equation:}`, display: true },
            { m: `${seed + 2}x + ${seed * 3} = ${seed}x + ${seed * 6}`, display: true },
            { m: `\\Rightarrow\\quad (${seed + 2}-${seed})x = ${seed * 6}-${seed * 3}`, display: true },
            { m: `\\Rightarrow\\quad 2x = ${seed * 3}`, display: true },
            { m: `\\Rightarrow\\quad x = \\frac{${seed * 3}}{2}`, display: true },
            { m: `\\text{Now use }x\\text{ to evaluate }x^2+1:`, display: true },
            { m: `x^2+1 = \\left(\\frac{${seed * 3}}{2}\\right)^2 + 1`, display: true },
            { m: `= \\frac{${(seed * 3) * (seed * 3)}}{4} + 1`, display: true },
            { m: `= \\frac{${(seed * 3) * (seed * 3)}+4}{4}`, display: true }
          ];

          // Extremely long workings on a subset (stress test)
          const shouldBeVeryLong = (q === 28 || q === 31 || q === 35);
          const longLines = shouldBeVeryLong ? longWorkingLines(55, seed) : [];

          items.push(mkQuestion({
            key: String(q),
            label: String(q),
            promptParts: [
              { t: "Algebra (long). Solve and simplify: " },
              { m: `\\frac{${seed + 9}x-${seed}}{2} = ${seed + 4}`, display: false }
            ],
            answerParts: [
              { m: `x = ${seed + 2}`, display: false }
            ],
            workingParts: [
              { m: `\\frac{${seed + 9}x-${seed}}{2} = ${seed + 4}`, display: true },
              { m: `${seed + 9}x - ${seed} = 2(${seed + 4})`, display: true },
              { m: `${seed + 9}x = ${2 * (seed + 4) + seed}`, display: true },
              { m: `x = \\frac{${2 * (seed + 4) + seed}}{${seed + 9}}`, display: true },
              { m: `\\text{(Continue with method and simplification.)}`, display: true },
              ...baseWorking,
              ...longLines
            ],
            workingDefaultExpanded: !!allWorkingsExpanded
          }));
        }

        // Deep nesting again at Q30
        items.push(mkQuestion({
          key: "30a(i)", label: "30a(i)", depth: 1,
          promptParts: [{ t: "(a)(i) Factorise " }, { m: "x^2-9", display: false }, { t: "." }],
          answerParts: [{ m: "(x-3)(x+3)", display: false }],
          workingParts: [
            { m: "x^2-9=(x-3)(x+3)", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));
        items.push(mkQuestion({
          key: "30a(ii)", label: "30a(ii)", depth: 1,
          promptParts: [{ t: "(a)(ii) Solve " }, { m: "x^2-9=0", display: false }, { t: "." }],
          answerParts: [{ m: "x=\\pm 3", display: false }],
          workingParts: [
            { m: "x^2-9=0", display: true },
            { m: "(x-3)(x+3)=0", display: true },
            { m: "x=3\\text{ or }x=-3", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));
        items.push(mkQuestion({
          key: "30b", label: "30b", depth: 1,
          promptParts: [{ t: "(b) Substitute " }, { m: "x=3", display: false }, { t: " into " }, { m: "2x^2+1", display: false }, { t: "." }],
          answerParts: [{ m: "19", display: false }],
          workingParts: [
            { m: "2(3^2)+1=2\\cdot 9+1=19", display: true }
          ],
          workingDefaultExpanded: !!allWorkingsExpanded
        }));

        // Ensure ordering still linear and coherent:
        // Move the 30 subparts next to Q30 by placing them immediately after Q30 if Q30 exists as standalone.
        // (We did not add standalone Q30 above; these appear as items later in the linear stream as stress-test.)

        return {
          id: allWorkingsExpanded ? "standardExpanded" : "standard",
          name: allWorkingsExpanded ? "Standard (Workings Expanded)" : "Standard paper",
          items,
          defaults: { workingsExpanded: !!allWorkingsExpanded }
        };
      }

      function buildSectionedPaper() {
        const items = [];

        items.push(mkSection("Section A"));
        for (let q = 1; q <= 35; q++) {
          items.push(mkQuestion({
            key: `A${q}`,
            label: String(q),
            promptParts: [
              { t: "Section A question " }, { m: `${q}+${q + 2}`, display: false }, { t: "." }
            ],
            answerParts: [{ m: `${q + (q + 2)}`, display: false }],
            workingParts: [
              { m: `${q}+${q + 2}=${q + (q + 2)}`, display: true }
            ]
          }));
        }

        items.push(mkSection("Section B"));
        for (let q = 1; q <= 8; q++) {
          const num = 35 + q;
          items.push(mkQuestion({
            key: `B${q}`,
            label: String(num),
            promptParts: [
              { t: "Section B question (medium). Simplify " }, { m: `\\frac{${q + 6}x}{${q + 2}}`, display: false }, { t: "." }
            ],
            answerParts: [{ m: `\\frac{${q + 6}}{${q + 2}}x`, display: false }],
            workingParts: [
              { m: `\\frac{${q + 6}x}{${q + 2}} = \\left(\\frac{${q + 6}}{${q + 2}}\\right)x`, display: true }
            ]
          }));
        }

        items.push(mkSection("Section C"));
        for (let q = 1; q <= 6; q++) {
          const num = 43 + q;
          const seed = q + 3;
          items.push(mkQuestion({
            key: `C${q}`,
            label: String(num),
            promptParts: [
              { t: "Section C (very long). Solve: " },
              { m: `${seed}x - ${seed + 5} = ${seed + 2}`, display: false }
            ],
            answerParts: [{ m: `x = ${Math.floor((seed + 5 + seed + 2) / seed)}`, display: false }],
            workingParts: [
              { m: `${seed}x - ${seed + 5} = ${seed + 2}`, display: true },
              { m: `${seed}x = ${2 * seed + 7}`, display: true },
              { m: `x = \\frac{${2 * seed + 7}}{${seed}}`, display: true },
              ...longWorkingLines(58, seed)
            ]
          }));
        }

        return { id: "sectioned", name: "Sectioned paper (A/B/C)", items, defaults: { workingsExpanded: false } };
      }

      const DATASETS = [
        buildShortPaper(),
        buildStandardPaper(false),
        buildDiagramPaper(),
        buildSectionedPaper(),
        buildStandardPaper(true)
      ];

      function getDatasetById(id) {
        return DATASETS.find(d => d.id === id) || DATASETS[0];
      }

      function clearEl(el) {
        while (el.firstChild) el.removeChild(el.firstChild);
      }

      function buildSelector() {
        clearEl(paperSelect);
        DATASETS.forEach(ds => {
          const opt = document.createElement("option");
          opt.value = ds.id;
          opt.textContent = ds.name;
          paperSelect.appendChild(opt);
        });
      }

      function questionAnchorForKey(key) {
        return safeId(key);
      }

      function buildNav(ds, navRoot) {
        clearEl(navRoot);

        // For sectioned dataset: show A/B/C separators only as plain text (non-clickable)
        // Navigation is question-number-only; labels are already numeric strings for items; key carries section identity.
        ds.items.forEach(item => {
          if (item.type === "section") {
            const sep = makeEl("div", "nav-sep", { text: item.title.replace("Section ", "Section ") });
            navRoot.appendChild(sep);
            return;
          }
          if (item.type !== "question") return;

          const btn = makeEl("button", "nav-item", {
            type: "button",
            "data-target": questionAnchorForKey(item.key),
            "aria-current": "false"
          });
          btn.textContent = item.label;
          btn.addEventListener("click", () => {
            const target = document.getElementById(questionAnchorForKey(item.key));
            if (target) {
              target.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
            }
            closeDrawer();
          });
          navRoot.appendChild(btn);
        });
      }

      function prefersReducedMotion() {
        return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      }

      function buildPaper(ds) {
        clearEl(paperEl);

        const title = makeEl("h1", "paper-title", { text: ds.name });
        paperEl.appendChild(title);

        ds.items.forEach(item => {
          if (item.type === "section") {
            const sh = makeEl("div", "section-header", { text: item.title });
            paperEl.appendChild(sh);
            return;
          }
          if (item.type !== "question") return;

          const section = makeEl("section", "q depth-" + (item.depth || 0), {
            id: questionAnchorForKey(item.key),
            "data-qkey": item.key
          });

          const row = makeEl("div", "q-row");
          const num = makeEl("div", "q-num", { text: item.label });
          const body = makeEl("div", "q-body");

          const prompt = makeEl("div", "q-prompt");
          renderParts(prompt, item.promptParts);

          // Diagrams must remain inside question block (prompt area)
          if (item.diagrams && item.diagrams.length) {
            item.diagrams.forEach(d => {
              const wrap = makeEl("div", "diagram", {});
              wrap.innerHTML = diagramSVG(d.type, d.seed);
              prompt.appendChild(wrap);
            });
          }

          const answer = makeEl("div", "q-answer");
          const ansLabel = makeEl("span", "ans-label", { text: "Answer:" });
          answer.appendChild(ansLabel);
          renderParts(answer, item.answerParts);

          // Working
          const workingRow = makeEl("div", "working-row");

          const working = makeEl("div", "working", {});
          // Build working lines as blocks (KaTeX display) and occasional text
          item.workingParts.forEach(part => {
            const line = makeEl("div", null, {});
            renderParts(line, [part]);
            working.appendChild(line);
          });

          // Preview (1–2 lines max)
          const preview = makeEl("div", "working-preview", {});
          const previewLines = item.workingParts.slice(0, 2);
          if (previewLines.length) {
            previewLines.forEach(part => {
              const line = makeEl("div", null, {});
              renderParts(line, [part]);
              preview.appendChild(line);
            });
          } else {
            preview.textContent = "";
          }

          const expandedByDefault = !!item.workingDefaultExpanded; // dataset-specific
          const toggle = makeEl("button", "toggle", {
            type: "button",
            "aria-expanded": expandedByDefault ? "true" : "false"
          });
          toggle.textContent = expandedByDefault ? "Hide working" : "Show working";

          // State init
          if (!expandedByDefault) {
            working.hidden = true;
          } else {
            working.hidden = false;
          }
          preview.hidden = expandedByDefault;

          toggle.addEventListener("click", () => {
            const isExpanded = toggle.getAttribute("aria-expanded") === "true";
            const next = !isExpanded;
            toggle.setAttribute("aria-expanded", String(next));
            toggle.textContent = next ? "Hide working" : "Show working";
            working.hidden = !next;
            preview.hidden = next;
            // No focus movement, no auto scroll adjustments
          });

          workingRow.appendChild(toggle);
          workingRow.appendChild(preview);
          workingRow.appendChild(working);

          body.appendChild(prompt);
          body.appendChild(answer);
          body.appendChild(workingRow);

          row.appendChild(num);
          row.appendChild(body);
          section.appendChild(row);

          paperEl.appendChild(section);
        });

        // Render KaTeX now (or fallback if not loaded)
        katexRenderAll(paperEl);
      }

      // Active nav highlighting (quiet)
      function setupActiveTracking() {
        const allTargets = () => Array.from(paperEl.querySelectorAll("section.q[id]"));
        let io = null;

        function setCurrent(id) {
          const btns = navList.querySelectorAll(".nav-item[data-target]");
          btns.forEach(b => b.setAttribute("aria-current", (b.getAttribute("data-target") === id) ? "true" : "false"));
          const btns2 = drawerNav.querySelectorAll(".nav-item[data-target]");
          btns2.forEach(b => b.setAttribute("aria-current", (b.getAttribute("data-target") === id) ? "true" : "false"));
        }

        function initObserver() {
          if (io) io.disconnect();
          const targets = allTargets();
          if (!targets.length) return;

          io = new IntersectionObserver((entries) => {
            // choose the entry closest to top that is intersecting
            const visible = entries
              .filter(e => e.isIntersecting)
              .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
            if (visible.length) {
              setCurrent(visible[0].target.id);
            }
          }, {
            root: null,
            rootMargin: "-20% 0px -70% 0px",
            threshold: [0, 0.1]
          });

          targets.forEach(t => io.observe(t));
        }

        initObserver();
        return { refresh: initObserver };
      }

      // Drawer open/close with focus trap; background should not be keyboard-interactable
      function openDrawer() {
        if (!drawerBackdrop.hidden) return;
        lastFocus = document.activeElement;
        drawerBackdrop.hidden = false;
        document.body.style.overflow = "hidden";

        // Disable background from assistive tech & tabbing (basic)
        appShell.setAttribute("aria-hidden", "true");
        // Focus first focusable in drawer
        const focusTarget = drawerClose;
        focusTarget.focus();
      }

      function closeDrawer() {
        if (drawerBackdrop.hidden) return;
        drawerBackdrop.hidden = true;
        document.body.style.overflow = "";
        appShell.removeAttribute("aria-hidden");
        if (lastFocus && typeof lastFocus.focus === "function") {
          lastFocus.focus();
        } else {
          jumpBtn.focus();
        }
      }

      function trapFocus(e) {
        if (drawerBackdrop.hidden) return;
        if (e.key !== "Tab") return;

        const focusables = drawer.querySelectorAll('button, [href], select, textarea, input, [tabindex]:not([tabindex="-1"])');
        const list = Array.from(focusables).filter(el => !el.hasAttribute("disabled") && el.offsetParent !== null);
        if (!list.length) return;

        const first = list[0];
        const last = list[list.length - 1];
        const active = document.activeElement;

        if (e.shiftKey) {
          if (active === first || active === drawer) {
            e.preventDefault();
            last.focus();
          }
        } else {
          if (active === last) {
            e.preventDefault();
            first.focus();
          }
        }
      }

      function setupDrawer() {
        jumpBtn.addEventListener("click", openDrawer);
        drawerClose.addEventListener("click", closeDrawer);
        drawerBackdrop.addEventListener("click", (e) => {
          if (e.target === drawerBackdrop) closeDrawer();
        });
        document.addEventListener("keydown", (e) => {
          if (!drawerBackdrop.hidden && e.key === "Escape") {
            e.preventDefault();
            closeDrawer();
          }
          trapFocus(e);
        });
      }

      function mount(datasetId) {
        const ds = getDatasetById(datasetId);
        buildNav(ds, navList);
        buildNav(ds, drawerNav);
        buildPaper(ds);
      }

      // Ensure KaTeX renders after CDN load (if it loads after initial render)
      function waitForKatexThenRender() {
        const maxMs = 2500;
        const start = Date.now();
        (function tick() {
          const has = !!window.katex && typeof window.katex.render === "function";
          if (has) {
            katexRenderAll(paperEl);
            return;
          }
          if (Date.now() - start > maxMs) {
            // fallback already in place; do nothing
            return;
          }
          setTimeout(tick, 60);
        })();
      }

      // Init
      buildSelector();
      setupDrawer();

      // Default dataset
      paperSelect.value = "short";
      mount(paperSelect.value);

      const tracker = setupActiveTracking();
      paperSelect.addEventListener("change", () => {
        mount(paperSelect.value);
        tracker.refresh();
        waitForKatexThenRender();
      });

      waitForKatexThenRender();
    })();
  </script>
</body>

</html>